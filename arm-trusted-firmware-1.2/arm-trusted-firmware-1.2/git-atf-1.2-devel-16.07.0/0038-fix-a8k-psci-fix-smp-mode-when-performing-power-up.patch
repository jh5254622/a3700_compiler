From ec2b37548516435b56370b8926911e66d3396ab0 Mon Sep 17 00:00:00 2001
From: "hayim@marvell.com" <hayim@marvell.com>
Date: Mon, 7 Mar 2016 18:34:15 +0200
Subject: [PATCH 038/239] fix: a8k: psci: fix smp mode when performing power-up

- SMP mode works well when performing reset but on
  power down/up the CPUs fails to boot.
- This patch reverts some of the changes which were made
  in patch 0a10a87 and adds back the call to
  gic_init_secure_percpu during PSCI flow

Change-Id: I4c6ed159b6d44da654481205a120c31d109f33d6
Signed-off-by: hayim@marvell.com <hayim@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/28086
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Kostya Porotchkin <kostap@marvell.com>
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
---
 bl31/bl31.ld.S                                |   3 +-
 plat/marvell/a8k/a7040_rz/aarch64/plat_psci.S |  11 ++
 plat/marvell/a8k/a7040_rz/platform.mk         |   1 +
 plat/marvell/a8k/apn806/platform.mk           |   1 +
 plat/marvell/a8k/common/aarch64/gic_64.S      | 177 ++++++++++++++++++++++++++
 5 files changed, 192 insertions(+), 1 deletion(-)
 create mode 100644 plat/marvell/a8k/common/aarch64/gic_64.S

diff --git a/bl31/bl31.ld.S b/bl31/bl31.ld.S
index 8e1ca3c..969aa5c 100644
--- a/bl31/bl31.ld.S
+++ b/bl31/bl31.ld.S
@@ -186,8 +186,9 @@ SECTIONS
 
 #ifdef PLAT_MARVELL_7040_RZ1
     /* Note: this section must be aligned to 64K (for Mavell A8K platform) */
-    secure_scetion : ALIGN(0x10000) {
+    secure_section : ALIGN(0x10000) {
         *(._secure.text)
+        *(._secure_gic.text)
     } >RAM
 #endif
     ASSERT(. <= BL31_LIMIT, "BL31 image has exceeded its limit.")
diff --git a/plat/marvell/a8k/a7040_rz/aarch64/plat_psci.S b/plat/marvell/a8k/a7040_rz/aarch64/plat_psci.S
index 901d949..c966751 100644
--- a/plat/marvell/a8k/a7040_rz/aarch64/plat_psci.S
+++ b/plat/marvell/a8k/a7040_rz/aarch64/plat_psci.S
@@ -114,9 +114,20 @@ _armada8k_cpu_entry:
 	msr	cpacr_el1, x0			/* Enable FP/SIMD */
 0:
 
+#if 0
 	bl	gicv2_pcpu_distif_init
 
 	bl	gicv2_cpuif_enable
+#endif
+
+#if defined(CONFIG_GICV3)
+	ldr	x0, =PLAT_MARVELL_GICR_BASE
+	bl	gic_init_secure_percpu
+#elif defined(CONFIG_GICV2)
+	ldr	x0, =PLAT_MARVELL_GICD_BASE
+	ldr	x1, =PLAT_MARVELL_GICC_BASE
+	bl	gic_init_secure_percpu
+#endif
 
 	bl	psci_build_stack
 
diff --git a/plat/marvell/a8k/a7040_rz/platform.mk b/plat/marvell/a8k/a7040_rz/platform.mk
index 9256966..669b49a 100644
--- a/plat/marvell/a8k/a7040_rz/platform.mk
+++ b/plat/marvell/a8k/a7040_rz/platform.mk
@@ -75,6 +75,7 @@ MARVELL_DRV		:= 	$(MARVELL_DRV_BASE)/rfu.c	\
 BL31_SOURCES		+=	lib/cpus/aarch64/cortex_a72.S				\
 				$(PLAT_SRC_BASE)/aarch64/plat_helpers.S			\
 				$(PLAT_SRC_BASE)/aarch64/plat_psci.S			\
+				$(PLAT_FAMILY_BASE)/common/aarch64/gic_64.S		\
 				$(PLAT_SRC_BASE)/plat_pm.c				\
 				$(PLAT_SRC_BASE)/plat_topology.c			\
 				$(PLAT_SRC_BASE)/plat_bl31_setup.c			\
diff --git a/plat/marvell/a8k/apn806/platform.mk b/plat/marvell/a8k/apn806/platform.mk
index c022f78..03874b9 100644
--- a/plat/marvell/a8k/apn806/platform.mk
+++ b/plat/marvell/a8k/apn806/platform.mk
@@ -77,6 +77,7 @@ MARVELL_DRV		:= 	$(MARVELL_DRV_BASE)/rfu.c	\
 BL31_SOURCES		+=	lib/cpus/aarch64/cortex_a72.S				\
 				$(PLAT_SRC_BASE)/aarch64/plat_helpers.S			\
 				$(PLAT_SRC_BASE)/aarch64/plat_psci.S			\
+				$(PLAT_FAMILY_BASE)/common/aarch64/gic_64.S		\
 				$(PLAT_SRC_BASE)/plat_pm.c				\
 				$(PLAT_SRC_BASE)/plat_topology.c			\
 				$(PLAT_APN_SRC_BASE)/plat_bl31_setup.c			\
diff --git a/plat/marvell/a8k/common/aarch64/gic_64.S b/plat/marvell/a8k/common/aarch64/gic_64.S
new file mode 100644
index 0000000..cafe783
--- /dev/null
+++ b/plat/marvell/a8k/common/aarch64/gic_64.S
@@ -0,0 +1,177 @@
+/*
+ * GIC Initialization Routines.
+ *
+ * (C) Copyright 2013
+ * David Feng <fenghua@phytium.com.cn>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/linkage.h>
+#include <gicv2.h>
+#include <gic_common.h>
+
+#define GICD_IGROUPRn		0x0080
+#define GICD_IGROUPMODRn	0x0d00
+#define GICD_ISENABLERn		0x0100
+
+
+/*************************************************************************
+ *
+ * void gic_init_secure(DistributorBase);
+ *
+ * Initialize secure copy of GIC at EL3.
+ *
+ *************************************************************************/
+ENTRY(gic_init_secure)
+	/*
+	 * Initialize Distributor
+	 * x0: Distributor Base
+	 */
+#if defined(CONFIG_GICV3)
+	mov	w9, #0x37		/* EnableGrp0 | EnableGrp1NS */
+					/* EnableGrp1S | ARE_S | ARE_NS */
+	str	w9, [x0, GICD_CTLR]	/* Secure GICD_CTLR */
+	ldr	w9, [x0, GICD_TYPER]
+	and	w10, w9, #0x1f		/* ITLinesNumber */
+	cbz	w10, 1f			/* No SPIs */
+	add	x11, x0, (GICD_IGROUPRn + 4)
+	add	x12, x0, (GICD_IGROUPMODRn + 4)
+	mov	w9, #~0
+0:	str	w9, [x11], #0x4
+	str	wzr, [x12], #0x4	/* Config SPIs as Group1NS */
+	sub	w10, w10, #0x1
+	cbnz	w10, 0b
+#elif defined(CONFIG_GICV2)
+	mov	w9, #0x3		/* EnableGrp0 | EnableGrp1 */
+	str	w9, [x0, GICD_CTLR]	/* Secure GICD_CTLR */
+	ldr	w9, [x0, GICD_TYPER]
+	and	w10, w9, #0x1f		/* ITLinesNumber */
+	cbz	w10, 1f			/* No SPIs */
+	add	x11, x0, (GICD_IGROUPRn + 4)
+	mov	w9, #~0			/* Config SPIs as Grp1 */
+0:	str	w9, [x11], #0x4
+	sub	w10, w10, #0x1
+	cbnz	w10, 0b
+#endif
+1:
+	ret
+ENDPROC(gic_init_secure)
+
+/* insert gic_init_secure_percpu function to secure section - part of the PSCI FW */
+.pushsection ._secure_gic.text, "ax"
+
+/*************************************************************************
+ * For Gicv2:
+ * void gic_init_secure_percpu(DistributorBase, CpuInterfaceBase);
+ * For Gicv3:
+ * void gic_init_secure_percpu(ReDistributorBase);
+ *
+ * Initialize secure copy of GIC at EL3.
+ *
+ *************************************************************************/
+ENTRY(gic_init_secure_percpu)
+#if defined(CONFIG_GICV3)
+	/*
+	 * Initialize ReDistributor
+	 * x0: ReDistributor Base
+	 */
+	mrs	x10, mpidr_el1
+	lsr	x9, x10, #32
+	bfi	x10, x9, #24, #8	/* w10 is aff3:aff2:aff1:aff0 */
+	mov	x9, x0
+1:	ldr	x11, [x9, GICR_TYPER]
+	lsr	x11, x11, #32		/* w11 is aff3:aff2:aff1:aff0 */
+	cmp	w10, w11
+	b.eq	2f
+	add	x9, x9, #(2 << 16)
+	b	1b
+
+	/* x9: ReDistributor Base Address of Current CPU */
+2:	mov	w10, #~0x2
+	ldr	w11, [x9, GICR_WAKER]
+	and	w11, w11, w10		/* Clear ProcessorSleep */
+	str	w11, [x9, GICR_WAKER]
+	dsb	st
+	isb
+3:	ldr	w10, [x9, GICR_WAKER]
+	tbnz	w10, #2, 3b		/* Wait Children be Alive */
+
+	add	x10, x9, #(1 << 16)	/* SGI_Base */
+	mov	w11, #~0
+	str	w11, [x10, GICR_IGROUPRn]
+	str	wzr, [x10, GICR_IGROUPMODRn]	/* SGIs|PPIs Group1NS */
+	mov	w11, #0x1		/* Enable SGI 0 */
+	str	w11, [x10, GICR_ISENABLERn]
+
+	/* Initialize Cpu Interface */
+	mrs	x10, ICC_SRE_EL3
+	orr	x10, x10, #0xf		/* SRE & Disable IRQ/FIQ Bypass & */
+					/* Allow EL2 access to ICC_SRE_EL2 */
+	msr	ICC_SRE_EL3, x10
+	isb
+
+	mrs	x10, ICC_SRE_EL2
+	orr	x10, x10, #0xf		/* SRE & Disable IRQ/FIQ Bypass & */
+					/* Allow EL1 access to ICC_SRE_EL1 */
+	msr	ICC_SRE_EL2, x10
+	isb
+
+	mov	x10, #0x3		/* EnableGrp1NS | EnableGrp1S */
+	msr	ICC_IGRPEN1_EL3, x10
+	isb
+
+	msr	ICC_CTLR_EL3, xzr
+	isb
+
+	msr	ICC_CTLR_EL1, xzr	/* NonSecure ICC_CTLR_EL1 */
+	isb
+
+	mov	x10, #0x1 << 7		/* Non-Secure access to ICC_PMR_EL1 */
+	msr	ICC_PMR_EL1, x10
+	isb
+#elif defined(CONFIG_GICV2)
+	/*
+	 * Initialize SGIs and PPIs
+	 * x0: Distributor Base
+	 * x1: Cpu Interface Base
+	 */
+	mov	w9, #~0			/* Config SGIs and PPIs as Grp1 */
+	str	w9, [x0, GICD_IGROUPRn]	/* GICD_IGROUPR0 */
+	mov	w9, #0x1		/* Enable SGI 0 */
+	str	w9, [x0, GICD_ISENABLERn]
+
+	/* Initialize Cpu Interface */
+	mov	w9, #0x1e7		/* Disable IRQ/FIQ Bypass & */
+					/* Enable Ack Group1 Interrupt & */
+					/* EnableGrp0 & EnableGrp1 */
+	str	w9, [x1, GICC_CTLR]	/* Secure GICC_CTLR */
+
+	mov	w9, #0x1 << 7		/* Non-Secure access to GICC_PMR */
+	str	w9, [x1, GICC_PMR]
+#endif
+	ret
+ENDPROC(gic_init_secure_percpu)
+
+
+/*************************************************************************
+ * For Gicv2:
+ * void gic_kick_secondary_cpus(DistributorBase);
+ * For Gicv3:
+ * void gic_kick_secondary_cpus(void);
+ *
+ *************************************************************************/
+ENTRY(gic_kick_secondary_cpus)
+#if defined(CONFIG_GICV3)
+	mov	x9, #(1 << 40)
+	msr	ICC_ASGI1R_EL1, x9
+	isb
+#elif defined(CONFIG_GICV2)
+	mov	w9, #0x8000
+	movk	w9, #0x100, lsl #16
+	str	w9, [x0, GICD_SGIR]
+#endif
+	ret
+ENDPROC(gic_kick_secondary_cpus)
+
+
-- 
1.9.1

