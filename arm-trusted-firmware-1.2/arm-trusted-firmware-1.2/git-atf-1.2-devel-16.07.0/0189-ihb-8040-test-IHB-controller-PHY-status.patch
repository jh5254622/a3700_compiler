From 3d353916b29de7097bdd194ef99215d3abd111b0 Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Mon, 23 May 2016 18:34:04 +0300
Subject: [PATCH 189/239] ihb: 8040: test IHB controller & PHY status

on Armada-8040, CP1 is connected via IHB0.

Prior to configuring CP1 interface, added an inquiry for IHB
controller & PHY link properties.

Change-Id: I315439839663ae3cd159e580c4ec3902e6b7d8d9
Signed-off-by: Omri Itach <omrii@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/29892
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Haim Boot <hayim@marvell.com>
---
 .../plat/marvell/a8k/a70x0/board/apn806_setup.h    |   1 +
 plat/marvell/a8k/a70x0/apn806_setup.c              | 104 +++++++++++++++++++--
 plat/marvell/a8k/a70x0/plat_bl31_setup.c           |   6 ++
 3 files changed, 101 insertions(+), 10 deletions(-)

diff --git a/include/plat/marvell/a8k/a70x0/board/apn806_setup.h b/include/plat/marvell/a8k/a70x0/board/apn806_setup.h
index feffd05..f1f3be8 100644
--- a/include/plat/marvell/a8k/a70x0/board/apn806_setup.h
+++ b/include/plat/marvell/a8k/a70x0/board/apn806_setup.h
@@ -35,5 +35,6 @@
 #define __APN806_SETUP_H__
 
 void apn806_init(void);
+int ihb_test_link(int ihb_index);
 
 #endif /* __APN806_SETUP_H__ */
diff --git a/plat/marvell/a8k/a70x0/apn806_setup.c b/plat/marvell/a8k/a70x0/apn806_setup.c
index 985f678..c28e04d 100644
--- a/plat/marvell/a8k/a70x0/apn806_setup.c
+++ b/plat/marvell/a8k/a70x0/apn806_setup.c
@@ -38,19 +38,48 @@
 #include <ccu.h>
 #include <mmio.h>
 #include <cache_llc.h>
+#include <debug.h>
 
-#define SMMU_sACR		(MVEBU_SMMU_BASE + 0x10)
-#define SMMU_sACR_PG_64K	(1 << 16)
+#define SMMU_sACR				(MVEBU_SMMU_BASE + 0x10)
+#define SMMU_sACR_PG_64K			(1 << 16)
 
-#define CCU_GSPMU_CR		(MVEBU_CCU_BASE + 0x3F0)
-#define GSPMU_CPU_CONTROL	(0x1 << 0)
+#define CCU_GSPMU_CR				(MVEBU_CCU_BASE + 0x3F0)
+#define GSPMU_CPU_CONTROL			(0x1 << 0)
 
-#define IHB_MAX_UNIT_ID		2
+#define IHB_MAX_UNIT_ID				2
 #define IHBX4_REG_START_ADDRESS_REG(unit_id)	(MVEBU_REGS_BASE + 0x6F4218 + (unit_id * 0x20))
-#define IHB_REMAP_OFF_SHIFT	8
-
-
-void setup_ihb(void)
+#define IHB_REMAP_OFF_SHIFT			8
+
+/* IHB indirect access defintions */
+#define IHB_WRITE_READ_DATA_REG(ihb_index)	MVEBU_IHB_REG_BASE_REMAP(ihb_index)
+#define IHB_ACCESS_CMD_REG(ihb_index)		(MVEBU_IHB_REG_BASE_REMAP(ihb_index) + 0x4)
+
+#define IHB_CTRL_STATUS_REG_NUM			5
+#define IHB_CTRL_PHY_READY			0x0f009000 /* expected successful Link result */
+
+#define IHB_PHY_PWM3_REG_NUM			7
+#define PWM3_LINK_ERROR_OFFSET			8	/* [11:8] : LINK_ERROR */
+#define PWM3_LINK_ERROR_MASK			(0xF << PWM3_LINK_ERROR_OFFSET)
+#define PWM4_NUM_OF_LANES_OFFSET		20	/* [20:22] : AUTO_NUMBER_OF_LANES */
+#define PWM4_NUM_OF_LANES_MASK			(0x7 << PWM4_NUM_OF_LANES_OFFSET)
+#define PWM4_LINK_SPEED_MASK			0x7	/* [3:0] AUTO_SPEED */
+
+#define IHB_PHY_ACCESS_ENABLE			(1 << 22 | 1 << 23)
+#define IHB_INDIRECT_REG_CTRL_ADDR(reg_num)	((reg_num << 16) | 0x21)
+
+#define IHB_REG_ENABLE_PHY_ADDR			((0x7 << 16) | 0x20)
+#define IHB_REG_ENABLE_PHY_DATA			0x03002016
+
+enum ihb_register_type {
+	IHB_REG_TYPE_PHY = 0,
+	IHB_REG_TYPE_CTRL,
+};
+
+/* IHBx indirect access register are based by default at 0xf4000000/0xf6000000
+ * to avoid conflict of internal registers of units connected via IHBx, which
+ * can be based on the same address (i.e CP1 base is also 0xf4000000),
+ * the following routines remaps the IHBx indirect bases to another domain */
+void ihb_remap_indirect_access_base(void)
 {
 	uint32_t i;
 
@@ -58,6 +87,61 @@ void setup_ihb(void)
 		mmio_write_32(IHBX4_REG_START_ADDRESS_REG(i), MVEBU_IHB_REG_BASE_REMAP(i) >> IHB_REMAP_OFF_SHIFT);
 }
 
+/* routine to enable access to PHY registers over IHB0 indirect read/write*/
+void ihb_enable_phy_regs_access(int ihb_index)
+{
+	/* Enable PHY local access (reg 7 bit 25) */
+	mmio_write_32(IHB_WRITE_READ_DATA_REG(ihb_index), IHB_REG_ENABLE_PHY_DATA);
+	mmio_write_32(IHB_ACCESS_CMD_REG(ihb_index), IHB_REG_ENABLE_PHY_ADDR);
+}
+
+/* read ihb0 PHY/CTRL registers via indirect access */
+uint32_t ihb_indirect_read(int reg_num, enum ihb_register_type reg_type, int ihb_index)
+{
+	uint32_t indirect_reg_address = 0;
+
+	/* Access to PHY registers requires special configuration */
+	if (reg_type == IHB_REG_TYPE_PHY)
+		indirect_reg_address |= IHB_PHY_ACCESS_ENABLE;
+
+	indirect_reg_address |= IHB_INDIRECT_REG_CTRL_ADDR(reg_num);
+
+	mmio_write_32(IHB_ACCESS_CMD_REG(ihb_index), indirect_reg_address);
+	return mmio_read_32(IHB_WRITE_READ_DATA_REG(ihb_index));
+}
+
+int ihb_test_link(int ihb_index)
+{
+	uint32_t ctrl_status, phy_status, link_error, lane_count;
+	uint32_t link_result[5] = {1, 2, 4, 8, 16}; /* link speed and lane count */
+
+	NOTICE("IHB0 link status.. ");
+	ihb_enable_phy_regs_access(ihb_index);	/* enable PHY domain read/write access */
+
+	/* IHB Controller link status*/
+	ctrl_status = ihb_indirect_read(IHB_CTRL_STATUS_REG_NUM, IHB_REG_TYPE_CTRL, ihb_index);
+
+	/* IHB PHY link status: PWM Control #3*/
+	phy_status = ihb_indirect_read(IHB_PHY_PWM3_REG_NUM, IHB_REG_TYPE_PHY, ihb_index);
+
+	if (ctrl_status != IHB_CTRL_PHY_READY) {
+		printf(" link failed (IHB status: 0x%x, PWM_CTRL #3 = 0x%x)\n", ctrl_status, phy_status);
+		return 0;
+	}
+
+	printf("Link UP:");
+	link_error = (phy_status & PWM3_LINK_ERROR_MASK) >> PWM3_LINK_ERROR_OFFSET;
+	if (link_error)
+		ERROR("\n\tlink Error #%d: (IHB status: 0%x):", link_error, ctrl_status);
+
+	lane_count = (phy_status & PWM4_NUM_OF_LANES_MASK) >> PWM4_NUM_OF_LANES_OFFSET;
+	printf(" %d lanes ", link_result[lane_count]);
+	printf("@ %d Gbps", link_result[(phy_status & PWM4_LINK_SPEED_MASK)]);
+	printf(" (PWM_CTRL #3 = 0x%x)\n", phy_status);
+
+	return 1;
+}
+
 void setup_smmu(void)
 {
 	uint32_t reg;
@@ -94,7 +178,7 @@ void apn806_init(void)
 	init_aurora2();
 
 	/* configure IHB mapping */
-	setup_ihb();
+	ihb_remap_indirect_access_base();
 
 	/* configure RFU windows */
 	init_rfu();
diff --git a/plat/marvell/a8k/a70x0/plat_bl31_setup.c b/plat/marvell/a8k/a70x0/plat_bl31_setup.c
index a28fafe..2d8205e 100644
--- a/plat/marvell/a8k/a70x0/plat_bl31_setup.c
+++ b/plat/marvell/a8k/a70x0/plat_bl31_setup.c
@@ -57,6 +57,12 @@ void bl31_plat_arch_setup(void)
 	/* configure apn806 */
 	apn806_init();
 
+	/* test IHB0 (CP1) status and disable indirect access.
+	 * when all CP1 interfaces will be supported, they will be
+	 * initialized by calling cp110_init again for 2nd CP */
+	if (CP_COUNT > 1)
+		ihb_test_link(0); /* test IHB0 link */
+
 	/* configure cp110 */
 	cp110_init();
 }
-- 
1.9.1

