From 3bac4cef7feaef607c6a6bfb6b5eac51a89d8e88 Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Tue, 8 Sep 2015 13:55:17 +0300
Subject: [PATCH 083/538] bus: mvebu-mbus: Optimize MBUS and Fabric settings
 for Armada 38x SoCs

In some of Marvell's SoCs, the MBUS performance can be tuned and optimized
through special registers in the MBUS unit.

This patch adds the following:
- Add optional optimization function in the mbus per SoC struct
- Implement dedicated Armada 38x mbus optimization function:
  * Prioritize XOR, PCIe and GbEs (ID=4,6,3,7,8) DRAM access
  * Prioritize CPUs requests
  * Pre-fetch enable for all IO masters
  * Enable the CPUs Instruction and Data prefetch

Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/23493
Reviewed-by: Neta Zur Hershkovits <neta@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/23639

fix check-patch errors: lines over 80 chars; wrong block comments
Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>

Conflicts:
	arch/arm/boot/dts/armada-38x.dtsi

Change-Id: I041ebfaa0c9f2d98c6e7b7754e6fef4e164477dd
Reviewed-on: http://vgitil04.il.marvell.com:8080/27316
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Reviewed-by: Lior Amsalem <alior@marvell.com>
Tested-by: Lior Amsalem <alior@marvell.com>
---
 .../devicetree/bindings/bus/mvebu-mbus.txt         |  4 +-
 arch/arm/boot/dts/armada-38x.dtsi                  |  3 +-
 drivers/bus/mvebu-mbus.c                           | 63 ++++++++++++++++++++--
 3 files changed, 65 insertions(+), 5 deletions(-)

diff --git a/Documentation/devicetree/bindings/bus/mvebu-mbus.txt b/Documentation/devicetree/bindings/bus/mvebu-mbus.txt
index fa6cde4..2be9ffe 100644
--- a/Documentation/devicetree/bindings/bus/mvebu-mbus.txt
+++ b/Documentation/devicetree/bindings/bus/mvebu-mbus.txt
@@ -48,12 +48,14 @@ Required properties:
 - compatible:	Should be set to "marvell,mbus-controller".
 
 - reg:          Device's register space.
-		Two or three entries are expected (see the examples below):
+		Two to four entries are expected (see the examples below):
 		the first one controls the devices decoding window,
 		the second one controls the SDRAM decoding window and
 		the third controls the MBus bridge (only with the
 		marvell,armada370-mbus and marvell,armadaxp-mbus
 		compatible strings)
+		the optional forth entry controls the MBus optimization registers
+		(currently only with marvell,armada380-mbus)
 
 Example:
 
diff --git a/arch/arm/boot/dts/armada-38x.dtsi b/arch/arm/boot/dts/armada-38x.dtsi
index 82c3a89..daeda5b 100644
--- a/arch/arm/boot/dts/armada-38x.dtsi
+++ b/arch/arm/boot/dts/armada-38x.dtsi
@@ -396,7 +396,8 @@
 
 			mbusc: mbus-controller@20000 {
 				compatible = "marvell,mbus-controller";
-				reg = <0x20000 0x100>, <0x20180 0x20>, <0x20250 0x8>;
+				reg = <0x20000 0x100>, <0x20180 0x20>,
+				      <0x20250 0x8>, <0x20420 0xc>;
 			};
 
 			mpic: interrupt-controller@20a00 {
diff --git a/drivers/bus/mvebu-mbus.c b/drivers/bus/mvebu-mbus.c
index c43c3d2..8ee08a3 100644
--- a/drivers/bus/mvebu-mbus.c
+++ b/drivers/bus/mvebu-mbus.c
@@ -120,6 +120,7 @@ struct mvebu_mbus_soc_data {
 			       u32 *store_addr);
 	int (*show_cpu_target)(struct mvebu_mbus_state *s,
 			       struct seq_file *seq, void *v);
+	void (*mbus_optimizations)(struct mvebu_mbus_state *s);
 };
 
 /*
@@ -136,6 +137,7 @@ struct mvebu_mbus_state {
 	void __iomem *mbuswins_base;
 	void __iomem *sdramwins_base;
 	void __iomem *mbusbridge_base;
+	void __iomem *mbusopt_base;
 	phys_addr_t sdramwins_phys_base;
 	struct dentry *debugfs_root;
 	struct dentry *debugfs_sdram;
@@ -801,6 +803,45 @@ int mvebu_mbus_save_cpu_target(u32 *store_addr)
 	return mbus_state.soc->save_cpu_target(&mbus_state, store_addr);
 }
 
+static void armada_380_mbus_optimizations(struct mvebu_mbus_state *mbus)
+{
+	/*
+	 * MBUS Units Priority Control Register -
+	 * Prioritize XOR, PCIe and GbEs (ID=4,6,3,7,8) DRAM access
+	 * GbE is High and others are Med
+	 */
+	__raw_writel(0x19180, mbus->mbusopt_base);
+
+	/*
+	 * Fabric Units Priority Control Register -
+	 * Prioritize CPUs requests
+	 */
+	__raw_writel(0x3000A, mbus->mbusopt_base + 0x4);
+
+	/*
+	 * MBUS Units Prefetch Control Register -
+	 * Pre-fetch enable for all IO masters
+	 */
+	__raw_writel(0xFFFF, mbus->mbusopt_base + 0x8);
+
+	/*
+	 * Fabric Units Prefetch Control Register -
+	 * Enable the CPUs Instruction and Data prefetch
+	 */
+	__raw_writel(0x303, mbus->mbusopt_base + 0xC);
+}
+
+static const struct mvebu_mbus_soc_data armada_380_mbus_data = {
+	.num_wins            = 20,
+	.has_mbus_bridge     = true,
+	.win_cfg_offset      = armada_370_xp_mbus_win_cfg_offset,
+	.win_remap_offset    = armada_xp_mbus_win_remap_offset,
+	.setup_cpu_target    = mvebu_mbus_default_setup_cpu_target,
+	.show_cpu_target     = mvebu_sdram_debug_show_orion,
+	.save_cpu_target     = mvebu_mbus_default_save_cpu_target,
+	.mbus_optimizations  = armada_380_mbus_optimizations,
+};
+
 static const struct mvebu_mbus_soc_data armada_370_mbus_data = {
 	.num_wins            = 20,
 	.has_mbus_bridge     = true,
@@ -876,7 +917,7 @@ static const struct of_device_id of_mvebu_mbus_ids[] = {
 	{ .compatible = "marvell,armada375-mbus",
 	  .data = &armada_xp_mbus_data, },
 	{ .compatible = "marvell,armada380-mbus",
-	  .data = &armada_xp_mbus_data, },
+	  .data = &armada_380_mbus_data, },
 	{ .compatible = "marvell,armadaxp-mbus",
 	  .data = &armada_xp_mbus_data, },
 	{ .compatible = "marvell,kirkwood-mbus",
@@ -1049,6 +1090,8 @@ static int __init mvebu_mbus_common_init(struct mvebu_mbus_state *mbus,
 					 size_t sdramwins_size,
 					 phys_addr_t mbusbridge_phys_base,
 					 size_t mbusbridge_size,
+					 phys_addr_t mbusopt_phys_base,
+					 size_t mbusopt_size,
 					 bool is_coherent)
 {
 	int win;
@@ -1076,6 +1119,11 @@ static int __init mvebu_mbus_common_init(struct mvebu_mbus_state *mbus,
 	} else
 		mbus->mbusbridge_base = NULL;
 
+	if (mbusopt_phys_base) {
+		mbus->mbusopt_base = ioremap(mbusopt_phys_base, sdramwins_size);
+		mbus->soc->mbus_optimizations(mbus);
+	}
+
 	for (win = 0; win < mbus->soc->num_wins; win++)
 		mvebu_mbus_disable_window(mbus, win);
 
@@ -1113,7 +1161,7 @@ int __init mvebu_mbus_init(const char *soc, phys_addr_t mbuswins_phys_base,
 			mbuswins_phys_base,
 			mbuswins_size,
 			sdramwins_phys_base,
-			sdramwins_size, 0, 0, false);
+			sdramwins_size, 0, 0, 0, 0, false);
 }
 
 #ifdef CONFIG_OF
@@ -1254,7 +1302,8 @@ static void __init mvebu_mbus_get_pcie_resources(struct device_node *np,
 
 int __init mvebu_mbus_dt_init(bool is_coherent)
 {
-	struct resource mbuswins_res, sdramwins_res, mbusbridge_res;
+	struct resource mbuswins_res, sdramwins_res, mbusbridge_res,
+	       mbusopt_res;
 	struct device_node *np, *controller;
 	const struct of_device_id *of_id;
 	const __be32 *prop;
@@ -1297,12 +1346,18 @@ int __init mvebu_mbus_dt_init(bool is_coherent)
 	 * compatibility.
 	 */
 	memset(&mbusbridge_res, 0, sizeof(mbusbridge_res));
+	memset(&mbusopt_res, 0, sizeof(mbusopt_res));
 
 	if (mbus_state.soc->has_mbus_bridge) {
 		if (of_address_to_resource(controller, 2, &mbusbridge_res))
 			pr_warn(FW_WARN "deprecated mbus-mvebu Device Tree, suspend/resume will not work\n");
 	}
 
+	if (mbus_state.soc->mbus_optimizations) {
+		if (of_address_to_resource(controller, 3, &mbusopt_res))
+			pr_warn(FW_WARN "deprecated mbus-mvebu Device Tree, MBUS performance is not optimized\n");
+	}
+
 	mbus_state.hw_io_coherency = is_coherent;
 
 	/* Get optional pcie-{mem,io}-aperture properties */
@@ -1316,6 +1371,8 @@ int __init mvebu_mbus_dt_init(bool is_coherent)
 				     resource_size(&sdramwins_res),
 				     mbusbridge_res.start,
 				     resource_size(&mbusbridge_res),
+				     mbusopt_res.start,
+				     resource_size(&mbusopt_res),
 				     is_coherent);
 	if (ret)
 		return ret;
-- 
1.9.1

