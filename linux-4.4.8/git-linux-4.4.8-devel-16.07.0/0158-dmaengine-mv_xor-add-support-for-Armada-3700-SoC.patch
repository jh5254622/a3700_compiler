From b86cc9e5de661d2dae729d3fe7b73f30fe6415ad Mon Sep 17 00:00:00 2001
From: Marcin Wojtas <mw@semihalf.com>
Date: Mon, 4 Jan 2016 17:00:34 +0100
Subject: [PATCH 158/538] dmaengine: mv_xor: add support for Armada 3700 SoC

Armada 3700 SoC comprise single XOR engine compliant with ones used in
older Marvell SoC's like Armada XP or 38x. The only thing that needed
modification is Mbus configuration, which has to be done on two levels:
global and in device. The first one is inherited from the bootlader.
The latter can be opened in a default way, leaving arbitration to the bus
controller. Hence filled mbus_dram_target_info structure is not needed.

Patch "dmaengine: mv_xor: optimize performance by using a subset
of the XOR channels" introduced limitation for using XOR engines and
channels vs number of available CPU's. Those contstraints do not however
fit Armada 3700 architecture with two possible CPU's and single,
dual-channel engine. Hence in this commit an adjustment for setting
maximum available channels is added.

This patch enables XOR access to DRAM by opening default window to 4GB
space with specific attribute. Also a new compatible string is introduced
in order to differentiate machines. Moreover a proper casting was
introduced, so that both 32 and 64 bit architectures can be satisfied
without compilation warnings.

Change-Id: I174a9c6b4b10e7a5eee9acac4adf9b3e396283cc
Signed-off-by: Marcin Wojtas <mw@semihalf.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/27673
Reviewed-by: Lior Amsalem <alior@marvell.com>
Tested-by: Nadav Haklai <nadavh@marvell.com>
---
 Documentation/devicetree/bindings/dma/mv-xor.txt |  3 +-
 drivers/dma/mv_xor.c                             | 53 +++++++++++++++++-------
 drivers/dma/mv_xor.h                             |  1 +
 3 files changed, 41 insertions(+), 16 deletions(-)

diff --git a/Documentation/devicetree/bindings/dma/mv-xor.txt b/Documentation/devicetree/bindings/dma/mv-xor.txt
index 276ef81..900328d 100644
--- a/Documentation/devicetree/bindings/dma/mv-xor.txt
+++ b/Documentation/devicetree/bindings/dma/mv-xor.txt
@@ -1,7 +1,8 @@
 * Marvell XOR engines
 
 Required properties:
-- compatible: Should be "marvell,orion-xor" or "marvell,armada-380-xor"
+- compatible: Should be "marvell,orion-xor", "marvell,armada-380-xor"
+    or "marvell,armada-3700-xor".
 - reg: Should contain registers location and length (two sets)
     the first set is the low registers, the second set the high
     registers for the XOR engine.
diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c
index b250f63..6914aed 100644
--- a/drivers/dma/mv_xor.c
+++ b/drivers/dma/mv_xor.c
@@ -478,7 +478,7 @@ mv_xor_prep_dma_xor(struct dma_chan *chan, dma_addr_t dest, dma_addr_t *src,
 
 	dev_dbg(mv_chan_to_devp(mv_chan),
 		"%s src_cnt: %d len: %u dest %pad flags: %ld\n",
-		__func__, src_cnt, len, &dest, flags);
+		__func__, src_cnt, (unsigned int)len, &dest, flags);
 
 	sw_desc = mv_chan_alloc_slot(mv_chan);
 	if (sw_desc) {
@@ -1067,16 +1067,28 @@ mv_xor_conf_mbus_windows(struct mv_xor_device *xordev,
 			writel(0, base + WINDOW_REMAP_HIGH(i));
 	}
 
-	for (i = 0; i < dram->num_cs; i++) {
-		const struct mbus_dram_window *cs = dram->cs + i;
+	if (dram) {
+		for (i = 0; i < dram->num_cs; i++) {
+			const struct mbus_dram_window *cs = dram->cs + i;
 
-		writel((cs->base & 0xffff0000) |
-		       (cs->mbus_attr << 8) |
-		       dram->mbus_dram_target_id, base + WINDOW_BASE(i));
-		writel((cs->size - 1) & 0xffff0000, base + WINDOW_SIZE(i));
+			writel((cs->base & 0xffff0000) |
+			       (cs->mbus_attr << 8) |
+			       dram->mbus_dram_target_id,
+			       base + WINDOW_BASE(i));
+			writel((cs->size - 1) & 0xffff0000,
+			       base + WINDOW_SIZE(i));
 
-		win_enable |= (1 << i);
-		win_enable |= 3 << (16 + (2 * i));
+			win_enable |= (1 << i);
+			win_enable |= 3 << (16 + (2 * i));
+		}
+	} else {
+		/*
+		 * For Armada3700 open default 4GB Mbus window, leaving
+		 * specific configuration to a different layer.
+		 */
+		writel(0xffff0000, base + WINDOW_SIZE(0));
+		win_enable |= 1;
+		win_enable |= 3 << 16;
 	}
 
 	writel(win_enable, base + WINDOW_BAR_ENABLE(0));
@@ -1130,7 +1142,7 @@ static int mv_xor_resume(struct platform_device *dev)
 	}
 
 	dram = mv_mbus_dram_info();
-	if (dram)
+	if (dram || xordev->xor_armada3700)
 		mv_xor_conf_mbus_windows(xordev, dram);
 
 	return 0;
@@ -1139,6 +1151,7 @@ static int mv_xor_resume(struct platform_device *dev)
 static const struct of_device_id mv_xor_dt_ids[] = {
 	{ .compatible = "marvell,orion-xor", .data = (void *)XOR_MODE_IN_REG },
 	{ .compatible = "marvell,armada-380-xor", .data = (void *)XOR_MODE_IN_DESC },
+	{ .compatible = "marvell,armada-3700-xor", .data = (void *)XOR_MODE_IN_DESC },
 	{},
 };
 
@@ -1147,12 +1160,13 @@ static unsigned int mv_xor_engine_count;
 static int mv_xor_probe(struct platform_device *pdev)
 {
 	const struct mbus_dram_target_info *dram;
+	struct device_node *dn = pdev->dev.of_node;
 	struct mv_xor_device *xordev;
 	struct mv_xor_platform_data *pdata = dev_get_platdata(&pdev->dev);
 	struct resource *res;
 	unsigned int max_engines, max_channels;
 	int i, ret;
-	int op_in_desc;
+	long op_in_desc;
 
 	dev_notice(&pdev->dev, "Marvell shared XOR driver\n");
 
@@ -1180,11 +1194,18 @@ static int mv_xor_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, xordev);
 
+	/* Get special Soc configurations */
+	if (of_device_is_compatible(dn, "marvell,armada-3700-xor"))
+		xordev->xor_armada3700 = true;
+
 	/*
 	 * (Re-)program MBUS remapping windows if we are asked to.
+	 * Armada3700 requires setting default configuration of Mbus
+	 * windows, however without using filled mbus_dram_target_info
+	 * structure.
 	 */
 	dram = mv_mbus_dram_info();
-	if (dram)
+	if (dram || xordev->xor_armada3700)
 		mv_xor_conf_mbus_windows(xordev, dram);
 
 	/* Not all platforms can gate the clock, so it is not
@@ -1199,10 +1220,12 @@ static int mv_xor_probe(struct platform_device *pdev)
 	 * order for async_tx to perform well. So we limit the number
 	 * of engines and channels so that we take into account this
 	 * constraint. Note that we also want to use channels from
-	 * separate engines when possible.
+	 * separate engines when possible. For dual-CPU Armada 3700
+	 * SoC with single XOR engine allow using its both channels.
 	 */
 	max_engines = num_present_cpus();
-	max_channels = min_t(unsigned int,
+	max_channels = xordev->xor_armada3700 ? num_present_cpus() :
+		       min_t(unsigned int,
 			     MV_XOR_MAX_CHANNELS,
 			     DIV_ROUND_UP(num_present_cpus(), 2));
 
@@ -1220,7 +1243,7 @@ static int mv_xor_probe(struct platform_device *pdev)
 			struct mv_xor_chan *chan;
 			dma_cap_mask_t cap_mask;
 			int irq;
-			op_in_desc = (int)of_id->data;
+			op_in_desc = (long)of_id->data;
 
 			if (i >= max_channels)
 				continue;
diff --git a/drivers/dma/mv_xor.h b/drivers/dma/mv_xor.h
index c19fe30..1ed44ad 100644
--- a/drivers/dma/mv_xor.h
+++ b/drivers/dma/mv_xor.h
@@ -85,6 +85,7 @@ struct mv_xor_device {
 	void __iomem	     *xor_high_base;
 	struct clk	     *clk;
 	struct mv_xor_chan   *channels[MV_XOR_MAX_CHANNELS];
+	bool                 xor_armada3700;
 };
 
 /**
-- 
1.9.1

