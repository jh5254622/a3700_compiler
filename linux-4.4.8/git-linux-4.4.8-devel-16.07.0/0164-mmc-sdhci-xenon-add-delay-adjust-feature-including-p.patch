From 1870fc5599863b9c03bd8177d3b06c77fffad0ff Mon Sep 17 00:00:00 2001
From: Victor Gu <xigu@marvell.com>
Date: Tue, 5 Jan 2016 16:38:13 +0800
Subject: [PATCH 164/538] mmc: sdhci-xenon: add delay adjust feature including
 phy reset

Tuning is only available in HS200 mode, need to adjust
delay for other modes, and even adjust the delay before tuning.
1. add a new sdhci operation delay_adj
2. call delay_adj after set ios in sdhci
3. implement eMMC PHY init and reset
4. implement adjust delay routines and register to sdhci

Change-Id: I7de2ff21e80934c01620e79fd2b7847c62806602
Signed-off-by: Victor Gu <xigu@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/27679
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Tested-by: Nadav Haklai <nadavh@marvell.com>
---
 drivers/mmc/host/sdhci-xenon.c | 644 ++++++++++++++++++++++++++++++++++++++++-
 drivers/mmc/host/sdhci.c       |   3 +
 drivers/mmc/host/sdhci.h       |   1 +
 3 files changed, 644 insertions(+), 4 deletions(-)

diff --git a/drivers/mmc/host/sdhci-xenon.c b/drivers/mmc/host/sdhci-xenon.c
index 24f0af6..cbc6b90 100644
--- a/drivers/mmc/host/sdhci-xenon.c
+++ b/drivers/mmc/host/sdhci-xenon.c
@@ -17,10 +17,16 @@
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include "sdhci.h"
 #include "sdhci-pltfm.h"
+/* Below header files are included since need to call APIs inside of them
+ * for delay adjust testing in eMMC/SD/SDIO modes
+ */
+#include "../core/mmc_ops.h"
+#include "../core/sdio_ops.h"
 
 /* Re-tuning event interrupt signal */
 #define  SDHCI_RETUNE_EVT_INTSIG		0x00001000
@@ -42,6 +48,12 @@
 
 #define SDHC_SYS_EXT_OP_CTRL			0x010c
 
+#define SDHC_SLOT_OP_STATUS_CTRL		0x0128
+#define	 DELAY_90_DEGREE_MASK_EMMC5		(1 << 7)
+#define  DELAY_90_DEGREE_SHIFT_EMMC5		7
+#define  TUNING_PROG_FIXED_DELAY_MASK		0xff
+#define  FORCE_SEL_INVERSE_CLK_SHIFT		11
+
 #define SDHC_SLOT_eMMC_CTRL			0x0130
 #define  ENABLE_DATA_STROBE			(1 << 24)
 #define  SET_EMMC_RSTN				(1 << 16)
@@ -58,9 +70,102 @@
 #define SDHC_SLOT_AUTO_RETUNING_CTRL		0x0148
 #define  ENABLE_AUTO_RETUNING			0x1
 
+#define SDHC_SLOT_DLL_CUR_DLY_VAL		0x0150
+
+#define EMMC_PHY_REG_BASE			0x170
+
+#define EMMC_PHY_TIMING_ADJUST			EMMC_PHY_REG_BASE
+#define  TIMING_ADJUST_SLOW_MODE		(1 << 29)
+#define  TIMING_ADJUST_SDIO_MODE		(1 << 28)
+#define  OUTPUT_QSN_PHASE_SELECT		(1 << 17)
+#define  SAMPL_INV_QSP_PHASE_SELECT		(1 << 18)
+#define  SAMPL_INV_QSP_PHASE_SELECT_SHIFT	18
+#define  PHY_INITIALIZATION			(1 << 31)
+#define  WAIT_CYCLE_BEFORE_USING_MASK		0xf
+#define  WAIT_CYCLE_BEFORE_USING_SHIFT		12
+#define  FC_SYNC_EN_DURATION_MASK		0xf
+#define  FC_SYNC_EN_DURATION_SHIFT		8
+#define	 FC_SYNC_RST_EN_DURATION_MASK		0xf
+#define  FC_SYNC_RST_EN_DURATION_SHIFT		4
+#define  FC_SYNC_RST_DURATION_MASK		0xf
+#define  FC_SYNC_RST_DURATION_SHIFT		0
+
+#define EMMC_PHY_FUNC_CONTROL			(EMMC_PHY_REG_BASE + 0x4)
+#define  ASYNC_DDRMODE_MASK			(1 << 23)
+#define  ASYNC_DDRMODE_SHIFT			23
+#define  CMD_DDR_MODE				(1 << 16)
+#define  DQ_DDR_MODE_SHIFT			8
+#define  DQ_DDR_MODE_MASK			0xff
+#define  DQ_ASYNC_MODE				(1 << 4)
+
+#define EMMC_PHY_PAD_CONTROL			(EMMC_PHY_REG_BASE + 0x8)
+#define  REC_EN_SHIFT				24
+#define  REC_EN_MASK				0xf
+#define  FC_DQ_RECEN				(1 << 24)
+#define  FC_CMD_RECEN				(1 << 25)
+#define  FC_QSP_RECEN				(1 << 26)
+#define  FC_QSN_RECEN				(1 << 27)
+#define  OEN_QSN				(1 << 28)
+#define  AUTO_RECEN_CTRL			(1 << 30)
+#define  FC_ALL_CMOS_RECEIVER			0xf000
+
+#define  EMMC5_FC_QSP_PD			(1 << 18)
+#define  EMMC5_FC_QSP_PU			(1 << 22)
+#define  EMMC5_FC_CMD_PD			(1 << 17)
+#define  EMMC5_FC_CMD_PU			(1 << 21)
+#define  EMMC5_FC_DQ_PD				(1 << 16)
+#define  EMMC5_FC_DQ_PU				(1 << 20)
+
+#define EMMC_PHY_PAD_CONTROL1			(EMMC_PHY_REG_BASE + 0xc)
+#define  EMMC5_1_FC_QSP_PD			(1 << 9)
+#define  EMMC5_1_FC_QSP_PU			(1 << 25)
+#define  EMMC5_1_FC_CMD_PD			(1 << 8)
+#define  EMMC5_1_FC_CMD_PU			(1 << 24)
+#define  EMMC5_1_FC_DQ_PD			0xff
+#define  EMMC5_1_FC_DQ_PU			(0xff << 16)
+
+#define EMMC_PHY_PAD_CONTROL2			(EMMC_PHY_REG_BASE + 0x10)
+#define  ZNR_MASK				(0x1f << 8)
+#define  ZNR_SHIFT				8
+#define  ZPR_MASK				0x1f
+/* Perferred ZNR and ZPR values vary between different boards.
+ * The specific ZNR and ZPR values should be defined here
+ * according to board actual timing.
+ */
+#define  ZNR_PREF_VALUE				0xf
+#define  ZPR_PREF_VALUE				0xf
+
+#define EMMC_PHY_DLL_CONTROL			(EMMC_PHY_REG_BASE + 0x14)
+#define  DLL_ENABLE				(1 << 31)
+#define  DLL_REFCLK_SEL				(1 << 30)
+#define  DLL_PHSEL1_SHIFT			24
+#define  DLL_PHSEL0_SHIFT			16
+#define  DLL_PHASE_MASK				0x3f
+#define  DLL_PHASE_90_DEGREE			0x1f
+#define  DLL_DELAY_TEST_LOWER_SHIFT		8
+#define  DLL_DELAY_TEST_LOWER_MASK		0xff
+#define  DLL_FAST_LOCK				(1 << 5)
+#define  DLL_GAIN2X				(1 << 3)
+#define  DLL_BYPASS_EN				(1 << 0)
+
+#define EMMC_LOGIC_TIMING_ADJUST		(EMMC_PHY_REG_BASE + 0x18)
+#define EMMC_LOGIC_TIMING_ADJUST_LOW		(EMMC_PHY_REG_BASE + 0x1c)
+
 /* Xenon quirks */
 #define SDHCI_QUIRK_XENON_EMMC_SLOT		(1 << 0) /* only support eMMC */
 
+/* Hardware team recommends below value for HS400
+ * eMMC logic timing adjust register(0x188), refer to FS to details
+ * bit[3:0] PHY response delay parameter
+ * bit[7:4] PHY write delay parameter
+ * bit[11:8] PHY stop CLK parameter
+ * bit[15:12] PHY interrupt off delay
+ * bit[19:16] PHY init det delay
+ * bit[23:20] PHY read wait delay
+ * bit[31:24] Reserved
+ */
+#define LOGIC_TIMING_VALUE				0x00aa8977
+
 /* Max input clock, 400MHZ, it is also used as Max output clock
  */
 #define XENON_SDHC_MAX_CLOCK			400000000
@@ -74,6 +179,13 @@
 /* No support for this tuning value */
 #define XENON_TMR_RETUN_NO_PRESENT		0xf
 
+/* Invalid XENON MMC timing value, which is used as default value */
+#define XENON_MMC_TIMING_INVALID			0xff
+
+/* Delay step */
+#define COARSE_SAMPL_FIX_DELAY_STEP			100
+#define FINE_SAMPL_FIX_DELAY_STEP			50
+
 /* SDHC private parameters */
 struct sdhci_xenon_priv {
 	/* The three fields in below records the current
@@ -82,6 +194,7 @@ struct sdhci_xenon_priv {
 	 * if any setting is changed.
 	 */
 	unsigned char	bus_width;
+	unsigned char	timing;
 	unsigned char	tuning_count;
 	unsigned int	clock;
 	unsigned int	quirks; /* Xenon private quirks */
@@ -90,6 +203,516 @@ struct sdhci_xenon_priv {
 /*
  * Xenon Specific Initialization Operations
  */
+/*
+ * Internal eMMC PHY routines
+ */
+static int sdhci_xenon_phy_init(struct sdhci_host *host)
+{
+	u32 reg;
+	u32 wait;
+	u32 clock;
+
+	reg = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
+	reg |= PHY_INITIALIZATION;
+	sdhci_writel(host, reg, EMMC_PHY_TIMING_ADJUST);
+
+	/* Add duration of FC_SYNC_RST */
+	wait = ((reg >> FC_SYNC_RST_DURATION_SHIFT) &
+		FC_SYNC_RST_DURATION_MASK);
+	/* Add interval between FC_SYNC_EN and FC_SYNC_RST */
+	wait += ((reg >> FC_SYNC_RST_EN_DURATION_SHIFT) &
+		FC_SYNC_RST_EN_DURATION_MASK);
+	/* Add duration of asserting FC_SYNC_EN */
+	wait += ((reg >> FC_SYNC_EN_DURATION_SHIFT) &
+		FC_SYNC_EN_DURATION_MASK);
+	/* Add duration of waiting for PHY */
+	wait += ((reg >> WAIT_CYCLE_BEFORE_USING_SHIFT) &
+		WAIT_CYCLE_BEFORE_USING_MASK);
+	/* 4 additional bus clock and 4 AXI bus clock are required */
+	wait += 8;
+	/* left shift 20 bits */
+	wait <<= 20;
+
+	clock = host->mmc->actual_clock;
+	if (clock == 0)
+		/* Use the possibly slowest bus frequency value */
+		clock = 100000;
+
+	/* get the wait time */
+	wait /= clock;
+	wait++;
+
+	/* wait for host eMMC PHY init to complete */
+	udelay(wait);
+
+	reg = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
+	reg &= PHY_INITIALIZATION;
+	if (reg) {
+		dev_err(mmc_dev(host->mmc), "%s: eMMC PHY init cannot complete after %d us\n",
+			mmc_hostname(host->mmc), wait);
+		return -EIO;
+	}
+
+	dev_dbg(mmc_dev(host->mmc), "%s: eMMC PHY init complete\n",
+		mmc_hostname(host->mmc));
+
+	return 0;
+}
+
+static void sdhci_xenon_phy_reset(struct sdhci_host *host, unsigned int timing)
+{
+	u32 reg;
+	struct mmc_card *card = host->mmc->card;
+
+	dev_dbg(mmc_dev(host->mmc), "%s: eMMC PHY setting starts\n",
+		mmc_hostname(host->mmc));
+
+	/* Setup pad, set bit[28] and bits[26:24] */
+	reg = sdhci_readl(host, EMMC_PHY_PAD_CONTROL);
+	reg |= (FC_DQ_RECEN | FC_CMD_RECEN | FC_QSP_RECEN | OEN_QSN);
+
+	/* According to latest spec, all FC_XX_RECEIVCE should
+	 * be set as CMOS Type
+	 */
+	reg |= FC_ALL_CMOS_RECEIVER;
+	sdhci_writel(host, reg, EMMC_PHY_PAD_CONTROL);
+
+	/* Set CMD and DQ Pull Up */
+	reg = sdhci_readl(host, EMMC_PHY_PAD_CONTROL1);
+	reg |= (EMMC5_1_FC_CMD_PU | EMMC5_1_FC_DQ_PU);
+	reg &= ~(EMMC5_1_FC_CMD_PD | EMMC5_1_FC_DQ_PD);
+	sdhci_writel(host, reg, EMMC_PHY_PAD_CONTROL1);
+
+	/* If timing belongs to high speed, set bit[17] of
+	 * EMMC_PHY_TIMING_ADJUST register
+	 */
+	if ((timing == MMC_TIMING_MMC_HS400) ||
+	    (timing == MMC_TIMING_MMC_HS200) ||
+	    (timing == MMC_TIMING_UHS_SDR50) ||
+	    (timing == MMC_TIMING_UHS_SDR104) ||
+	    (timing == MMC_TIMING_UHS_DDR50) ||
+	    (timing == MMC_TIMING_UHS_SDR25) ||
+	    (timing == MMC_TIMING_MMC_DDR52)) {
+		reg = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
+		reg &= ~OUTPUT_QSN_PHASE_SELECT;
+		sdhci_writel(host, reg, EMMC_PHY_TIMING_ADJUST);
+	}
+
+	/* If SDIO card, set SDIO Mode
+	 * Otherwise, clear SDIO Mode and Slow Mode
+	 */
+	if (card && (card->type & MMC_TYPE_SDIO)) {
+		reg = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
+		reg |= TIMING_ADJUST_SDIO_MODE;
+
+		if ((timing == MMC_TIMING_UHS_SDR25) ||
+		    (timing == MMC_TIMING_UHS_SDR12) ||
+		    (timing == MMC_TIMING_SD_HS) ||
+		    (timing == MMC_TIMING_LEGACY))
+			reg |= TIMING_ADJUST_SLOW_MODE;
+
+		sdhci_writel(host, reg, EMMC_PHY_TIMING_ADJUST);
+	} else {
+		reg = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
+		reg &= ~(TIMING_ADJUST_SDIO_MODE | TIMING_ADJUST_SLOW_MODE);
+		sdhci_writel(host, reg, EMMC_PHY_TIMING_ADJUST);
+	}
+
+	/* Set preferred ZNR and ZPR value
+	 * The ZNR and ZPR value vary between different boards.
+	 */
+	reg = sdhci_readl(host, EMMC_PHY_PAD_CONTROL2);
+	reg &= ~(ZNR_MASK | ZPR_MASK);
+	reg |= ((ZNR_PREF_VALUE << ZNR_SHIFT) | ZPR_PREF_VALUE);
+	sdhci_writel(host, reg, EMMC_PHY_PAD_CONTROL2);
+
+	/* When setting EMMC_PHY_FUNC_CONTROL register,
+	 * SD clock should be disabled
+	 */
+	reg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
+	reg &= ~SDHCI_CLOCK_CARD_EN;
+	sdhci_writew(host, reg, SDHCI_CLOCK_CONTROL);
+
+	if ((timing == MMC_TIMING_UHS_DDR50) ||
+	    (timing == MMC_TIMING_MMC_HS400) ||
+	    (timing == MMC_TIMING_MMC_DDR52)) {
+		reg = sdhci_readl(host, EMMC_PHY_FUNC_CONTROL);
+		reg |= (DQ_DDR_MODE_MASK << DQ_DDR_MODE_SHIFT) | CMD_DDR_MODE;
+		sdhci_writel(host, reg, EMMC_PHY_FUNC_CONTROL);
+	}
+
+	if (timing == MMC_TIMING_MMC_HS400) {
+		reg = sdhci_readl(host, EMMC_PHY_FUNC_CONTROL);
+		reg &= ~DQ_ASYNC_MODE;
+		sdhci_writel(host, reg, EMMC_PHY_FUNC_CONTROL);
+	}
+
+	/* Enable bus clock */
+	reg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
+	reg |= SDHCI_CLOCK_CARD_EN;
+	sdhci_writew(host, reg, SDHCI_CLOCK_CONTROL);
+
+	if (timing == MMC_TIMING_MMC_HS400)
+		sdhci_writel(host, LOGIC_TIMING_VALUE,
+			     EMMC_LOGIC_TIMING_ADJUST);
+
+	sdhci_xenon_phy_init(host);
+
+	dev_dbg(mmc_dev(host->mmc), "%s: eMMC PHY setting completed\n",
+		mmc_hostname(host->mmc));
+}
+
+/* apply samping fix delay */
+static int sdhci_xenon_set_fix_delay(struct sdhci_host *host,
+				     unsigned int delay, bool invert,
+				     bool phase)
+{
+	unsigned int reg;
+	int ret = 0;
+	u8 timeout;
+
+	if (invert)
+		invert = 0x1;
+	else
+		invert = 0x0;
+
+	if (phase)
+		phase = 0x1;
+	else
+		phase = 0x0;
+
+	/* Setup sampling fix delay */
+	reg = sdhci_readl(host, SDHC_SLOT_OP_STATUS_CTRL);
+	reg &= ~TUNING_PROG_FIXED_DELAY_MASK;
+	reg |= delay & TUNING_PROG_FIXED_DELAY_MASK;
+	sdhci_writel(host, reg, SDHC_SLOT_OP_STATUS_CTRL);
+
+	/* Disable SDCLK */
+	reg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
+	reg &= ~(SDHCI_CLOCK_CARD_EN | SDHCI_CLOCK_INT_EN);
+	sdhci_writel(host, reg, SDHCI_CLOCK_CONTROL);
+
+	udelay(200);
+
+	/* If phase = true, set 90 degree phase */
+	reg = sdhci_readl(host, EMMC_PHY_FUNC_CONTROL);
+	reg &= ~ASYNC_DDRMODE_MASK;
+	reg |= (phase << ASYNC_DDRMODE_SHIFT);
+	sdhci_writel(host, reg, EMMC_PHY_FUNC_CONTROL);
+
+	/* Setup inversion of sampling edge */
+	reg = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
+	reg &= ~SAMPL_INV_QSP_PHASE_SELECT;
+	reg |= (invert << SAMPL_INV_QSP_PHASE_SELECT_SHIFT);
+	sdhci_writel(host, reg, EMMC_PHY_TIMING_ADJUST);
+
+	/* Enable SD internal clock */
+	reg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
+	reg |= SDHCI_CLOCK_INT_EN;
+	sdhci_writel(host, reg, SDHCI_CLOCK_CONTROL);
+
+	/* Wait max 20 ms */
+	timeout = 20;
+	while (!((reg = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
+			& SDHCI_CLOCK_INT_STABLE)) {
+		if (timeout == 0) {
+			pr_err("%s: Internal clock never stabilised.\n",
+					mmc_hostname(host->mmc));
+			return -EIO;
+		}
+		timeout--;
+		mdelay(1);
+	}
+
+	/* Enable SDCLK */
+	reg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
+	reg |= SDHCI_CLOCK_CARD_EN;
+	sdhci_writel(host, reg, SDHCI_CLOCK_CONTROL);
+
+	udelay(200);
+
+	/* Has to re-initialize eMMC PHY here to active PHY
+	 * because later get status cmd will be issued.
+	 */
+	ret = sdhci_xenon_phy_init(host);
+
+	return ret;
+}
+
+/* apply strobe delay */
+static void sdhci_xenon_set_strobe_delay(struct sdhci_host *host)
+{
+	u32 reg;
+
+	/* Enable DLL */
+	reg = sdhci_readl(host, EMMC_PHY_DLL_CONTROL);
+	reg |= (DLL_ENABLE | DLL_GAIN2X | DLL_FAST_LOCK);
+
+	/* Set phase as 90 degree */
+	reg &= ~((DLL_PHASE_MASK << DLL_PHSEL0_SHIFT) |
+			(DLL_PHASE_MASK << DLL_PHSEL1_SHIFT));
+	reg |= ((DLL_PHASE_90_DEGREE << DLL_PHSEL0_SHIFT) |
+			(DLL_PHASE_90_DEGREE << DLL_PHSEL1_SHIFT));
+
+	reg |= DLL_REFCLK_SEL;
+	reg &= ~DLL_BYPASS_EN;
+	sdhci_writel(host, reg, EMMC_PHY_DLL_CONTROL);
+
+	/* Set data strobe pull down */
+	reg = sdhci_readl(host, EMMC_PHY_PAD_CONTROL1);
+	reg |= EMMC5_1_FC_QSP_PD;
+	reg &= ~EMMC5_1_FC_QSP_PU;
+	sdhci_writel(host, reg, EMMC_PHY_PAD_CONTROL1);
+}
+
+/* eMMC delay adjust test */
+static int sdhci_xenon_emmc_delay_adj(struct mmc_card *card)
+{
+	int err;
+	u8 *ext_csd = NULL;
+
+	err = mmc_get_ext_csd(card, &ext_csd);
+	kfree(ext_csd);
+
+	return err;
+}
+
+/* SD delay adjust test */
+static int sdhci_xenon_sd_delay_adj(struct mmc_card *card)
+{
+	return mmc_send_status(card, NULL);
+}
+
+/* SDIO delay adjust test */
+static int sdhci_xenon_sdio_delay_adj(struct mmc_card *card)
+{
+	u8 reg;
+
+	return mmc_io_rw_direct(card, 0, 0, 0, 0, &reg);
+}
+
+static int sdhci_xenon_delay_adj_test(struct sdhci_host *host,
+		struct mmc_card *card, unsigned int delay,
+		bool invert, bool phase)
+{
+	int ret;
+
+	sdhci_xenon_set_fix_delay(host, delay, invert, phase);
+
+	if (mmc_card_mmc(card))
+		ret = sdhci_xenon_emmc_delay_adj(card);
+	else if (mmc_card_sd(card))
+		ret = sdhci_xenon_sd_delay_adj(card);
+	else if (mmc_card_sdio(card))
+		ret = sdhci_xenon_sdio_delay_adj(card);
+	else
+		return -EINVAL;
+	if (ret) {
+		pr_debug("Xenon failed when sampling fix delay %d, inverted %d, phase %d\n",
+			 delay, invert, phase);
+		return -1;
+	}
+
+	pr_debug("Xenon succeeded when sampling fixed delay %d, inverted %d, phase %d\n",
+		 delay, invert, phase);
+	return 0;
+}
+
+/* Adjust the fix delay
+ * This routine tries to calculate a proper fix delay.It is because tuning
+ * is only available in HS200 mode, need to adjust delay for other modes,
+ * and even adjust the delay before tuning.
+ */
+static int sdhci_xenon_fix_delay_adj(struct sdhci_host *host,
+				     struct mmc_card *card)
+{
+	bool invert, phase;
+	int idx, nr_pair;
+	int ret;
+	unsigned int delay;
+	unsigned int min_delay, max_delay;
+	u32 reg;
+	/* Pairs to set the delay edge.
+	 * First column is the inversion sequence.
+	 * Second column indicates delay 90 degree or not.
+	 */
+	bool delay_edge_pair[][2] = {
+			{ true,		false},
+			{ true,		true},
+			{ false,	false},
+			{ false,	true }
+	};
+
+	nr_pair = sizeof(delay_edge_pair) / ARRAY_SIZE(delay_edge_pair);
+
+	for (idx = 0; idx < nr_pair; idx++) {
+		invert = delay_edge_pair[idx][0];
+		phase = delay_edge_pair[idx][1];
+
+		/* Increase delay value to get min fix delay */
+		for (min_delay = 0; min_delay <= TUNING_PROG_FIXED_DELAY_MASK;
+				min_delay += COARSE_SAMPL_FIX_DELAY_STEP) {
+			ret = sdhci_xenon_delay_adj_test(host, card, min_delay,
+							 invert, phase);
+			if (!ret)
+				break;
+		}
+
+		if (ret) {
+			pr_debug("Failed to set sampling fixed delay with inversion %d, phase %d\n",
+				 invert, phase);
+			continue;
+		}
+
+		/* Increase delay value to get max fix delay */
+		for (max_delay = min_delay + 1;
+			max_delay < TUNING_PROG_FIXED_DELAY_MASK;
+			max_delay += FINE_SAMPL_FIX_DELAY_STEP) {
+			ret = sdhci_xenon_delay_adj_test(host, card, max_delay,
+							 invert, phase);
+			if (ret) {
+				max_delay -= FINE_SAMPL_FIX_DELAY_STEP;
+				break;
+			}
+		}
+
+		/* Handle the round case in case the max allowed edge passed
+		 * delay adjust testing.
+		 */
+		if (!ret) {
+			ret = sdhci_xenon_delay_adj_test(host, card,
+						   TUNING_PROG_FIXED_DELAY_MASK,
+						   invert, phase);
+			if (!ret)
+				max_delay = TUNING_PROG_FIXED_DELAY_MASK;
+		}
+
+		/* For eMMC PHY, sampling fixed delay line window should
+		 * be large enough, thus the sampling point(the middle of
+		 * the window) can work when environment varies.
+		 * However, there is no clear conclusoin how large the window
+		 * should be. We just make an assumption that
+		 * the window should be larger 25% of a SDCLK cycle.
+		 * Please note that this judgement is only based on experience.
+		 *
+		 * The field delay value of main delay line in
+		 * register SDHC_SLOT_DLL_CUR represents a half of SDCLK
+		 * cycle. Thus the window should be larger than 1/2 of
+		 * the field delay value of main delay line value.
+		 */
+		reg = sdhci_readl(host, SDHC_SLOT_DLL_CUR_DLY_VAL);
+		reg &= TUNING_PROG_FIXED_DELAY_MASK;
+		/* get the 1/4 SDCLK cycle */
+		reg >>= 1;
+
+		if ((max_delay - min_delay) < reg) {
+			pr_info("The window size %d when inversion = %d, phase = %d cannot meet timing requiremnt\n",
+				max_delay - min_delay, invert, phase);
+			continue;
+		}
+
+		delay = (min_delay + max_delay) / 2;
+		sdhci_xenon_set_fix_delay(host, delay, invert, phase);
+		pr_debug("Xenon sampling fix delay = %d with inversion = %d, phase = %d\n",
+			 delay, invert, phase);
+		return 0;
+	}
+
+	return -EIO;
+}
+
+/* Adjust the strobe delay for HS400 mode */
+static int sdhci_xenon_strobe_delay_adj(struct sdhci_host *host,
+					struct mmc_card *card)
+{
+	int ret = 0;
+	u32 reg;
+
+	/* Enable SDHC data strobe */
+	reg = sdhci_readl(host, SDHC_SLOT_eMMC_CTRL);
+	reg |= ENABLE_DATA_STROBE;
+	sdhci_writel(host, reg, SDHC_SLOT_eMMC_CTRL);
+
+	/* Enable the DLL to automatically adjust HS400 strobe delay */
+	sdhci_xenon_set_strobe_delay(host);
+	return ret;
+}
+
+/*
+ * sdhci_xenon_delay_adj should not be called inside of IRQ context,
+ * either hardware IRQ or software IRQ.
+ */
+static int sdhci_xenon_delay_adj(struct sdhci_host *host, struct mmc_ios *ios)
+{
+	int ret;
+	struct mmc_host *mmc = host->mmc;
+	struct mmc_card *card = NULL;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_xenon_priv *priv;
+
+	if (!host->clock)
+		return 0;
+
+	priv = (struct sdhci_xenon_priv *)pltfm_host->private;
+	if (ios->timing != priv->timing)
+		sdhci_xenon_phy_reset(host, ios->timing);
+
+	/* Legacy mode is a special case.
+	 * In legacy Mode, usually it is not necessary to adjust
+	 * sampling fixed delay, since the SDCLK frequency is quiet low.
+	 */
+	if (ios->timing == MMC_TIMING_LEGACY) {
+		priv->timing = ios->timing;
+		return 0;
+	}
+
+	/* If the timing, frequency or bus width are changed,
+	 * better to set eMMC PHY based on current setting
+	 * and adjust Xenon SDHC delay.
+	 */
+	if ((host->clock == priv->clock) &&
+		(ios->bus_width == priv->bus_width) &&
+		(ios->timing == priv->timing))
+		return 0;
+
+	/* Save the values */
+	priv->clock = host->clock;
+	priv->bus_width = ios->bus_width;
+	priv->timing = ios->timing;
+
+	if (unlikely(card == NULL))
+		return -EIO;
+
+	/* No need to set any delay for some cases in this stage
+	 * since it will be reset as legacy mode soon.
+	 * For example,
+	 * during the hardware reset in high speed mode,
+	 * and the SDCLK is no more than 400k (legacy mode).
+	 */
+	if (host->clock <= 4000000)
+		return 0;
+
+	if (mmc_card_hs400(card)) {
+		pr_debug("%s: start HS400 strobe delay adjustment\n",
+			 mmc_hostname(mmc));
+		ret = sdhci_xenon_strobe_delay_adj(host, card);
+		if (ret)
+			pr_err("%s: strobe fixed delay adjustment failed\n",
+			       mmc_hostname(mmc));
+
+		return ret;
+	}
+
+	pr_debug("%s: start sampling fixed delay adjustment\n",
+		 mmc_hostname(mmc));
+	ret = sdhci_xenon_fix_delay_adj(host, card);
+	if (ret)
+		pr_err("%s: sampling fixed delay adjustment failed\n",
+		       mmc_hostname(mmc));
+
+	return ret;
+}
+
 /* Enable/Disable the Auto Clock Gating function */
 static void sdhci_xenon_set_acg(struct sdhci_host *host, bool enable)
 {
@@ -299,6 +922,7 @@ static struct sdhci_ops sdhci_xenon_ops = {
 	.get_max_clock		= sdhci_xenon_get_max_clock,
 	.voltage_switch		= sdhci_xenon_voltage_switch,
 	.voltage_switch_pre	= sdhci_xenon_voltage_switch_pre,
+	.delay_adj		= sdhci_xenon_delay_adj,
 };
 
 static struct sdhci_pltfm_data sdhci_xenon_pdata = {
@@ -423,18 +1047,21 @@ static void sdhci_xenon_set_tuning_mode(struct sdhci_host *host)
 static void sdhci_xenon_add_host_fixup(struct sdhci_host *host)
 {
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
-	struct sdhci_xenon_priv *priv =
-				 (struct sdhci_xenon_priv *)pltfm_host->private;
+	struct sdhci_xenon_priv *priv;
 
 	sdhci_xenon_set_tuning_mode(host);
 
+	priv = (struct sdhci_xenon_priv *)pltfm_host->private;
 	sdhci_xenon_set_tuning_count(host, priv->tuning_count);
 }
 
-static void sdhci_xenon_slot_probe(struct sdhci_host *host)
+static int sdhci_xenon_slot_probe(struct sdhci_host *host)
 {
 	struct mmc_host *mmc = host->mmc;
 	u8 slotno = mmc->slotno;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_xenon_priv *priv =
+				 (struct sdhci_xenon_priv *)pltfm_host->private;
 
 	/* Enable slot */
 	sdhci_xenon_set_slot(host, slotno, true);
@@ -456,6 +1083,11 @@ static void sdhci_xenon_slot_probe(struct sdhci_host *host)
 
 	/* Set tuning functionality of this slot */
 	sdhci_xenon_setup_tuning(host);
+
+	/* set default timing value */
+	priv->timing = XENON_MMC_TIMING_INVALID;
+
+	return 0;
 }
 
 static void sdhci_xenon_slot_remove(struct sdhci_host *host)
@@ -491,7 +1123,11 @@ static int sdhci_xenon_probe(struct platform_device *pdev)
 		goto free_pltfm;
 	}
 
-	sdhci_xenon_slot_probe(host);
+	err = sdhci_xenon_slot_probe(host);
+	if (err) {
+		pr_err("%s: Failed to probe slot.\n", mmc_hostname(host->mmc));
+		goto free_pltfm;
+	}
 
 	err = sdhci_add_host(host);
 	if (err) {
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 9d8254e..7544a07 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1617,6 +1617,9 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 
 	mmiowb();
 	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (host->ops->delay_adj)
+		host->ops->delay_adj(host, ios);
 }
 
 static void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 13c9a71..ca2673e 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -551,6 +551,7 @@ struct sdhci_ops {
 					 unsigned int max_dtr, int host_drv,
 					 int card_drv, int *drv_type);
 	void	(*voltage_switch_pre)(struct sdhci_host *host);
+	int	(*delay_adj)(struct sdhci_host *host, struct mmc_ios *ios);
 	void	(*init_card)(struct sdhci_host *host, struct mmc_card *card);
 };
 
-- 
1.9.1

