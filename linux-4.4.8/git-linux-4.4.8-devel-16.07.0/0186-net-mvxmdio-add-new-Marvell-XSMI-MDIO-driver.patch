From eb5e44374300aa5f7eabe5208df5ad3dfd2be7c7 Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Wed, 17 Feb 2016 13:14:24 +0200
Subject: [PATCH 186/538] net: mvxmdio: add new Marvell XSMI MDIO driver

- Add a separate driver for XSMI MDIO interface of the Marvell Ethernet
  PHYs
- The Network driver will enable the MVXMDIO

Change-Id: I17b2fc07af60f62663eafa786c40ebf1d785db36
Signed-off-by: Hanna Hawa <hannah@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/27585
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
---
 .../devicetree/bindings/net/marvell-xmdio.txt      |  35 +++
 drivers/net/ethernet/marvell/Kconfig               |  11 +
 drivers/net/ethernet/marvell/Makefile              |   1 +
 drivers/net/ethernet/marvell/mvxmdio.c             | 240 +++++++++++++++++++++
 4 files changed, 287 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/net/marvell-xmdio.txt
 create mode 100644 drivers/net/ethernet/marvell/mvxmdio.c

diff --git a/Documentation/devicetree/bindings/net/marvell-xmdio.txt b/Documentation/devicetree/bindings/net/marvell-xmdio.txt
new file mode 100644
index 0000000..ee4e704
--- /dev/null
+++ b/Documentation/devicetree/bindings/net/marvell-xmdio.txt
@@ -0,0 +1,35 @@
+* Marvell xMDIO Ethernet Controller interface
+
+The Ethernet controllers of the Marvel Armada-39x, Armada-7k
+and Armada-8k have an identical unit that provides
+an interface with the xMDIO bus. This driver handles this xMDIO
+interface.
+
+Required properties:
+- compatible: "marvell,xmdio"
+- reg: address and length of the xSMI register
+
+The child nodes of the xMDIO driver are the individual PHY devices
+connected to this xMDIO bus. They must have a "reg" property given the
+PHY address on the xMDIO bus.
+
+Example at the SoC level:
+
+mdio {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	compatible = "marvell,xmdio";
+	reg = <0x12A600 0x20>;
+};
+
+And at the board level:
+
+mdio {
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+}
diff --git a/drivers/net/ethernet/marvell/Kconfig b/drivers/net/ethernet/marvell/Kconfig
index a1c862b..c8e158e 100644
--- a/drivers/net/ethernet/marvell/Kconfig
+++ b/drivers/net/ethernet/marvell/Kconfig
@@ -40,6 +40,17 @@ config MVMDIO
 
 	  This driver is used by the MV643XX_ETH and MVNETA drivers.
 
+config MVXMDIO
+	tristate "Marvell xMDIO interface support"
+	depends on HAS_IOMEM
+	select PHYLIB
+	---help---
+	  This driver supports the xMDIO interface found in the network
+	  interface units of the Marvell EBU SoCs (Armada39x, Armada8k,
+	  and Armada7k).
+
+	  This driver should be used by PPv2.2 netwrork driver.
+
 config MVNETA
 	tristate "Marvell Armada 370/38x/XP network interface support"
 	depends on PLAT_ORION
diff --git a/drivers/net/ethernet/marvell/Makefile b/drivers/net/ethernet/marvell/Makefile
index f6425bd..f0e14b8 100644
--- a/drivers/net/ethernet/marvell/Makefile
+++ b/drivers/net/ethernet/marvell/Makefile
@@ -3,6 +3,7 @@
 #
 
 obj-$(CONFIG_MVMDIO) += mvmdio.o
+obj-$(CONFIG_MVXMDIO) += mvxmdio.o
 obj-$(CONFIG_MV643XX_ETH) += mv643xx_eth.o
 obj-$(CONFIG_MVNETA) += mvneta.o
 obj-$(CONFIG_MVPP2) += mvpp2.o
diff --git a/drivers/net/ethernet/marvell/mvxmdio.c b/drivers/net/ethernet/marvell/mvxmdio.c
new file mode 100644
index 0000000..72e5801
--- /dev/null
+++ b/drivers/net/ethernet/marvell/mvxmdio.c
@@ -0,0 +1,240 @@
+/**
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/of_mdio.h>
+#include <linux/of_address.h>
+
+#define TIMEOUT_MIN		150	/* = 150us */
+#define TIMEOUT_MAX		160	/* = 160us */
+#define NTRIES			5
+#define XBUSY			BIT(30)
+#define XREAD_VALID		BIT(29)
+#define XCLKDIV_OFFS		0
+#define XCLKDIV_MASK		(0x3 << XCLKDIV_OFFS)
+#define XOPCODE_OFFS		26
+#define XOPCODE_ADDR_READ	(7 << XOPCODE_OFFS)
+#define XOPCODE_ADDR_WRITE	(5 << XOPCODE_OFFS)
+#define XPHYADDR_OFFS		16 /* Phy port addr offset */
+#define XPORT_ADDR(x)		((x & 0x1f) << XPHYADDR_OFFS)
+#define XDEVADDR_OFFS		21	/* Phy device addr offset */
+#define XDEV_ADDR(x)		((x & 0x1f) << XDEVADDR_OFFS)
+
+struct xmdio_controller {
+	__u32 __bitwise xmdio_mngmnt;	/* XSMI Management Register */
+	__u32 __bitwise unused;		/* unused */
+	__u32 __bitwise xmdio_addr;	/* XSMI Address Register */
+} __packed;
+
+/* Check if XSMI bus is idle */
+static int xmdio_chck_idle(struct xmdio_controller __iomem *regs)
+{
+	return !(readl(&regs->xmdio_mngmnt) & XBUSY);
+}
+
+/* Wait until XSMI bus is free */
+static int xmdio_wait_free(struct device *dev, struct xmdio_controller __iomem *regs)
+{
+	int ntries = NTRIES;
+
+	while (ntries > 0) {
+		if (xmdio_chck_idle(regs))
+			return 0;
+
+		usleep_range(TIMEOUT_MIN, TIMEOUT_MAX);
+		ntries--;
+	}
+
+	dev_err(dev, "timeout while waiting for bus to be free\n");
+	return -ETIMEDOUT;
+}
+
+/* Check if XSMI bus read operaton is done */
+static int xmdio_chck_read_done(struct xmdio_controller __iomem *regs)
+{
+	return readl(&regs->xmdio_mngmnt) & XREAD_VALID;
+}
+
+/* Wait until XSMI bus read operation is done */
+static int xmdio_wait_read_done(struct device *dev, struct xmdio_controller __iomem *regs)
+{
+	int ntries = NTRIES;
+
+	while (ntries > 0) {
+		if (xmdio_chck_read_done(regs))
+			return 0;
+
+		usleep_range(TIMEOUT_MIN, TIMEOUT_MAX);
+		ntries--;
+	}
+
+	dev_err(dev, "timeout while waiting for bus read operation is done\n");
+	return -ETIMEDOUT;
+}
+
+static int xmdio_read(struct mii_bus *bus, int phy_id, int regnum)
+{
+	struct xmdio_controller __iomem *regs = bus->priv;
+	u32 reg_val;
+	u16 dev_addr = regnum >> 16;
+	u16 data;
+	int ret;
+
+	ret = xmdio_wait_free(&bus->dev, regs);
+	if (ret)
+		return ret;
+
+	/* Write phy reg addr */
+	writel(regnum & 0xffff, &regs->xmdio_addr);
+
+	/* Set phy port and device addrs, and read opcode */
+	reg_val = XPORT_ADDR(phy_id) | XDEV_ADDR(dev_addr) | XOPCODE_ADDR_READ;
+
+	/* Initiate the read operation */
+	writel(reg_val, &regs->xmdio_mngmnt);
+
+	ret = xmdio_wait_read_done(&bus->dev, regs);
+	if (ret)
+		return ret;
+
+	data = readl(&regs->xmdio_mngmnt) & 0xffff;
+
+	return data;
+}
+
+static int xmdio_write(struct mii_bus *bus, int phy_id, int regnum, u16 value)
+{
+	struct xmdio_controller __iomem *regs = bus->priv;
+	u32 reg_val;
+	u16 dev_addr = regnum >> 16;
+	int ret;
+
+	ret = xmdio_wait_free(&bus->dev, regs);
+	if (ret)
+		return ret;
+
+	/* Write phy reg addr */
+	writel(regnum & 0xffff, &regs->xmdio_addr);
+
+	/* Set phy port and device addrs, write opcode, and value */
+	reg_val = XPORT_ADDR(phy_id) | XDEV_ADDR(dev_addr) | XOPCODE_ADDR_WRITE | value;
+
+	/* Initiate the write operation */
+	writel(reg_val, &regs->xmdio_mngmnt);
+
+	ret = xmdio_wait_free(&bus->dev, regs);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int xmdio_reset(struct mii_bus *bus)
+{
+	return 0;
+}
+
+static int xmdio_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct mii_bus *bus;
+	struct resource res;
+	int ret;
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		dev_err(&pdev->dev, "could not obtain address\n");
+		return ret;
+	}
+
+	bus = mdiobus_alloc_size(PHY_MAX_ADDR * sizeof(int));
+	if (!bus)
+		return -ENOMEM;
+
+	bus->name = "Marvell XSMI MDIO Bus";
+	bus->read = xmdio_read;
+	bus->write = xmdio_write;
+	bus->reset = xmdio_reset;
+	bus->irq = bus->priv;
+	bus->parent = &pdev->dev;
+	snprintf(bus->id, MII_BUS_ID_SIZE, "%llx", (unsigned long long)res.start);
+
+	/* Set the PHY base address */
+	bus->priv = of_iomap(np, 0);
+
+	if (!bus->priv) {
+		ret = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	ret = of_mdiobus_register(bus, np);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot register MDIO bus\n");
+		goto err_registration;
+	}
+
+	platform_set_drvdata(pdev, bus);
+
+	return 0;
+
+err_registration:
+	iounmap(bus->priv);
+
+err_ioremap:
+	mdiobus_free(bus);
+
+	return ret;
+}
+
+static int xmdio_remove(struct platform_device *pdev)
+{
+	struct mii_bus *bus = platform_get_drvdata(pdev);
+
+	mdiobus_unregister(bus);
+	iounmap(bus->priv);
+	mdiobus_free(bus);
+
+	return 0;
+}
+
+static const struct of_device_id xmdio_match[] = {
+	{ .compatible = "marvell,xmdio", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, xmdio_match);
+
+static struct platform_driver xmdio_driver = {
+	.driver = {
+		.name = "marvell-xmdio",
+		.of_match_table = xmdio_match,
+	},
+	.probe = xmdio_probe,
+	.remove = xmdio_remove,
+};
+
+module_platform_driver(xmdio_driver);
+
+MODULE_DESCRIPTION("Marvell XSMI MDIO interface driver");
+MODULE_AUTHOR("Victor Axelrod <victora@marvell.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:marvell-xmdio");
-- 
1.9.1

