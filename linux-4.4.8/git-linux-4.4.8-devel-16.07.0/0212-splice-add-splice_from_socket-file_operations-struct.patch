From 76c75140af4f5af5b02933c13e60f3cb18b4a181 Mon Sep 17 00:00:00 2001
From: Ofer Heifetz <oferh@marvell.com>
Date: Mon, 28 Dec 2015 12:27:54 +0200
Subject: [PATCH 212/538] splice: add splice_from_socket file_operations struct

new file operation that adds support for splice syscall
from socket file descriptor to file system file descriptor

Change-Id: I6579edb4124037376599d9f7fbd6bb521d20bbca
Signed-off-by: Ofer Heifetz <oferh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/27906
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Lior Amsalem <alior@marvell.com>
---
 fs/Kconfig         | 11 +++++++++++
 fs/splice.c        | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/fs.h |  6 ++++++
 3 files changed, 64 insertions(+)

diff --git a/fs/Kconfig b/fs/Kconfig
index 6ce72d8..5f56849 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -281,4 +281,15 @@ endif # NETWORK_FILESYSTEMS
 source "fs/nls/Kconfig"
 source "fs/dlm/Kconfig"
 
+config SPLICE_FROM_SOCKET
+	bool "Splice from socket to file descriptor"
+	depends on NET
+	default y
+
+	---help---
+	splice_from_socket to file descriptor can improve splice syscall
+	performance by ~10%.
+	If filesystem does not support this fop api, default
+	file descriptor to file descriptor splice is used.
+
 endmenu
diff --git a/fs/splice.c b/fs/splice.c
index 0f77e96..d711df8 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -32,6 +32,9 @@
 #include <linux/gfp.h>
 #include <linux/socket.h>
 #include <linux/compat.h>
+#ifdef CONFIG_SPLICE_FROM_SOCKET
+#include <linux/net.h>
+#endif
 #include "internal.h"
 
 /*
@@ -1693,10 +1696,54 @@ SYSCALL_DEFINE6(splice, int, fd_in, loff_t __user *, off_in,
 	struct fd in, out;
 	long error;
 
+#ifdef CONFIG_SPLICE_FROM_SOCKET
+	struct socket *sock = NULL;
+	ssize_t ret;
+#endif
 	if (unlikely(!len))
 		return 0;
 
 	error = -EBADF;
+
+#ifdef CONFIG_SPLICE_FROM_SOCKET
+	/* check if fd_in is a socket */
+	sock = sockfd_lookup(fd_in, (int *)&error);
+	if (sock) {
+		if (!sock->sk)
+			goto nosock;
+		out = fdget(fd_out);
+		if (out.file) {
+			if (!(out.file->f_mode & FMODE_WRITE)) {
+				error = -EBADF;
+				goto done;
+			}
+			if (!(out.file->f_mode & FMODE_CAN_WRITE)) {
+				error = -EINVAL;
+				goto done;
+			}
+
+			ret = rw_verify_area(WRITE, out.file, off_out, len);
+			if (ret < 0) {
+				error = ret;
+				goto done;
+			}
+
+			len = ret;
+			if (!out.file->f_op->splice_from_socket)
+				goto done;
+			error = out.file->f_op->splice_from_socket(out.file,
+								   sock,
+								   off_out,
+								   len);
+		}
+done:
+		fdput(out);
+nosock:
+		fput(sock->file);
+		return error;
+	}
+#endif
+
 	in = fdget(fd_in);
 	if (in.file) {
 		if (in.file->f_mode & FMODE_READ) {
diff --git a/include/linux/fs.h b/include/linux/fs.h
index ab3d8d9..8890825 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -52,6 +52,9 @@ struct swap_info_struct;
 struct seq_file;
 struct workqueue_struct;
 struct iov_iter;
+#ifdef CONFIG_SPLICE_FROM_SOCKET
+struct socket;
+#endif
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -1632,6 +1635,9 @@ struct file_operations {
 	int (*flock) (struct file *, int, struct file_lock *);
 	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
 	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
+#ifdef CONFIG_SPLICE_FROM_SOCKET
+	ssize_t (*splice_from_socket)(struct file *file, struct socket *sock, loff_t __user *ppos, size_t count);
+#endif
 	int (*setlease)(struct file *, long, struct file_lock **, void **);
 	long (*fallocate)(struct file *file, int mode, loff_t offset,
 			  loff_t len);
-- 
1.9.1

