From 560417023011aaf3bbdae807d07af4ed68ac18e8 Mon Sep 17 00:00:00 2001
From: Shadi Ammouri <shadi@marvell.com>
Date: Tue, 8 Mar 2016 15:18:41 +0200
Subject: [PATCH 247/538] clk: xor: Add support for multi clocks gating

Try to acquire and enable multiple (up to 4) clocks for XOR engine
clock gating.

Change-Id: I45b6c8719afd7bd4b062c43c5ef5dae397943106
Signed-off-by: Shadi Ammouri <shadi@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/28118
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
---
 drivers/dma/mv_xor_v2.c | 32 ++++++++++++++++++++++++--------
 1 file changed, 24 insertions(+), 8 deletions(-)

diff --git a/drivers/dma/mv_xor_v2.c b/drivers/dma/mv_xor_v2.c
index 5062faf..4a7c622 100644
--- a/drivers/dma/mv_xor_v2.c
+++ b/drivers/dma/mv_xor_v2.c
@@ -86,6 +86,9 @@
 /* descriptors queue size */
 #define MV_XOR_V2_MAX_DESC_NUM	1024
 
+/* Maximum number of XOR engine gating clocks. */
+#define MAX_A8K_XOR_CLOCKS	4
+
 /**
  * struct mv_xor_v2_descriptor - DMA HW descriptor
  * @desc_id: used by S/W and is not affected by H/W.
@@ -150,7 +153,7 @@ struct mv_xor_v2_device {
 	spinlock_t cookie_lock;
 	void __iomem *dma_base;
 	void __iomem *glob_base;
-	struct clk *clk;
+	struct clk *clk[MAX_A8K_XOR_CLOCKS];
 	struct tasklet_struct irq_tasklet;
 	struct list_head free_sw_desc;
 	struct dma_device dmadev;
@@ -761,6 +764,7 @@ static int mv_xor_v2_probe(struct platform_device *pdev)
 	struct mv_xor_v2_sw_desc *sw_desc;
 	struct msi_desc *msi_desc;
 	struct device *dev = &pdev->dev;
+	struct clk *clk;
 
 	dev_notice(&pdev->dev, "Marvell Version 2 XOR driver\n");
 
@@ -780,13 +784,16 @@ static int mv_xor_v2_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, xor_dev);
 
-	xor_dev->clk = devm_clk_get(dev, NULL);
-	if (!IS_ERR(xor_dev->clk)) {
-		ret = clk_prepare_enable(xor_dev->clk);
-		if (ret) {
-			dev_err(dev, "Failed to enable XOR clock.\n");
-			devm_clk_put(dev, xor_dev->clk);
-			return ret;
+	/* Optionaly enable clocks */
+	for (i = 0; i < MAX_A8K_XOR_CLOCKS; i++) {
+		clk = of_clk_get(dev->of_node, i);
+		if (!IS_ERR(clk)) {
+			if (clk_prepare_enable(clk)) {
+				dev_err(dev, "Failed to enable clock %d for XOR engine.\n", i);
+				devm_clk_put(dev, clk);
+				goto free_clocks;
+			}
+			xor_dev->clk[i] = clk;
 		}
 	}
 
@@ -893,6 +900,15 @@ free_hw_desq:
 			  xor_dev->hw_desq_virt, xor_dev->hw_desq);
 free_msi_irqs:
 	platform_msi_domain_free_irqs(&pdev->dev);
+
+free_clocks:
+	for (i = 0; i < MAX_A8K_XOR_CLOCKS; i++) {
+		if (xor_dev->clk[i]) {
+			clk_disable_unprepare(xor_dev->clk[i]);
+			devm_clk_put(dev, xor_dev->clk[i]);
+		}
+	}
+
 	return ret;
 }
 
-- 
1.9.1

