From e8891707feb560d7972244d725c6d2ddc6a6bf2b Mon Sep 17 00:00:00 2001
From: Terry Zhou <bjzhou@marvell.com>
Date: Tue, 1 Mar 2016 09:28:20 +0800
Subject: [PATCH 319/538] clk: a3700: add core clock driver for Armada 3700

- Add new driver to handle the core clocks found in the a3700 SOC,
  reads the CPU registers to determine the frequencies of several
  core clocks: TBG-A/B-S/P, CPU, DDR, SATA, USB, GBE, etc.
- Take core clock as the parent of the corresponding gating clock

Change-Id: I9ca79296392c186da89f9301ff9dad0c1c28fa33
Signed-off-by: Terry Zhou <bjzhou@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/27953
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Victor Gu <xigu@marvell.com>
---
 .../bindings/clock/mvebu-armada3700-clock.txt      |  28 ++-
 arch/arm64/boot/dts/marvell/armada-37xx.dtsi       |   6 +
 drivers/clk/mvebu/armada-3700.c                    | 269 ++++++++++++++++++++-
 drivers/clk/mvebu/armada-3700.h                    | 134 ++++++++++
 4 files changed, 430 insertions(+), 7 deletions(-)
 create mode 100644 drivers/clk/mvebu/armada-3700.h

diff --git a/Documentation/devicetree/bindings/clock/mvebu-armada3700-clock.txt b/Documentation/devicetree/bindings/clock/mvebu-armada3700-clock.txt
index 3c76d93..34931c6 100644
--- a/Documentation/devicetree/bindings/clock/mvebu-armada3700-clock.txt
+++ b/Documentation/devicetree/bindings/clock/mvebu-armada3700-clock.txt
@@ -1,11 +1,33 @@
 * Clock bindings for Marvell MVEBU Armada3700 SoCs
 
-Marvell Armada 3700 allow some peripheral clocks to be gated to save power.The clock
+Armada3700 SoCs usually allow to determine core clock frequencies by
+reading the CPU registers. The core clock consumer should
+specify the desired clock by having the clock ID in its "clocks" phandle cell.
+
+Also, Marvell Armada3700 allow some peripheral clocks to be gated to save power.The clock
 consumer should specify the desired clock by having the clock ID in its
 "clocks" phandle cell. The clock ID is directly mapped to the corresponding clock
 gating control bit in HW to ease manual clock lookup in datasheet.
 
-Required properties:
+In most of the time, the core clock modules have the corresponding gating
+control bit, the kernel driver will take the core clock as the parent of
+the gating clock, thus, the consumer only need to specify the gating clock ID.
+
+Core Clock Required properties:
+- compatible : shall be one of the following:
+	"marvell,armada-3700-core-clock" - For Armada 3700 SoC core clocks
+- reg : shall be the register address of the clock related register
+- #clock-cells : from common clock binding; shall be set to 1
+
+Example:
+
+core_clk: core-clocks@13000 {
+	compatible = "marvell,armada-3700-core-clock";
+	reg = <0x13000 0x6000>;
+	#clock-cells = <1>;
+};
+
+Gated Clock Required properties:
 - compatible : shall be one of the following:
 	"marvell,armada-3700-north-bridge-gating-clock" - gate clock control for Armada 3700 north bridge
 	"marvell,armada-3700-south-bridge-gating-clock" - gate clock control for Armada 3700 south bridge
@@ -37,4 +59,4 @@ sata0: sata@e0000 {
 	interrupts = <0 27 4>;
 	clocks = <&ngateclk 3>;
 	status = "disabled";
-};
\ No newline at end of file
+};
diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
index 702df38..42210bd 100644
--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
@@ -138,6 +138,12 @@
 				status = "disabled";
 			};
 
+			core_clk: core-clocks@13000 {
+				compatible = "marvell,armada-3700-core-clock";
+				reg = <0x13000 0x6000>;
+				#clock-cells = <1>;
+			};
+
 			ngateclk: north-bridge-gate-clk@13014 {
 				compatible = "marvell,armada-3700-north-bridge-gating-clock";
 				reg = <0x13014 0x4>;
diff --git a/drivers/clk/mvebu/armada-3700.c b/drivers/clk/mvebu/armada-3700.c
index 2e837fa..e34b11c 100644
--- a/drivers/clk/mvebu/armada-3700.c
+++ b/drivers/clk/mvebu/armada-3700.c
@@ -17,16 +17,277 @@
 */
 
 #include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
 #include <linux/clk-provider.h>
 #include <linux/io.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/syscore_ops.h>
+
 #include "common.h"
+#include "armada-3700.h"
+
+/*
+ * Core Clock
+ */
+
+static void __iomem *northbase; /* kernel address of MVEBU_NORTH_CLOCK_REGS_BASE */
+#define clkr32(reg)	readl(northbase + (reg))
+
+const char *tbg_clk_name[MVEBU_A3700_TBG_CLK_NUM] = {"tbg_a_p", "tbg_b_p", "tbg_a_s", "tbg_b_s"};
+
+/***************************************************************************************************
+  * get_ref_clk
+  *
+  * return: reference clock in MHz (25 or 40)
+ ***************************************************************************************************/
+static u32 get_ref_clk(void)
+{
+	u32 regval;
+
+	regval = (clkr32(MVEBU_TEST_PIN_LATCH_N) & MVEBU_XTAL_MODE_MASK) >> MVEBU_XTAL_MODE_OFFS;
+
+	if (regval == MVEBU_XTAL_CLOCK_25MHZ)
+		return 25;
+	else
+		return 40;
+}
+
+/***************************************************************************************************
+  * get_tbg_clk
+  *
+  * return: reference clock in Hz
+ ***************************************************************************************************/
+static u32 get_tbg_clk(enum a3700_clock_line tbg_typ)
+{
+	u32 tbg_M, tbg_N, vco_div;
+	u32 ref, reg_val;
+
+	/* get ref clock */
+	ref = get_ref_clk();
+
+	/* get M, N */
+	reg_val = clkr32(MVEBU_NORTH_BRG_TBG_CTRL7);
+	tbg_M = ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_A_P)) ?
+		((reg_val  >> MVEBU_TBG_A_REFDIV_OFFSET) & MVEBU_TBG_DIV_MASK) :
+		((reg_val >> MVEBU_TBG_B_REFDIV_OFFSET) & MVEBU_TBG_DIV_MASK);
+	tbg_M = (tbg_M == 0) ? 1 : tbg_M;
+
+	reg_val = clkr32(MVEBU_NORTH_BRG_TBG_CTRL0);
+	tbg_N = ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_A_P)) ?
+		((reg_val >> MVEBU_TBG_A_FBDIV_OFFSET) & MVEBU_TBG_DIV_MASK) :
+		((reg_val >> MVEBU_TBG_B_FBDIV_OFFSET) & MVEBU_TBG_DIV_MASK);
+
+	if ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_B_S)) {
+		/* get SE VCODIV */
+		reg_val = clkr32(MVEBU_NORTH_BRG_TBG_CTRL1);
+		reg_val = (tbg_typ == TBG_A_S) ?
+			  ((reg_val >> MVEBU_TBG_A_VCODIV_SE_OFFSET) & MVEBU_TBG_DIV_MASK) :
+			  ((reg_val >> MVEBU_TBG_B_VCODIV_SE_OFFSET) & MVEBU_TBG_DIV_MASK);
+	} else {
+		/* get DIFF VCODIV */
+		reg_val = clkr32(MVEBU_NORTH_BRG_TBG_CTRL8);
+		reg_val = (tbg_typ == TBG_A_P) ?
+			  ((reg_val >> MVEBU_TBG_A_VCODIV_DIFF_OFFSET) & MVEBU_TBG_DIV_MASK) :
+			  ((reg_val >> MVEBU_TBG_B_VCODIV_DIFF_OFFSET) & MVEBU_TBG_DIV_MASK);
+	}
+	if (reg_val > MVEBU_TBG_VCODIV_MAX)
+		return 0; /* invalid */
+
+	vco_div = 0x1 << reg_val;
+
+	/* align with the FS */
+	return (((tbg_N * ref) << 2)/(tbg_M * vco_div)) * 1000000;
+}
+
+enum {
+	A3700_TBG_TO_CPU_CLK = 0,
+	A3700_TBG_TO_DDR_CLK,
+	A3700_TBG_TO_SATA_CLK,
+	A3700_TBG_TO_MMC_CLK,
+	A3700_TBG_TO_USB_CLK,
+	A3700_TBG_TO_GBE0_CLK,
+	A3700_TBG_TO_GBE1_CLK,
+};
+
+static const struct coreclk_ratio armada_3700_coreclk_ratios[] __initconst = {
+	{ .id = A3700_TBG_TO_CPU_CLK, .name = "cpu" },
+	{ .id = A3700_TBG_TO_DDR_CLK, .name = "ddr" },
+	{ .id = A3700_TBG_TO_SATA_CLK, .name = "sata-host" },
+	{ .id = A3700_TBG_TO_MMC_CLK, .name = "mmc" },
+	{ .id = A3700_TBG_TO_USB_CLK, .name = "usb32-ss-sys" },
+	{ .id = A3700_TBG_TO_GBE0_CLK, .name = "gbe0-core" },
+	{ .id = A3700_TBG_TO_GBE1_CLK, .name = "gbe1-core" },
+};
+
+/***************************************************************************************************
+  * get the clock ratio and TBG module according to the clock id
+ ***************************************************************************************************/
+static void __init armada_3700_get_clk_ratio(
+	void __iomem *base, int id, int *tbg, int *mult, int *div)
+{
+	int prscl1, prscl2, div2;
+	*mult = 1;
+
+	switch (id) {
+	case A3700_TBG_TO_CPU_CLK:
+		*tbg = (clkr32(MVEBU_NORTH_CLOCK_TBG_SELECT_REG) >> TBG_WCPU_PCLK_SEL_OFFSET) & MVEBU_TBG_CLK_SEL_MASK;
+		*div = (clkr32(MVEBU_NORTH_CLOCK_DIVIDER_SELECT0_REG) >> WCPU_CLK_DIV_PRSCL_OFFSET) &
+					MVEBU_TBG_CLK_PRSCL_MASK;
+		break;
+
+	case A3700_TBG_TO_DDR_CLK:
+		*tbg = TBG_A_S;/* DDR always use TBG_A_S */
+		*div = 2;
+		break;
+
+	case A3700_TBG_TO_SATA_CLK:
+		*tbg = (clkr32(MVEBU_NORTH_CLOCK_TBG_SELECT_REG) >> TBG_SATA_HOST_PCLK_SEL_OFFSET) &
+					MVEBU_TBG_CLK_SEL_MASK;
+		prscl1 = (clkr32(MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG) >> SATA_HOST_CLK_PRSCL1_OFFSET) &
+					MVEBU_TBG_CLK_PRSCL_MASK;
+		prscl2 = (clkr32(MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG) >> SATA_HOST_CLK_PRSCL2_OFFSET) &
+					MVEBU_TBG_CLK_PRSCL_MASK;
+		*div = prscl1 * prscl2;
+		break;
+
+	case A3700_TBG_TO_MMC_CLK:
+		*tbg = (clkr32(MVEBU_NORTH_CLOCK_TBG_SELECT_REG) >> TBG_MMC_PCLK_SEL_OFFSET) &
+					MVEBU_TBG_CLK_SEL_MASK;
+		prscl1 = (clkr32(MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG) >> MMC_CLK_PRSCL1_OFFSET) &
+					MVEBU_TBG_CLK_PRSCL_MASK;
+		prscl2 = (clkr32(MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG) >> MMC_CLK_PRSCL2_OFFSET) &
+					MVEBU_TBG_CLK_PRSCL_MASK;
+		*div = prscl1 * prscl2;
+		break;
+
+	case A3700_TBG_TO_USB_CLK:
+		*tbg = (clkr32(MVEBU_SOUTH_CLOCK_TBG_SELECT_REG) >> TBG_USB32_SS_CLK_SEL_OFFSET) &
+					MVEBU_TBG_CLK_SEL_MASK;
+		prscl1 = (clkr32(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT0_REG) >> USB32_SS_SYS_CLK_PRSCL1_OFFSET) &
+					MVEBU_TBG_CLK_PRSCL_MASK;
+		prscl2 = (clkr32(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT0_REG) >> USB32_SS_SYS_CLK_PRSCL2_OFFSET) &
+					MVEBU_TBG_CLK_PRSCL_MASK;
+		*div = prscl1 * prscl2;
+		break;
+
+	case A3700_TBG_TO_GBE0_CLK:
+		*tbg = (clkr32(MVEBU_SOUTH_CLOCK_TBG_SELECT_REG) >> TBG_GBE_CORE_CLK_SEL_OFFSET) &
+					MVEBU_TBG_CLK_SEL_MASK;
+		prscl1 = (clkr32(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG) >> GBE_CORE_CLK_PRSCL1_OFFSET) &
+					MVEBU_TBG_CLK_PRSCL_MASK;
+		prscl2 = (clkr32(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG) >> GBE_CORE_CLK_PRSCL2_OFFSET) &
+					MVEBU_TBG_CLK_PRSCL_MASK;
+		div2 = (clkr32(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG) >> GBE0_CORE_CLK_DIV_OFFSET) &
+					MVEBU_TBG_CLK_DIV_MASK;
+		*div = (prscl1 * prscl2) << div2;
+		break;
+
+	case A3700_TBG_TO_GBE1_CLK:
+		*tbg = (clkr32(MVEBU_SOUTH_CLOCK_TBG_SELECT_REG) >> TBG_GBE_CORE_CLK_SEL_OFFSET) &
+					MVEBU_TBG_CLK_SEL_MASK;
+		prscl1 = (clkr32(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG) >> GBE_CORE_CLK_PRSCL1_OFFSET) &
+					MVEBU_TBG_CLK_PRSCL_MASK;
+		prscl2 = (clkr32(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG) >> GBE_CORE_CLK_PRSCL2_OFFSET) &
+					MVEBU_TBG_CLK_PRSCL_MASK;
+		div2 = (clkr32(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG) >> GBE1_CORE_CLK_DIV_OFFSET) &
+					MVEBU_TBG_CLK_DIV_MASK;
+		*div = (prscl1 * prscl2) << div2;
+		break;
+
+	default:
+		*div = 0;
+		break;
+	}
+}
+
+static u32 __init armada_3700_get_tbg_freq(void __iomem *base, int tbg_index)
+{
+	return get_tbg_clk(tbg_index);
+}
+
+static const char *__init armada_3700_get_tbg_name(int tbg_index)
+{
+	return tbg_clk_name[tbg_index];
+}
+
+static const struct a3700_clk_desc armada_3700_coreclks = {
+	.get_tbg_freq = armada_3700_get_tbg_freq,
+	.get_tbg_name = armada_3700_get_tbg_name,
+	.get_clk_ratio = armada_3700_get_clk_ratio,
+	.ratios = armada_3700_coreclk_ratios,
+	.num_ratios = ARRAY_SIZE(armada_3700_coreclk_ratios),
+	.num_tbg = MVEBU_A3700_TBG_CLK_NUM,
+};
+
+void __init armada3700_coreclk_setup(struct device_node *np,
+				const struct a3700_clk_desc *desc)
+{
+	struct clk_onecell_data *clk_data;
+	void __iomem *base;
+	unsigned long rate;
+	int i;
+
+	clk_data = kmalloc(sizeof(*clk_data), GFP_KERNEL);
+	if (!clk_data)
+		return;
+
+	base = of_iomap(np, 0);
+	if (WARN_ON(!base))
+		return;
+
+	northbase = base; /* save it into static variable, only needed once */
+
+	/* Allocate struct for TBG_A(P/S), TBG_B(P/S), and ratio clocks */
+	clk_data->clk_num = desc->num_tbg + desc->num_ratios;
+
+	clk_data->clks = kcalloc(clk_data->clk_num, sizeof(struct clk *),
+				GFP_KERNEL);
+	if (WARN_ON(!clk_data->clks)) {
+		iounmap(base);
+		return;
+	}
+
+	/* Register TBG clocks */
+	for (i = 0; i < desc->num_tbg; i++) {
+		rate = desc->get_tbg_freq(base, i);
+		clk_data->clks[i] = clk_register_fixed_rate(NULL, desc->get_tbg_name(i), NULL,
+							   CLK_IS_ROOT, rate);
+		WARN_ON(IS_ERR(clk_data->clks[i]));
+	}
+
+	/* Register fixed-factor clocks derived from TBG clock */
+	for (i = 0; i < desc->num_ratios; i++) {
+		const char *rclk_name = desc->ratios[i].name;
+		int tbg, mult, div;
+
+		desc->get_clk_ratio(base, desc->ratios[i].id, &tbg, &mult, &div);
+		clk_data->clks[desc->num_tbg+i] = clk_register_fixed_factor(NULL, rclk_name,
+				       desc->get_tbg_name(tbg), 0, mult, div);
+		WARN_ON(IS_ERR(clk_data->clks[desc->num_tbg+i]));
+	};
+
+	/* register isn't needed anymore */
+	iounmap(base);
+
+	of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+}
+
+
+static void __init armada_3700_coreclk_init(struct device_node *np)
+{
+	armada3700_coreclk_setup(np, &armada_3700_coreclks);
+}
+
+CLK_OF_DECLARE(armada_3700_core_clk, "marvell,armada-3700-core-clock",
+	       armada_3700_coreclk_init);
 
 /*
  * Clock Gating Control
  */
 static const struct clk_gating_soc_desc armada_3700_north_bridge_gating_desc[] __initconst = {
-	{ "sata-host", NULL, 3, 0, CLK_GATE_SET_TO_DISABLE },
+	{ "sata-host-gate", "sata-host", 3, 0, CLK_GATE_SET_TO_DISABLE },
 	{ "twsi2", NULL, 16, 0, CLK_GATE_SET_TO_DISABLE },
 	{ "twsi1", NULL, 17, 0, CLK_GATE_SET_TO_DISABLE },
 	{ }
@@ -42,9 +303,9 @@ CLK_OF_DECLARE(armada_3700_north_bridge_clk_gating,
 	       armada_3700_north_bridge_clk_gating_init);
 
 static const struct clk_gating_soc_desc armada_3700_south_bridge_gating_desc[] __initconst = {
-	{ "gbe1-core", NULL, 4, 0, CLK_GATE_SET_TO_DISABLE },
-	{ "gbe0-core", NULL, 5, 0, CLK_GATE_SET_TO_DISABLE },
-	{ "usb32-ss-sys", NULL, 17, 0, CLK_GATE_SET_TO_DISABLE },
+	{ "gbe1-gate", "gbe1-core", 4, 0, CLK_GATE_SET_TO_DISABLE },
+	{ "gbe0-gate", "gbe0-core", 5, 0, CLK_GATE_SET_TO_DISABLE },
+	{ "usb32-ss-sys-gate", "usb32-ss-sys", 17, 0, CLK_GATE_SET_TO_DISABLE },
 	{ }
 };
 
diff --git a/drivers/clk/mvebu/armada-3700.h b/drivers/clk/mvebu/armada-3700.h
new file mode 100644
index 0000000..863bc39
--- /dev/null
+++ b/drivers/clk/mvebu/armada-3700.h
@@ -0,0 +1,134 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+#ifndef __CLK_MVEBU_ARMADA_3700_H_
+#define __CLK_MVEBU_ARMADA_3700_H_
+
+enum a3700_clock_src {
+	TBG_A,
+	TBG_B
+};
+
+enum a3700_clock_line {
+	TBG_A_P = 0,
+	TBG_B_P = 1,
+	TBG_A_S = 2,
+	TBG_B_S = 3
+};
+
+struct a3700_clk_desc {
+	u32 (*get_tbg_freq)(void __iomem *reg, int tbg_index);
+	const char* (*get_tbg_name)(int tbg_index);
+	void (*get_clk_ratio)(void __iomem *reg, int id, int *tbg_index, int *mult, int *div);
+	const struct coreclk_ratio *ratios;
+	int num_ratios;
+	int num_tbg;
+};
+
+#define MVEBU_A3700_TBG_CLK_NUM		4
+
+/* Register offset of NORTH_CLOCK_REGS_BASE */
+#define MVEBU_SOUTH_CLOCK_REGS_BASE	(0x5000)
+#define MVEBU_TESTPIN_NORTH_REG_BASE	(0x800)
+
+/* Reset sample */
+#define MVEBU_TEST_PIN_LATCH_N		(MVEBU_TESTPIN_NORTH_REG_BASE + 0x8)
+
+/********************************/
+/* REF Clock                    */
+/********************************/
+#define MVEBU_XTAL_MODE_MASK		0x00000200
+#define MVEBU_XTAL_MODE_OFFS		(9)
+#define MVEBU_XTAL_CLOCK_25MHZ		(0x0)
+#define MVEBU_XTAL_CLOCK_40MHZ		(0x1)
+
+/****************/
+/* North Bridge */
+/****************/
+#define MVEBU_NORTH_BRG_PLL_BASE		(0x200)
+#define MVEBU_NORTH_BRG_TBG_CFG			(MVEBU_NORTH_BRG_PLL_BASE + 0x0)
+#define MVEBU_NORTH_BRG_TBG_CTRL0		(MVEBU_NORTH_BRG_PLL_BASE + 0x4)
+#define MVEBU_NORTH_BRG_TBG_CTRL1		(MVEBU_NORTH_BRG_PLL_BASE + 0x8)
+#define MVEBU_NORTH_BRG_TBG_CTRL2		(MVEBU_NORTH_BRG_PLL_BASE + 0xC)
+#define MVEBU_NORTH_BRG_TBG_CTRL3		(MVEBU_NORTH_BRG_PLL_BASE + 0x10)
+#define MVEBU_NORTH_BRG_TBG_CTRL4		(MVEBU_NORTH_BRG_PLL_BASE + 0x14)
+#define MVEBU_NORTH_BRG_TBG_CTRL5		(MVEBU_NORTH_BRG_PLL_BASE + 0x18)
+#define MVEBU_NORTH_BRG_TBG_CTRL6		(MVEBU_NORTH_BRG_PLL_BASE + 0x1C)
+#define MVEBU_NORTH_BRG_TBG_CTRL7		(MVEBU_NORTH_BRG_PLL_BASE + 0x20)
+#define MVEBU_NORTH_BRG_TBG_CTRL8		(MVEBU_NORTH_BRG_PLL_BASE + 0x30)
+
+/* tbg definition */
+#define MVEBU_TBG_CLK_SEL_MASK			0x3
+#define MVEBU_TBG_CLK_PRSCL_MASK		0x7
+#define MVEBU_TBG_CLK_DIV_MASK			0x1
+
+#define MVEBU_TBG_DIV_MASK			0x1FFUL
+#define MVEBU_TBG_A_REFDIV_OFFSET		(0)
+#define MVEBU_TBG_B_REFDIV_OFFSET		(16)
+
+#define MVEBU_TBG_A_FBDIV_OFFSET		(2)
+#define MVEBU_TBG_B_FBDIV_OFFSET		(18)
+
+#define MVEBU_TBG_VCODIV_MAX	0x7
+#define MVEBU_TBG_A_VCODIV_SE_OFFSET		(0)
+#define MVEBU_TBG_A_VCODIV_DIFF_OFFSET		(1)
+#define MVEBU_TBG_B_VCODIV_SE_OFFSET		(16)
+#define MVEBU_TBG_B_VCODIV_DIFF_OFFSET		(17)
+
+/* north bridge clock TBG select register */
+#define MVEBU_NORTH_CLOCK_TBG_SELECT_REG	(0x0)
+#define TBG_WCPU_PCLK_SEL_OFFSET		(22)
+#define TBG_SATA_HOST_PCLK_SEL_OFFSET		(2)
+#define TBG_MMC_PCLK_SEL_OFFSET		(0)
+
+/* north bridge clock divider select registers */
+#define MVEBU_NORTH_CLOCK_DIVIDER_SELECT0_REG	(0x4)
+#define WCPU_CLK_DIV_PRSCL_OFFSET	(28)
+
+#define MVEBU_NORTH_CLOCK_DIVIDER_SELECT1_REG	(0x8)
+
+#define MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG	(0xC)
+#define MMC_CLK_PRSCL1_OFFSET		(16)
+#define MMC_CLK_PRSCL2_OFFSET		(13)
+#define SATA_HOST_CLK_PRSCL1_OFFSET		(10)
+#define SATA_HOST_CLK_PRSCL2_OFFSET		(7)
+
+/****************/
+/* South Bridge */
+/****************/
+
+/* north bridge clock TBG select register */
+#define MVEBU_SOUTH_CLOCK_TBG_SELECT_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x0)
+#define TBG_USB32_SS_CLK_SEL_OFFSET	(18)
+#define TBG_GBE_CORE_CLK_SEL_OFFSET	(8)
+
+#define MVEBU_SOUTH_CLOCK_DIVIDER_SELECT0_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x4)
+#define USB32_SS_SYS_CLK_PRSCL1_OFFSET		(18)
+#define USB32_SS_SYS_CLK_PRSCL2_OFFSET		(15)
+
+
+#define MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x8)
+#define GBE_CORE_CLK_PRSCL1_OFFSET		(21)
+#define GBE_CORE_CLK_PRSCL2_OFFSET		(18)
+#define GBE0_CORE_CLK_DIV_OFFSET		(14)
+#define GBE1_CORE_CLK_DIV_OFFSET		(13)
+
+#define MVEBU_SOUTH_CLOCK_DIVIDER_SELECT2_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0xC)
+
+#endif
+
-- 
1.9.1

