From a7ee2b78c79e43ed6fbb6e6b9c629b4fb34d3162 Mon Sep 17 00:00:00 2001
From: Marcin Wojtas <mw@semihalf.com>
Date: Wed, 13 Apr 2016 04:27:54 +0200
Subject: [PATCH 347/538] PCI: advk: enable MSI handling in Root Complex mode

In root complex mode PCIe controller of Armada 3700 enables MSI
processing in two ways ('internal' and 'external). This commit
enables first option with MSI_ENABLE bit and also obtaining
msi-parent data from device tree. Documentation is updated
accordingly.

Change-Id: I08869474f3894bbf2230bc3364ccd7282e438ccf
Signed-off-by: Marcin Wojtas <mw@semihalf.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/29057
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
---
 Documentation/devicetree/bindings/pci/advk-pci.txt |  2 ++
 drivers/pci/host/pci-advk-arm64.c                  | 23 ++++++++++++++++++++++
 2 files changed, 25 insertions(+)

diff --git a/Documentation/devicetree/bindings/pci/advk-pci.txt b/Documentation/devicetree/bindings/pci/advk-pci.txt
index bf1e38e..4258776 100644
--- a/Documentation/devicetree/bindings/pci/advk-pci.txt
+++ b/Documentation/devicetree/bindings/pci/advk-pci.txt
@@ -11,6 +11,7 @@ Mandatory properties:
 - #size-cells, set to <2>
 - #interrupt-cells, set to <3>
 - bus-range: PCI bus numbers covered
+- msi-parent: parent MSI interrupt controller
 - ranges: ranges describing the IO registers to control the PCIe
   interfaces, and ranges describing the Memory windows needed to access
   the memory and I/O regions of each PCIe interface.
@@ -46,6 +47,7 @@ Example:
 		#size-cells = <2>;
 		dma-coherent;
 
+		msi-parent = <&advk_ic>;
 
 		bus-range = <0x00 0xff>;
 
diff --git a/drivers/pci/host/pci-advk-arm64.c b/drivers/pci/host/pci-advk-arm64.c
index 7289982..9a7f9ae 100644
--- a/drivers/pci/host/pci-advk-arm64.c
+++ b/drivers/pci/host/pci-advk-arm64.c
@@ -424,6 +424,9 @@ static void advk_pcie_setup_hw(struct advk_pcie_port *port)
 	/* Disable strict ordering */
 	state = advk_readl(port, PCIE_CORE_CTRL_REG_ADDR(PCIE_CORE_CTRL2_REG));
 	state &= ~STRICT_ORDER_ENABLE;
+#ifdef CONFIG_PCI_MSI
+	state |= MSI_ENABLE;
+#endif
 	advk_writel(port, state, PCIE_CORE_CTRL_REG_ADDR(PCIE_CORE_CTRL2_REG));
 
 	/* Start link training */
@@ -1105,6 +1108,22 @@ static void __iomem *advk_pcie_map_registers(struct platform_device *pdev,
 	return devm_ioremap_resource(&pdev->dev, &regs);
 }
 
+#ifdef CONFIG_PCI_MSI
+static struct msi_controller *advk_pcie_msi_init(struct device_node *np)
+{
+	struct device_node *msi_node;
+	struct msi_controller *msi;
+
+	msi_node = of_parse_phandle(np, "msi-parent", 0);
+	if (!msi_node)
+		return NULL;
+
+	msi = of_pci_find_msi_chip_by_node(msi_node);
+
+	return msi;
+}
+#endif
+
 static int advk_pcie_probe(struct platform_device *pdev)
 {
 	struct advk_pcie *pcie;
@@ -1231,6 +1250,10 @@ static int advk_pcie_probe(struct platform_device *pdev)
 	if (!bus)
 		return -ENOMEM;
 
+#ifdef CONFIG_PCI_MSI
+	bus->msi = advk_pcie_msi_init(np);
+#endif
+
 	pci_scan_child_bus(bus);
 	pci_assign_unassigned_bus_resources(bus);
 	pci_bus_add_devices(bus);
-- 
1.9.1

