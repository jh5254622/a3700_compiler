From f33bc11be607b5821a5b755535de50266e3f9641 Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Wed, 27 Apr 2016 10:33:09 +0300
Subject: [PATCH 366/538] pinctrl: ap806: add pinctrl driver for Armada-AP806

Change-Id: I915dea00b34561d91ab2f8e0cd680da56e26be25
Signed-off-by: Hanna Hawa <hannah@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/29395
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Shadi Ammouri <shadi@marvell.com>
---
 arch/arm64/Kconfig.platforms                  |   1 +
 arch/arm64/boot/dts/marvell/armada-ap806.dtsi |   5 +
 drivers/pinctrl/mvebu/Kconfig                 |   4 +
 drivers/pinctrl/mvebu/Makefile                |   1 +
 drivers/pinctrl/mvebu/pinctrl-armada-ap806.c  | 169 ++++++++++++++++++++++++++
 5 files changed, 180 insertions(+)
 create mode 100644 drivers/pinctrl/mvebu/pinctrl-armada-ap806.c

diff --git a/arch/arm64/Kconfig.platforms b/arch/arm64/Kconfig.platforms
index 2a5cf3f..9ecee10 100644
--- a/arch/arm64/Kconfig.platforms
+++ b/arch/arm64/Kconfig.platforms
@@ -12,6 +12,7 @@ config ARCH_MVEBU
 	select ARMADA_AP806_CORE_CLK
 	select ARMADA_AP806_RING_CLK
 	select ARMADA_AP806_SYSCON
+	select PINCTRL_ARMADA_AP806
 	select ARMADA_CP110_CLK
 	help
 	  This enables support for Marvell EBU familly, including:
diff --git a/arch/arm64/boot/dts/marvell/armada-ap806.dtsi b/arch/arm64/boot/dts/marvell/armada-ap806.dtsi
index 733e65f..7f77b3b 100644
--- a/arch/arm64/boot/dts/marvell/armada-ap806.dtsi
+++ b/arch/arm64/boot/dts/marvell/armada-ap806.dtsi
@@ -218,6 +218,11 @@
 				status = "disabled";
 			};
 
+			pinctrl@6F4000 {
+				compatible = "marvell,ap806-pinctrl";
+				reg = <0x6F4000 0x10>;
+			};
+
 			serial@512000 {
 				compatible = "snps,dw-apb-uart";
 				reg = <0x512000 0x100>;
diff --git a/drivers/pinctrl/mvebu/Kconfig b/drivers/pinctrl/mvebu/Kconfig
index f8e503d..4103097 100644
--- a/drivers/pinctrl/mvebu/Kconfig
+++ b/drivers/pinctrl/mvebu/Kconfig
@@ -7,6 +7,10 @@ config PINCTRL_ARMADA_3700
 	bool
 	select PINCTRL_MVEBU
 
+config PINCTRL_ARMADA_AP806
+	bool
+	select PINCTRL_MVEBU
+
 if PLAT_ORION
 
 config PINCTRL_DOVE
diff --git a/drivers/pinctrl/mvebu/Makefile b/drivers/pinctrl/mvebu/Makefile
index 5506126..8b5cbeb 100644
--- a/drivers/pinctrl/mvebu/Makefile
+++ b/drivers/pinctrl/mvebu/Makefile
@@ -7,4 +7,5 @@ obj-$(CONFIG_PINCTRL_ARMADA_38X) += pinctrl-armada-38x.o
 obj-$(CONFIG_PINCTRL_ARMADA_39X) += pinctrl-armada-39x.o
 obj-$(CONFIG_PINCTRL_ARMADA_XP)  += pinctrl-armada-xp.o
 obj-$(CONFIG_PINCTRL_ARMADA_3700) += pinctrl-armada-3700.o
+obj-$(CONFIG_PCIE_ARMADA_8K) += pinctrl-armada-ap806.o
 obj-$(CONFIG_PINCTRL_ORION)  += pinctrl-orion.o
diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c b/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c
new file mode 100644
index 0000000..ba585170
--- /dev/null
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-ap806.c
@@ -0,0 +1,169 @@
+/*
+ * Marvell Armada ap806 pinctrl driver based on mvebu pinctrl core
+ *
+ * Copyright (C) 2015 Marvell
+ *
+ * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
+ * Hanna Hawa <hannah@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/pinctrl.h>
+
+#include "pinctrl-mvebu.h"
+
+static void __iomem *mpp_base;
+
+static int armada_ap806_mpp_ctrl_get(unsigned pid, unsigned long *config)
+{
+	return default_mpp_ctrl_get(mpp_base, pid, config);
+}
+
+static int armada_ap806_mpp_ctrl_set(unsigned pid, unsigned long config)
+{
+	return default_mpp_ctrl_set(mpp_base, pid, config);
+}
+
+static struct mvebu_mpp_mode armada_ap806_mpp_modes[] = {
+	MPP_MODE(0,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "clk"),
+		 MPP_FUNCTION(3, "spi0",    "clk")),
+	MPP_MODE(1,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "cmd"),
+		 MPP_FUNCTION(3, "spi0",    "miso")),
+	MPP_MODE(2,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d0"),
+		 MPP_FUNCTION(3, "spi0",    "mosi")),
+	MPP_MODE(3,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d1"),
+		 MPP_FUNCTION(3, "spi0",    "cs0n")),
+	MPP_MODE(4,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d2"),
+		 MPP_FUNCTION(3, "i2c0",    "sda")),
+	MPP_MODE(5,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d3"),
+		 MPP_FUNCTION(3, "i2c0",    "sdk")),
+	MPP_MODE(6,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "ds")),
+	MPP_MODE(7,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d4"),
+		 MPP_FUNCTION(3, "uart1",   "rxd")),
+	MPP_MODE(8,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d5"),
+		 MPP_FUNCTION(3, "uart1",   "txd")),
+	MPP_MODE(9,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d6"),
+		 MPP_FUNCTION(3, "spi0",    "cs1n")),
+	MPP_MODE(10,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "d7")),
+	MPP_MODE(11,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(3, "uart0",   "txd")),
+	MPP_MODE(12,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(1, "sdio",    "pw_off"),
+		 MPP_FUNCTION(2, "sdio",    "hw_rst")),
+	MPP_MODE(13,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(14,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(15,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(16,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(17,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(18,
+		 MPP_FUNCTION(0, "gpio",    NULL)),
+	MPP_MODE(19,
+		 MPP_FUNCTION(0, "gpio",    NULL),
+		 MPP_FUNCTION(3, "uart0",   "rxd"),
+		 MPP_FUNCTION(4, "sdio",    "pw_off")),
+};
+
+static struct mvebu_pinctrl_soc_info armada_ap806_pinctrl_info;
+
+static const struct of_device_id armada_ap806_pinctrl_of_match[] = {
+	{
+		.compatible = "marvell,ap806-pinctrl",
+	},
+	{ },
+};
+
+static struct mvebu_mpp_ctrl armada_ap806_mpp_controls[] = {
+	MPP_FUNC_CTRL(0, 19, NULL, armada_ap806_mpp_ctrl),
+};
+
+static struct pinctrl_gpio_range armada_ap806_mpp_gpio_ranges[] = {
+	MPP_GPIO_RANGE(0,   0,  0, 20),
+};
+
+static int armada_ap806_pinctrl_probe(struct platform_device *pdev)
+{
+	struct mvebu_pinctrl_soc_info *soc = &armada_ap806_pinctrl_info;
+	const struct of_device_id *match =
+		of_match_device(armada_ap806_pinctrl_of_match, &pdev->dev);
+	struct resource *res;
+
+	if (!match)
+		return -ENODEV;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mpp_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(mpp_base))
+		return PTR_ERR(mpp_base);
+
+	soc->variant = 0; /* no variants for Armada AP806 */
+	soc->controls = armada_ap806_mpp_controls;
+	soc->ncontrols = ARRAY_SIZE(armada_ap806_mpp_controls);
+	soc->gpioranges = armada_ap806_mpp_gpio_ranges;
+	soc->ngpioranges = ARRAY_SIZE(armada_ap806_mpp_gpio_ranges);
+	soc->modes = armada_ap806_mpp_modes;
+	soc->nmodes = armada_ap806_mpp_controls[0].npins;
+
+	pdev->dev.platform_data = soc;
+
+	return mvebu_pinctrl_probe(pdev);
+}
+
+static int armada_ap806_pinctrl_remove(struct platform_device *pdev)
+{
+	return mvebu_pinctrl_remove(pdev);
+}
+
+static struct platform_driver armada_ap806_pinctrl_driver = {
+	.driver = {
+		.name = "armada-ap806-pinctrl",
+		.of_match_table = of_match_ptr(armada_ap806_pinctrl_of_match),
+	},
+	.probe = armada_ap806_pinctrl_probe,
+	.remove = armada_ap806_pinctrl_remove,
+};
+
+module_platform_driver(armada_ap806_pinctrl_driver);
+
+MODULE_AUTHOR("Thomas Petazzoni <thomas.petazzoni@free-electrons.com>");
+MODULE_DESCRIPTION("Marvell Armada ap806 pinctrl driver");
+MODULE_LICENSE("GPL v2");
-- 
1.9.1

