From a20bc83f8a290fccf5016d886f2365dec05fd48f Mon Sep 17 00:00:00 2001
From: Marcin Wojtas <mw@semihalf.com>
Date: Wed, 18 May 2016 15:06:35 +0200
Subject: [PATCH 420/538] PCI: advk: fix legacy interrupt handling

In legacy interrupt mode after clearing INTX assert bit, the EP's
handler is executed with generic_handle_irq() and deassert bit is
awaited to emerge and be cleared. Following the Functional Specification,
in case there is no deassert signal, EP's handler should be executed
again and condition re-checked. Normally there is a small gap between
these two events, which led to unnecessary generic_handle_irq() calling,
which was interpreted as spurious interrupts by Linux kernel.

It is enough to base on ASSERT bit signalling. From RC's point of view
polling on DEASSERT bit is redundant, especially because EP's interrupt
handler shouldn't be executed more than once within single chain
handling. If the flow is correct ASSERT -> handling -> DEASSERT, next
ASSERT hits regardless clearing DEASSERT bit RC in status registers.
This patch also removes unnecessary while loop in legacy interrupt
processing. All above results in great simplification of ADVK code.

Fix for SYSTEMSW-2444 "Armada 3700 spurious interrupts in PCIe legacy
interrupt mode"

Change-Id: Ie5e04e1d73eafa8334e338d61b376c8410bbf7e6
Signed-off-by: Marcin Wojtas <mw@semihalf.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/29899
Reviewed-by: Victor Gu <xigu@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
---
 drivers/irqchip/irq-mvebu-advk.c | 39 +++++++++++----------------------------
 1 file changed, 11 insertions(+), 28 deletions(-)

diff --git a/drivers/irqchip/irq-mvebu-advk.c b/drivers/irqchip/irq-mvebu-advk.c
index 1b0b373..8231530 100644
--- a/drivers/irqchip/irq-mvebu-advk.c
+++ b/drivers/irqchip/irq-mvebu-advk.c
@@ -68,14 +68,9 @@
 	ADVK_PCIE_INTR_INTA_ASSERT |		\
 	ADVK_PCIE_INTR_INTB_ASSERT |		\
 	ADVK_PCIE_INTR_INTC_ASSERT |		\
-	ADVK_PCIE_INTR_INTD_ASSERT |		\
-	ADVK_PCIE_INTR_INTA_DEASSERT |		\
-	ADVK_PCIE_INTR_INTB_DEASSERT |		\
-	ADVK_PCIE_INTR_INTC_DEASSERT |		\
-	ADVK_PCIE_INTR_INTD_DEASSERT)
+	ADVK_PCIE_INTR_INTD_ASSERT)
 
 #define ADVK_PCIE_INTR_INTX_ASSERT(val)			(1 << (15 + (val)))
-#define ADVK_PCIE_INTR_INTX_DEASSERT(val)		(1 << (19 + (val)))
 
 #define ADVK_PCIE_INTR_ISR0_ALL (		\
 	ADVK_PCIE_INTR_FLR_INT |		\
@@ -323,8 +318,7 @@ static void armada_3700_advk_irq_mask(struct irq_data *d)
 	u32 mask;
 
 	mask = readl(core_base + ADVK_PCIE_CORE_ISR0_MASK_REG);
-	mask |= ADVK_PCIE_INTR_INTX_ASSERT(hwirq) |
-		ADVK_PCIE_INTR_INTX_DEASSERT(hwirq);
+	mask |= ADVK_PCIE_INTR_INTX_ASSERT(hwirq);
 	writel(mask, core_base + ADVK_PCIE_CORE_ISR0_MASK_REG);
 }
 
@@ -334,8 +328,7 @@ static void armada_3700_advk_irq_unmask(struct irq_data *d)
 	u32 mask;
 
 	mask = readl(core_base + ADVK_PCIE_CORE_ISR0_MASK_REG);
-	mask = ~(ADVK_PCIE_INTR_INTX_ASSERT(hwirq) |
-		 ADVK_PCIE_INTR_INTX_DEASSERT(hwirq));
+	mask = ~(ADVK_PCIE_INTR_INTX_ASSERT(hwirq));
 	writel(mask, core_base + ADVK_PCIE_CORE_ISR0_MASK_REG);
 }
 
@@ -406,24 +399,14 @@ static void armada_3700_advk_isr0_handler(void)
 		armada_3700_advk_msi_handler();
 
 	/* Process legacy interrupts */
-	do {
-		for (i = 1; i <= ADVK_LEGACY_IRQ_NUM; i++) {
-			if (!(status & ADVK_PCIE_INTR_INTX_ASSERT(i)))
-				continue;
-
-			do {
-				writel(ADVK_PCIE_INTR_INTX_ASSERT(i),
-				       core_base + ADVK_PCIE_CORE_ISR0_STATUS_REG);
-				generic_handle_irq(irq_find_mapping(armada_3700_advk_domain, i));
-				status = readl(core_base + ADVK_PCIE_CORE_ISR0_STATUS_REG);
-			} while (!(status & ADVK_PCIE_INTR_INTX_DEASSERT(i)));
-
-			writel(ADVK_PCIE_INTR_INTX_DEASSERT(i),
-			       core_base + ADVK_PCIE_CORE_ISR0_STATUS_REG);
-		}
-
-		status = readl(core_base + ADVK_PCIE_CORE_ISR0_STATUS_REG);
-	} while (status & ADVK_PCIE_CORE_ISR0_INTX_MASK);
+	for (i = 1; i <= ADVK_LEGACY_IRQ_NUM; i++) {
+		if (!(status & ADVK_PCIE_INTR_INTX_ASSERT(i)))
+			continue;
+
+		writel(ADVK_PCIE_INTR_INTX_ASSERT(i),
+		       core_base + ADVK_PCIE_CORE_ISR0_STATUS_REG);
+		generic_handle_irq(irq_find_mapping(armada_3700_advk_domain, i));
+	}
 }
 
 static void armada_3700_advk_handle_cascade_irq(struct irq_desc *desc)
-- 
1.9.1

