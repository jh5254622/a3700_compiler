From 7b8c492c416ed775a588f5a15f7fbe764f0107f0 Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Tue, 24 May 2016 12:25:58 +0300
Subject: [PATCH 452/538] pp3: tai clock sync detection and status

	Extend sw sync:
	- bootup sync with stabilization delay
	- check the TAI-HW locked, if no - restart the sync
	- sysfs: tai_clock - show TAI clock status

Change-Id: Ie04bba5073e10f246257fd20215e28b52320d515
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/29915
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Lior Amsalem <alior@marvell.com>
---
 .../net/ethernet/marvell/pp3/gop/mv_gop_sysfs.c    | 126 ++++++++++++---------
 drivers/net/ethernet/marvell/pp3/gop/mv_ptp_if.c   |  23 +++-
 drivers/net/ethernet/marvell/pp3/gop/mv_ptp_if.h   |   4 +-
 .../net/ethernet/marvell/pp3/gop/mv_tai_clock.c    | 110 ++++++++++++++++--
 4 files changed, 195 insertions(+), 68 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/gop/mv_gop_sysfs.c b/drivers/net/ethernet/marvell/pp3/gop/mv_gop_sysfs.c
index 0667f56..3a61208 100644
--- a/drivers/net/ethernet/marvell/pp3/gop/mv_gop_sysfs.c
+++ b/drivers/net/ethernet/marvell/pp3/gop/mv_gop_sysfs.c
@@ -43,29 +43,40 @@ static ssize_t mv_gop_help(char *b)
 {
 	int o = 0;
 
-	o += scnprintf(b+o, PAGE_SIZE-o, "\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "cd                     ptp         - go to PTP and TAI units configuration sub directory\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [p]             > status      - show GOP port configuration\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [p]             > regs        - show GOP port registers\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [lane]          > xpcs_regs   - show XPCS lane registers\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [lane]          > serdes_regs - show Serdes lane registers\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [p]             > mib_cntrs   - show port MIB counters\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [p]             > clear_cntrs - clear port MIB counters\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [u] [v]         > reg_write   - write register: address [u], value [v]\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [u]             > reg_read    - read register: address [u]\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [u] [s:e] [v]   > reg_modify  - read, modify, write gop register\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "\n");
+	o += scnprintf(b + o, PAGE_SIZE - o,
+		"cd                     ptp         - go to PTP and TAI units configuration sub directory\n");
+	o += scnprintf(b + o, PAGE_SIZE - o,
+		"echo [p]             > status      - show GOP port configuration\n");
+	o += scnprintf(b + o, PAGE_SIZE - o,
+		"echo [p]             > regs        - show GOP port registers\n");
+	o += scnprintf(b + o, PAGE_SIZE - o,
+		"echo [lane]          > xpcs_regs   - show XPCS lane registers\n");
+	o += scnprintf(b + o, PAGE_SIZE - o,
+		"echo [lane]          > serdes_regs - show Serdes lane registers\n");
+	o += scnprintf(b + o, PAGE_SIZE - o,
+		"echo [p]             > mib_cntrs   - show port MIB counters\n");
+	o += scnprintf(b + o, PAGE_SIZE - o,
+		"echo [p]             > clear_cntrs - clear port MIB counters\n");
+	o += scnprintf(b + o, PAGE_SIZE - o,
+		"echo [u] [v]         > reg_write   - write register: address [u], value [v]\n");
+	o += scnprintf(b + o, PAGE_SIZE - o,
+		"echo [u]             > reg_read    - read register: address [u]\n");
+	o += scnprintf(b + o, PAGE_SIZE - o,
+		"echo [u] [s:e] [v]   > reg_modify  - read, modify, write gop register\n");
 #ifdef CONFIG_ARCH_MVEBU
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [p] [mode]      > port_mode   - change mode of lanes 6,5 connected to port [p]\n");
+	o += scnprintf(b + o, PAGE_SIZE - o,
+		"echo [p] [mode]      > port_mode   - change mode of lanes 6,5 connected to port [p]\n");
 #endif
-	o += scnprintf(b+o, PAGE_SIZE-o, "\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "parameters:\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "      [p]	- mac number\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "parameters:\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "      [p]	- mac number\n");
 #ifdef CONFIG_ARCH_MVEBU
-	o += scnprintf(b+o, PAGE_SIZE-o, "      [mode]	- rxaui:    switch to RXAUI\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "		- sgmii:    switch to SGMII\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "		- sgmii2_5: switch to SGMII 2.5\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "      [mode]	- rxaui:    switch to RXAUI\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "		- sgmii:    switch to SGMII\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "		- sgmii2_5: switch to SGMII 2.5\n");
 #endif
-	o += scnprintf(b+o, PAGE_SIZE-o, "\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "\n");
 
 	return o;
 }
@@ -73,42 +84,43 @@ static ssize_t mv_gop_help(char *b)
 static ssize_t mv_gop_ptp_help(char *b)
 {
 	int o = 0;
-	/* NOTE: the sysfs-show limited with PAGE_SIZE. Current help-size is about 1.28kB */
-	o += scnprintf(b+o, PAGE_SIZE-o, "\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "cat              tai_regs  - show TAI unit registers\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "cat              tai_tod   - show TAI time capture values\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [p]       > ptp_regs  - show PTP unit registers\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [p] [0/1] > ptp_en    - enable(1) / disable(0) PTP unit\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [p]       > ptp_reset - reset given port PTP unit\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     [p] - mac (port) number\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "----\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [h] [l] [n] > tai_tod_load_value  - set TAI TOD with DECimal\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "         [h] hig16bit sec, [l] low32bit sec, [n] - nanosec\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "\n");
-
-	o += scnprintf(b+o, PAGE_SIZE-o, "--- TAI TOD operationS (HEX parameters)---\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "echo [o] [h] [l] [n] > tai_op\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "         [h] high sec, [l] low sec, [n] nanosec (HEX)\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     [o] OPeration (HEX all parameters)\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "   ToD time:      [h]=0 must be present\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     1c -increment[l+n], 1c0 -graceful inc[l+n]\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     dc -decrement[l+n], 1d0 -graceful dec[l+n]\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "   FREQ:\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     F1c / Fdc - inc/dec by value [h]\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "   SYNC ToD time from/to linux or Sys/kernel:\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     41 - from linux, 21 - to linux\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     45 - from Sys/kernel, 47,46 -print ToD and System time\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "   Tai-Clock cfg:\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     CE1 - Clock External Increment [h] seconds\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     CED - Clock External Decrement [h] seconds\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     CEA - Clock External Absolute set [h] seconds\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     CEC - Clock External Check stability & counter\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     C1  - Clock Internal (free-running)\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     C0  - Clock Off\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     CEB11 - Blink led on gpio=11\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "   DEBUG:\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "     deb h l n  - DEBug-op with up to 3 parameters\n");
-	o += scnprintf(b+o, PAGE_SIZE-o, "\n");
+	/* NOTE: the sysfs-show limited with PAGE_SIZE. Current help-size is about 1.3kB */
+	o += scnprintf(b + o, PAGE_SIZE - o, "\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "cat              tai_regs  - show TAI unit registers\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "cat              tai_tod   - show TAI time capture values\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "cat              tai_clock - show TAI clock status\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo [p]       > ptp_regs  - show PTP unit registers\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo [p] [0/1] > ptp_en    - enable(1) / disable(0) PTP unit\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo [p]       > ptp_reset - reset given port PTP unit\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     [p] - mac (port) number\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "----\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo [h] [l] [n] > tai_tod_load_value  - set TAI TOD with DECimal\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "         [h] hig16bit sec, [l] low32bit sec, [n] - nanosec\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "\n");
+
+	o += scnprintf(b + o, PAGE_SIZE - o, "--- TAI TOD operationS (HEX parameters)---\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "echo [o] [h] [l] [n] > tai_op\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "         [h] high sec, [l] low sec, [n] nanosec (HEX)\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     [o] OPeration (HEX all parameters)\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "   ToD time:      [h]=0 must be present\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     1c -increment[l+n], 1c0 -graceful inc[l+n]\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     dc -decrement[l+n], 1d0 -graceful dec[l+n]\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "   FREQ:\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     F1c / Fdc - inc/dec by value [h]\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "   SYNC ToD time from/to linux or Sys/kernel:\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     41 - from linux, 21 - to linux\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     45 - from Sys/kernel, 47,46 -print ToD and System time\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "   Tai-Clock cfg:\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     CE1 - Clock External Increment [h] seconds\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     CED - Clock External Decrement [h] seconds\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     CEA - Clock External Absolute set [h] seconds\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     CEC - Clock External Check stability & counter\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     C1  - Clock Internal (free-running)\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     C0  - Clock Off\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     CEB11 - Blink led on gpio=11\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "   DEBUG:\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "     deb h l n  - DEBug-op with up to 3 parameters\n");
+	o += scnprintf(b + o, PAGE_SIZE - o, "\n");
 
 	return o;
 }
@@ -147,6 +159,8 @@ static ssize_t mv_gop_ptp_show(struct device *dev,
 		mv_pp3_tai_reg_dump();
 	else if (!strcmp(name, "tai_tod"))
 		mv_pp3_tai_tod_dump();
+	else if (!strcmp(name, "tai_clock"))
+		off = mv_pp3_tai_clock_status_get_sysfs(buf);
 	else {
 		off = 1;
 		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -339,6 +353,7 @@ static struct attribute *mv_gop_attrs[] = {
 
 static DEVICE_ATTR(help_ptp,		S_IRUSR, mv_gop_ptp_show, NULL);
 static DEVICE_ATTR(tai_regs,		S_IRUSR, mv_gop_ptp_show, NULL);
+static DEVICE_ATTR(tai_clock,		S_IRUSR, mv_gop_ptp_show, NULL);
 static DEVICE_ATTR(tai_tod,		S_IRUSR, mv_gop_ptp_show, NULL);
 static DEVICE_ATTR(tai_tod_load_value,	S_IWUSR, NULL, mv_gop_3_hex_store);
 static DEVICE_ATTR(tai_op,		S_IWUSR, NULL, mv_gop_3_hex_store);
@@ -349,6 +364,7 @@ static DEVICE_ATTR(ptp_reset,		S_IWUSR, NULL, mv_gop_3_hex_store);
 static struct attribute *mv_gop_ptp_attrs[] = {
 	&dev_attr_help_ptp.attr,
 	&dev_attr_tai_regs.attr,
+	&dev_attr_tai_clock.attr,
 	&dev_attr_tai_tod.attr,
 	&dev_attr_tai_tod_load_value.attr,
 	&dev_attr_tai_op.attr,
diff --git a/drivers/net/ethernet/marvell/pp3/gop/mv_ptp_if.c b/drivers/net/ethernet/marvell/pp3/gop/mv_ptp_if.c
index 6cebb173..0cd4016 100644
--- a/drivers/net/ethernet/marvell/pp3/gop/mv_ptp_if.c
+++ b/drivers/net/ethernet/marvell/pp3/gop/mv_ptp_if.c
@@ -53,6 +53,8 @@ static u32 ptp_tai_clock_in_cntr;
 static bool ptp_tai_clock_enabled;
 static bool ptp_tai_clock_external_cfg;
 
+static DEFINE_MUTEX(ptp_op_mutex);
+static DEFINE_MUTEX(ptp_clock_in_cntr_mutex);
 
 /************************************************************************/
 /*********    HW-level utilities     ************************************/
@@ -97,11 +99,21 @@ u16 mv_pp3_tai_clock_in_cntr_get(u32 *accumulated)
 	/* The HW 1PPS-in-Counter is reset upon reading
 	 * If some contexts are using this the "accumulated" is prefered
 	 */
-	u32 regv = mv_pp3_ptp_reg_read(MV_TAI_INCOMING_CLOCKIN_CNTING_CFG_LOW_REG);
+	u32 regv;
+	int mutex_req;
+
+	mutex_req = !in_interrupt();
+	if (mutex_req)
+		mutex_lock(&ptp_clock_in_cntr_mutex);
+
+	regv = mv_pp3_ptp_reg_read(MV_TAI_INCOMING_CLOCKIN_CNTING_CFG_LOW_REG);
 	regv &= MV_TAI_INCOMING_CLOCKIN_CNTING_CFG_LOW_CLOCK_CNTR_BITS_0_15_MASK;
 	ptp_tai_clock_in_cntr += regv;
 	if (accumulated)
 		*accumulated = ptp_tai_clock_in_cntr;
+
+	if (mutex_req)
+		mutex_unlock(&ptp_clock_in_cntr_mutex);
 	return (u16)regv;
 }
 
@@ -304,7 +316,7 @@ int mv_pp3_tai_tod_op(enum mv_pp3_tai_ptp_op op, struct mv_pp3_tai_tod *ts,
 			int synced_op)
 {
 	u32 ctrl, ctrl_new, status;
-	int rc = 0;
+	int rc = 0, mutex_req;
 	bool keep_last_op = (bool)synced_op;
 	u32 trigger_bit = synced_op ? 0 : 1;
 
@@ -321,7 +333,9 @@ int mv_pp3_tai_tod_op(enum mv_pp3_tai_ptp_op op, struct mv_pp3_tai_tod *ts,
 		}
 	}
 
-	/* mutex_lock - if needed, place here*/
+	mutex_req = !in_interrupt();
+	if (mutex_req)
+		mutex_lock(&ptp_op_mutex);
 
 	if (unlikely(op == MV_TAI_NOP)) {
 		ctrl = mv_pp3_ptp_reg_read(MV_TAI_TIME_CNTR_FUNC_CFG_0_REG);
@@ -357,6 +371,7 @@ exit:
 	if ((!keep_last_op) && (ctrl_new != ctrl)) /* restore original */
 		mv_pp3_ptp_reg_write(MV_TAI_TIME_CNTR_FUNC_CFG_0_REG, ctrl);
 
-	/* mutex_unlock - if needed, place here*/
+	if (mutex_req)
+		mutex_unlock(&ptp_op_mutex);
 	return rc;
 }
diff --git a/drivers/net/ethernet/marvell/pp3/gop/mv_ptp_if.h b/drivers/net/ethernet/marvell/pp3/gop/mv_ptp_if.h
index 1f5cd7d..88b4251 100644
--- a/drivers/net/ethernet/marvell/pp3/gop/mv_ptp_if.h
+++ b/drivers/net/ethernet/marvell/pp3/gop/mv_ptp_if.h
@@ -37,6 +37,8 @@ bool mv_pp3_tai_clock_stable_status_get(void);
 u16 mv_pp3_tai_clock_in_cntr_get(u32 *accumulated);
 int mv_pp3_ptp_event_led_sysfs(unsigned led_gpio);
 
+ssize_t mv_pp3_tai_clock_status_get_sysfs(char *buf);
+
 int mv_pp3_ptp_enable(int port, bool state);
 void mv_pp3_ptp_reset(int port);
 void mv_pp3_ptp_reset_all_ptp_ports(void);
@@ -45,7 +47,7 @@ int mv_pp3_tai_tod_op(enum mv_pp3_tai_ptp_op op, struct mv_pp3_tai_tod *ts,
 			int synced_op);
 int mv_pp3_tai_tod_op_read_captured(struct mv_pp3_tai_tod *ts, u32 *status);
 
-void mv_pp3_tai_clock_from_external_sync(u32 start, u32 sec, int d_sec);
+void mv_pp3_tai_clock_from_external_sync(int start, u32 sec, int d_sec);
 
 void mv_pp3_ptp_reg_dump(int port);
 void mv_pp3_tai_tod_dump_util(struct mv_pp3_tai_tod *ts);
diff --git a/drivers/net/ethernet/marvell/pp3/gop/mv_tai_clock.c b/drivers/net/ethernet/marvell/pp3/gop/mv_tai_clock.c
index 80f5d58..cf5e290 100644
--- a/drivers/net/ethernet/marvell/pp3/gop/mv_tai_clock.c
+++ b/drivers/net/ethernet/marvell/pp3/gop/mv_tai_clock.c
@@ -73,9 +73,13 @@ struct mv_ptp_event {
 
 	enum mv_ptp_event_clock_state state;
 	int state_cntr;
+	int clock_restart_req;
+	int sync_check_polling_limit;
+
 	bool gps_up_already_printed;
 	struct work_struct work_q;
 	struct timer_list timer;
+	int gps_watchdog_expired;
 
 	u32 sec;   /* Absolute set seconds to TAI/ToD */
 	int d_sec; /* Relative Inc/Dec delta to TAI/ToD */
@@ -132,6 +136,25 @@ static inline void ptp_event_led_blink(struct mv_ptp_event *ev, int req)
 }
 
 /***************************************************************************/
+/* ptp_is_sync_bad: checks sync between input GPS-1PPS and TAI-output 1PPS
+ *         retuns 0 if sync is ok,
+ *         retuns 1 if sync is bad and re-sync procedure to be initiated
+ * The detection is done on nano-sec difference between IRQ and TAI-counter
+ * so it should be called as soon as possible - best is in IRQ, but
+ * MV_TAI_GET_CAPTURE has latency more than 1.5uS
+ */
+static inline int ptp_is_sync_bad(void)
+{
+	struct mv_pp3_tai_tod ts;
+	/* ~999985000..999999999 - is under HW-sync
+	 * Range 0..500000000 is "ready for HW sync"
+	 */
+	mv_pp3_tai_tod_op(MV_TAI_GET_CAPTURE, &ts, 0);
+	 /* for precise IRQ context: 500000000 < nsec < 999985000 */
+	return (ts.nsec > 500015000) && (ts.nsec < 999985000);
+}
+
+/***************************************************************************/
 static irqreturn_t ptp_gpio_isr(int irq, void *data)
 {
 	struct mv_ptp_event *ev = data;
@@ -144,9 +167,7 @@ static irqreturn_t ptp_gpio_isr(int irq, void *data)
 		mod_timer(&ev->timer, MSEC_1PPS_D(-MSEC_BEFORE_1PPS));
 		break;
 	case PTP_CLK_GPS_UP:
-		/* Restart GPS-Up watchdog  */
-		mod_timer(&ev->timer, MSEC_1PPS_D(30));
-		ptp_event_led_blink(ev, -1); /*toggle*/
+		schedule_work(&ev->work_q);
 		break;
 	case PTP_CLK_GPS_DOWN:
 		/* GPS Up-and-Down timer */
@@ -204,7 +225,13 @@ static void ptp_tai_tod_set_synchronous(u32 sec, int d_sec)
 
 	if (!sec && !d_sec)
 		sec = 1;
-	clock_restart = (d_sec <= 0) || (d_sec > 2);
+
+	if (mv_ptp_event.clock_restart_req) {
+		mv_ptp_event.clock_restart_req = 0;
+		clock_restart = 1;
+	} else {
+		clock_restart = (d_sec <= 0) || (d_sec > 2);
+	}
 
 	if (sec && !d_sec) {
 		/* Absolute set required */
@@ -231,6 +258,7 @@ static void ptp_event_work_cb(struct work_struct *work)
 	enum mv_ptp_event_clock_state curr = ev->state;
 	struct mv_pp3_tai_tod ts;
 	u16 in_cntr_1pps;
+	int sync_bad;
 
 	switch (curr) {
 	case PTP_CLK_SYNC_START_TIMER:
@@ -280,6 +308,24 @@ static void ptp_event_work_cb(struct work_struct *work)
 		}
 		break;
 	case PTP_CLK_GPS_UP:
+		if (!ev->gps_watchdog_expired) {
+			/* per-second Heart-bit service:
+			 * sync-check, GPS-Up watchdog, led
+			 */
+			if (!ev->sync_check_polling_limit) {
+				sync_bad = 0;
+			} else {
+				sync_bad = ptp_is_sync_bad();
+				if (ev->sync_check_polling_limit > 0)
+					ev->sync_check_polling_limit--;
+			}
+			if (!sync_bad) {
+				mod_timer(&ev->timer, MSEC_1PPS_D(30));
+				ptp_event_led_blink(ev, -1); /*toggle*/
+				break;
+			}
+		}
+		ev->gps_watchdog_expired = 0;
 		ev->state = PTP_CLK_GPS_DOWN;
 		/* clock is free-running but stable */
 		pr_info("GPS 1PPS is Down\n");
@@ -323,7 +369,11 @@ static void ptp_event_timer_cb(unsigned long data)
 		break;
 
 	case PTP_CLK_SYNC_START_TIMER:
+		schedule_work(&ev->work_q);
+		break;
+
 	case PTP_CLK_GPS_UP:
+		ev->gps_watchdog_expired = 1;
 		schedule_work(&ev->work_q);
 		break;
 
@@ -382,11 +432,12 @@ static void ptp_event_monitor_stop(void) /* == deinit */
 		ev->gpio_irq_engaged = false;
 		ev->state = PTP_CLK_FREE_RUN;
 		ev->gps_up_already_printed = false;
+		ev->clock_restart_req = 1;
 	}
 }
 
 
-void mv_pp3_tai_clock_from_external_sync(u32 start, u32 sec, int d_sec)
+void mv_pp3_tai_clock_from_external_sync(int start, u32 sec, int d_sec)
 {
 	struct mv_ptp_event *ev = &mv_ptp_event;
 
@@ -396,6 +447,7 @@ void mv_pp3_tai_clock_from_external_sync(u32 start, u32 sec, int d_sec)
 		return;
 	}
 	if (start) {
+		ptp_event_monitor_start();
 		/* if both sec/d_sec == 0 - sync without set ToD requested
 		 * if both sec/d_sec == 1 - sync with keep current ToD
 		 */
@@ -403,8 +455,19 @@ void mv_pp3_tai_clock_from_external_sync(u32 start, u32 sec, int d_sec)
 			d_sec = 0;
 		ev->sec = sec;
 		ev->d_sec = d_sec;
-		ptp_event_monitor_start();
-		ev->state = PTP_CLK_SYNC_START;
+
+		if (start == 1) {
+			ev->state = PTP_CLK_SYNC_START; /* Starts at once */
+			ev->sync_check_polling_limit = 0;
+		} else {
+			/* Extended sync with stabilization delay
+			 * MV_PTP_GPS_DOWN2UP_PULSES and unlimited polling
+			 */
+			ev->state = PTP_CLK_GPS_DOWN;
+			ev->sync_check_polling_limit = -1;
+		}
+		ev->state_cntr = 0;
+
 		ptp_event_ptp_gpioirq(0, 1);
 	} else {
 		ptp_event_monitor_stop();
@@ -454,10 +517,41 @@ void mv_pp3_tai_clock_external_init2(bool from_external)
 		return;
 
 	if (from_external)
-		mv_pp3_tai_clock_from_external_sync(1, 1, 1);
+		mv_pp3_tai_clock_from_external_sync(2, 1, 1);
 }
 
 
+ssize_t mv_pp3_tai_clock_status_get_sysfs(char *buf)
+{
+	static const char * const status_str[] = {
+		"0:off",
+		"1:internal",
+		"2:sync_ok",
+		"3:sync_ok_checkpoll",
+		"4:sync_fail",
+	};
+	enum mv_ptp_event_clock_state ext_state = mv_ptp_event.state;
+	int sz, idx;
+	u32 clock_in_cntr;
+
+	if (!mv_pp3_tai_clock_enable_get()) {
+		idx = 0;
+	} else if (ext_state == PTP_CLK_FREE_RUN) {
+		idx = 1;
+	} else if (ext_state == PTP_CLK_GPS_UP) {
+		if (!mv_ptp_event.sync_check_polling_limit)
+			idx = 2;
+		else
+			idx = 3;
+	} else {
+		idx = 4;
+	}
+	mv_pp3_tai_clock_in_cntr_get(&clock_in_cntr);
+	sz  = scnprintf(buf, PAGE_SIZE, "%s, 1pps-in-cntr=%u\n",
+			status_str[idx], clock_in_cntr);
+	return sz;
+}
+
 /******************************************************************************
 * PTP-Event is a physical pulse obtained over MV_PTP_EVENT_MPP_DTB_STRING pin.
 *  Whilst the TAI-Clock-External is working it needs MPP function alternating
-- 
1.9.1

