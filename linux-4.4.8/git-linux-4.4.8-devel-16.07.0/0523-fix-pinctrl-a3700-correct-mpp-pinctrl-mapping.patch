From 5194044ea16b4bc6cb5ab3e4940e52d4fedde847 Mon Sep 17 00:00:00 2001
From: Ken Ma <make@marvell.com>
Date: Tue, 24 May 2016 10:14:47 +0800
Subject: [PATCH 523/538] fix: pinctrl: a3700: correct mpp pinctrl mapping

- Redefine mpp pins, now mppx is the real physical pin x
- Add the mapping of mpp pins' functions to mpp register bitmaps
- Update fdt files according to new mpp pins definition
- Update marvell,armada-3700-pinctrl.txt according to new mpp pins
  definition
- SYSTEMSW-2503: lack of GPIO mapping to pinctrl bit in A3700 pinctrl
  driver

Change-Id: I3ca156512e49596e21f3dedfd75f5b87ac0286c7
Signed-off-by: Ken Ma <make@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/29929
Reviewed-by: Victor Gu <xigu@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Wilson Ding <dingwei@marvell.com>
---
 .../pinctrl/marvell,armada-3700-pinctrl.txt        | 103 ++--
 arch/arm64/boot/dts/marvell/armada-3720-db.dts     |   2 +-
 arch/arm64/boot/dts/marvell/armada-37xx.dtsi       |  12 +-
 drivers/pinctrl/mvebu/pinctrl-armada-3700.c        | 547 +++++++++++++++++----
 4 files changed, 537 insertions(+), 127 deletions(-)

diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-3700-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-3700-pinctrl.txt
index d28cf1a..f833e38 100644
--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-3700-pinctrl.txt
+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-3700-pinctrl.txt
@@ -9,45 +9,80 @@ Required properties:
 
 Available mpp pins/groups and functions:
 Note: brackets (x) are not part of the mpp name for marvell,function and given
-only for more detailed description in this document.
+only for more detailed description in this document. Customer should make sure
+that there are no mpps configuration conflicts.
 
 North bridge: "marvell,armada-3700-nb-pinctrl"
 name          pins     functions
 ================================================================================
-mpp0          0        jtag, gpio
-mpp1          1        sdio, gpio
-mpp2          2        mmc, gpio
-mpp3          3        pwm0, gpio
-mpp4          4        pwm1, gpio
-mpp5          5        pwm2, gpio
-mpp6          6        pwm3, gpio
-mpp7          7        pmic1, gpio
-mpp8          8        pmic0, gpio
-mpp9          9        i2c2, gpio
-mpp10         10       i2c1, gpio
-mpp11         11       fcs0, gpio
-mpp12         12       fcs1, gpio
-mpp13         13       fcs2, gpio
-mpp14         14       fcs3, gpio
-mpp15         15       spi, gpio
-mpp16         16       1wire, gpio
-mpp17         17       uart1, gpio
-mpp18         18       spi(quad), gpio
-mpp19         19       spi(cs), uart2
-mpp20         20       led(led0), pulllow
-mpp21         21       led(led1), pulllow
-mpp22         22       led(led2), pulllow
-mpp23         23       led(led3), pulllow
+mpp0          0        i2c1(sck), gpio
+mpp1          1        i2c1(sda), gpio
+mpp2          2        i2c2(sck), gpio
+mpp3          3        i2c2(sda), gpio
+mpp4          4        1wire, gpio
+mpp5          5        gpio
+mpp6          6        pmic0(slp-out), gpio
+mpp7          7        pmic1(slp-out), gpio
+mpp8          8        sdio, gpio
+mpp9          9        sdio, gpio, uart2(rts)
+mpp10         10       sdio, gpio, uart2(cts)
+mpp11         11       pwm0, gpio, led0-od
+mpp12         12       pwm1, gpio, led1-od
+mpp13         13       pwm2, gpio, led2-od
+mpp14         14       pwm3, gpio, led3-od
+mpp15         15       spi-quad, gpio
+mpp16         16       spi-quad, gpio
+mpp17         17       spi-cs1, gpio
+mpp18         18       spi-cs2, gpio, uart2(tx)
+mpp19         19       spi-cs3, gpio, uart2(rx)
+mpp20         20       jtag, gpio
+mpp21         21       jtag, gpio
+mpp22         22       jtag, gpio
+mpp23         23       jtag, gpio
+mpp24         24       jtag, gpio
+mpp25         25       uart1, gpio
+mpp26         26       uart1, gpio
+mpp27         27       mmc, gpio
+mpp28         28       mmc, gpio
+mpp29         29       mmc, gpio
+mpp30         30       mmc, gpio
+mpp31         31       mmc, gpio
+mpp32         32       mmc, gpio
+mpp33         33       mmc, gpio
+mpp34         34       mmc, gpio
+mpp35         35       mmc, gpio
+mpp36         36       spi
 
 South bridge: "marvell,armada-3700-sb-pinctrl"
 name          pins     functions
 ================================================================================
-mpp0          0        usb32, gpio
-mpp1          1        usb2, gpio
-mpp2          2        sdio, gpio
-mpp3          3        mii, gpio
-mpp4          4        pcie1, gpio
-mpp5          5        ptp, gpio
-mpp6          6        ptp(clk), mii(txerr)
-mpp7          7        ptp(trig), mii(carriersense)
-mpp8          8        collision, mii(txerr)
\ No newline at end of file
+mpp0          0        usb32(drvvbus0), gpio
+mpp1          1        usb32(drvvbus1), gpio
+mpp2          2        gpio
+mpp3          3        pcie1(resetn), gpio
+mpp4          4        pcie1(clkreq), gpio
+mpp5          5        gpio
+mpp6          6        rgmii/mii/smi, gpio
+mpp7          7        rgmii/mii/smi, gpio
+mpp8          8        rgmii/mii/smi, gpio
+mpp9          9        rgmii/mii/smi, gpio
+mpp10         10       rgmii/mii/smi, gpio
+mpp11         11       rgmii/mii/smi, gpio
+mpp12         12       rgmii/mii/smi, gpio
+mpp13         13       rgmii/mii/smi, gpio
+mpp14         14       rgmii/mii/smi, gpio
+mpp15         15       rgmii/mii/smi, gpio
+mpp16         16       rgmii/mii/smi, gpio
+mpp17         17       rgmii/mii/smi, gpio
+mpp18         18       rgmii/mii/smi, gpio
+mpp19         19       rgmii/mii/smi, gpio
+mpp20         20       ptp/mii, gpio
+mpp21         21       ptp(clk-req), gpio, mii(tx-err)
+mpp22         22       ptp(trig-gen), gpio, mii(carrier-sense)
+mpp23         23       rgmii/mii/smi, gpio, mii(tx-err)
+mpp24         24       sdio(sd0-d2), gpio
+mpp25         25       sdio(sd0-d3), gpio
+mpp26         26       sdio(sd0-d1), gpio
+mpp27         27       sdio(sd0-d0), gpio
+mpp28         28       sdio(sd0-cmd), gpio
+mpp29         29       sdio(sd0-clk), gpio
diff --git a/arch/arm64/boot/dts/marvell/armada-3720-db.dts b/arch/arm64/boot/dts/marvell/armada-3720-db.dts
index 5252dbe..fde3fdd 100644
--- a/arch/arm64/boot/dts/marvell/armada-3720-db.dts
+++ b/arch/arm64/boot/dts/marvell/armada-3720-db.dts
@@ -74,7 +74,7 @@
 					spi-max-frequency = <104000000>;
 
 					pinctrl-names = "default";
-					pinctrl-0 = <&spi0_pins>;
+					pinctrl-0 = <&spi0_pins &spi_quad_pins>;
 
 					partition@0 {
 						label = "U-boot";
diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
index 7db34e3..f560582 100644
--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
@@ -157,12 +157,18 @@
 				reg = <0x13830 0x4>;
 
 				spi0_pins: spi-pins-0 {
-					marvell,pins = "mpp15", "mpp18";
+					marvell,pins = "mpp36";
 					marvell,function = "spi";
 				};
 
+				spi_quad_pins: spi-quad-pins {
+					marvell,pins = "mpp15", "mpp16";
+					marvell,function = "spi-quad";
+				};
+
 				mmc_pins: mmc-pins {
-					marvell,pins = "mpp2";
+					marvell,pins = "mpp27", "mpp28", "mpp29", "mpp30",
+							"mpp31", "mpp32", "mpp33", "mpp34", "mpp35";
 					marvell,function = "mmc";
 				};
 			};
@@ -178,7 +184,7 @@
 				reg = <0x18830 0x4>;
 
 				sdio_pins: sdio-pins {
-					marvell,pins = "mpp2";
+					marvell,pins = "mpp24", "mpp25", "mpp26", "mpp27", "mpp28", "mpp29";
 					marvell,function = "sdio";
 				};
 			};
diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-3700.c b/drivers/pinctrl/mvebu/pinctrl-armada-3700.c
index b75ad4d..211ba38 100644
--- a/drivers/pinctrl/mvebu/pinctrl-armada-3700.c
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-3700.c
@@ -15,17 +15,20 @@
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/platform_device.h>
 #include <linux/pinctrl/pinctrl.h>
-
 #include "pinctrl-mvebu.h"
 
-#define MVEBU_MPPS_PER_REG	32
-#define MVEBU_MPP_BITS		1
-#define MVEBU_MPP_MASK		0x1
+/*
+ * Armada3700 provides dual modes for most MPPs,
+ * either gpio or the specific function.
+ * But some MPPs can support up to 3 modes combined
+ * with selecting the significant bits in the MPP's
+ * register.
+ */
+#define ARMADA_3700_MPP_MAX_CONFIG_NUM	3
 
 enum armada_3700_bridge {
 	I_NORTHBRIDGE	= 0,
@@ -33,131 +36,514 @@ enum armada_3700_bridge {
 	I_MAXCONTROLLER,
 };
 
-static void __iomem *mpp_base[I_MAXCONTROLLER];/* north & south bridge mpp base*/
+struct  armada_3700_mpp_setting_bitmap {
+	/*
+	 * The mask is used for read/write MPP register bits of the function seletion.
+	 * For the mpps dedicated to gpio function which is not controlled by any MPP
+	 * register bits, the mask should be set to '0'.
+	 */
+	unsigned int mask;
+	unsigned int config_num;	/* mpp configuration modes number */
+	/*
+	 * This array maps the MPP's modes into the relevant MPP's register bits. It
+	 * is indexed by MPP's modes, which is defined in armada_3700_nb/sb_mpp_modes.
+	 */
+	unsigned int configs[ARMADA_3700_MPP_MAX_CONFIG_NUM];
+};
 
-static int armada_3700_nb_mpp_ctrl_get(unsigned pid, unsigned long *config)
-{
-	return default_mpp_ctrl_get(mpp_base[I_NORTHBRIDGE], pid, config);
-}
+static void __iomem *mpp_base[I_MAXCONTROLLER];/* north & south bridge mpp base */
 
-static int armada_3700_nb_mpp_ctrl_set(unsigned pid, unsigned long config)
+static int armada_3700_mpp_ctrl_get(unsigned pid,
+				    struct armada_3700_mpp_setting_bitmap mpp_setting_bitmap[],
+				    void __iomem *mpp_base_addr,
+				    unsigned long *config)
 {
-	return default_mpp_ctrl_set(mpp_base[I_NORTHBRIDGE], pid, config);
-}
+	unsigned int setting_num;
+	unsigned int reg, mask, i;
 
-static int armada_3700_sb_mpp_ctrl_get(unsigned pid, unsigned long *config)
-{
-	return default_mpp_ctrl_get(mpp_base[I_SOUTHBRIDGE], pid, config);
+	setting_num = mpp_setting_bitmap[pid].config_num;
+	mask = mpp_setting_bitmap[pid].mask;
+	if (!mask) {
+		/* The empty mask means the pin has a dedicated function. */
+		*config = 0;
+		return 0;
+	}
+
+	reg = readl(mpp_base_addr) & mask;
+	for (i = 0; i < setting_num; i++)
+		if (reg == mpp_setting_bitmap[pid].configs[i])
+			break;
+
+	if (i == setting_num) {
+		pr_err("Unknown config for bridge pin %u, mpp reg value(0x%08x)!\n", pid, reg);
+		return -EFAULT;
+	}
+
+	*config = i;
+	pr_debug("%s %d pid %d config %lu mask 0x%x reg 0x%x\n", __func__, __LINE__, pid, *config, mask, reg);
+	return 0;
 }
 
-static int armada_3700_sb_mpp_ctrl_set(unsigned pid, unsigned long config)
+static int armada_3700_mpp_ctrl_set(unsigned pid,
+				    struct armada_3700_mpp_setting_bitmap mpp_setting_bitmap[],
+				    void __iomem *mpp_base_addr,
+				    unsigned long config)
 {
-	return default_mpp_ctrl_set(mpp_base[I_SOUTHBRIDGE], pid, config);
+	unsigned int setting_num;
+	unsigned int reg, mask, val;
+
+	/* check whether the config value is valid */
+	setting_num = mpp_setting_bitmap[pid].config_num;
+	if (config >= setting_num) {
+		pr_err("For bridge pin %u, invalid config %lu!\n", pid, config);
+		return -EINVAL;
+	}
+
+	mask = mpp_setting_bitmap[pid].mask;
+	if (!mask)
+		return 0;
+	val = mpp_setting_bitmap[pid].configs[config];
+	reg = readl(mpp_base_addr) & ~mask;
+	writel(reg | val, mpp_base_addr);
+
+	pr_debug("%s %d pid %d config %lu reg 0x%x\n", __func__, __LINE__, pid, config, reg | val);
+	return 0;
 }
 
+/* south bridge pin-ctl */
 static struct mvebu_mpp_mode armada_3700_nb_mpp_modes[] = {
 	MPP_MODE(0,
-	   MPP_FUNCTION(0x0, "jtag", NULL),
+	   MPP_FUNCTION(0x0, "i2c1", "sck"),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(1,
-	   MPP_FUNCTION(0x0, "sdio", NULL),
+	   MPP_FUNCTION(0x0, "i2c1", "sda"),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(2,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
+	   MPP_FUNCTION(0x0, "i2c2", "sck"),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(3,
-	   MPP_FUNCTION(0x0, "pwm0", NULL),
+	   MPP_FUNCTION(0x0, "i2c2", "sda"),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(4,
-	   MPP_FUNCTION(0x0, "pwm1", NULL),
+	   MPP_FUNCTION(0x0, "1wire", NULL),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(5,
-	   MPP_FUNCTION(0x0, "pwm2", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	   MPP_FUNCTION(0x0, "gpio", NULL)),
 	MPP_MODE(6,
-	   MPP_FUNCTION(0x0, "pwm3", NULL),
+	   MPP_FUNCTION(0x0, "pmic0", "slp-out"),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(7,
-	   MPP_FUNCTION(0x0, "pmic1", NULL),
+	   MPP_FUNCTION(0x0, "pmic1", "slp-out"),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(8,
-	   MPP_FUNCTION(0x0, "pmic0", NULL),
+	   MPP_FUNCTION(0x0, "sdio", NULL),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(9,
-	   MPP_FUNCTION(0x0, "i2c2", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	   MPP_FUNCTION(0x0, "sdio", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL),
+	   MPP_FUNCTION(0x2, "uart2", "rts")),
 	MPP_MODE(10,
-	   MPP_FUNCTION(0x0, "i2c1", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	   MPP_FUNCTION(0x0, "sdio", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL),
+	   MPP_FUNCTION(0x2, "uart2", "cts")),
 	MPP_MODE(11,
-	   MPP_FUNCTION(0x0, "fcs0", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	   MPP_FUNCTION(0x0, "pwm0", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL),
+	   MPP_FUNCTION(0x2, "led0-od", NULL)),
 	MPP_MODE(12,
-	   MPP_FUNCTION(0x0, "fcs1", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	   MPP_FUNCTION(0x0, "pwm1", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL),
+	   MPP_FUNCTION(0x2, "led1-od", NULL)),
 	MPP_MODE(13,
-	   MPP_FUNCTION(0x0, "fcs2", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	   MPP_FUNCTION(0x0, "pwm2", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL),
+	   MPP_FUNCTION(0x2, "led2-od", NULL)),
 	MPP_MODE(14,
-	   MPP_FUNCTION(0x0, "fcs3", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	   MPP_FUNCTION(0x0, "pwm3", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL),
+	   MPP_FUNCTION(0x2, "led3-od", NULL)),
 	MPP_MODE(15,
-	   MPP_FUNCTION(0x0, "spi", NULL),
+	   MPP_FUNCTION(0x0, "spi-quad", NULL),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(16,
-	   MPP_FUNCTION(0x0, "1wire", NULL),
+	   MPP_FUNCTION(0x0, "spi-quad", NULL),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(17,
-	   MPP_FUNCTION(0x0, "uart1", NULL),
+	   MPP_FUNCTION(0x0, "spi-cs1", NULL),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(18,
-	   MPP_FUNCTION(0x0, "spi", "quad"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	   MPP_FUNCTION(0x0, "spi-cs2", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL),
+	   MPP_FUNCTION(0x2, "uart2", "tx")),
 	MPP_MODE(19,
-	   MPP_FUNCTION(0x0, "spi", "cs"),
-	   MPP_FUNCTION(0x1, "uart2", NULL)),
+	   MPP_FUNCTION(0x0, "spi-cs3", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL),
+	   MPP_FUNCTION(0x2, "uart2", "rx")),
 	MPP_MODE(20,
-	   MPP_FUNCTION(0x0, "led", "led0"),
-	   MPP_FUNCTION(0x1, "pulllow", NULL)),
+	   MPP_FUNCTION(0x0, "jtag", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(21,
-	   MPP_FUNCTION(0x0, "led", "led1"),
-	   MPP_FUNCTION(0x1, "pulllow", NULL)),
+	   MPP_FUNCTION(0x0, "jtag", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(22,
-	   MPP_FUNCTION(0x0, "led", "led2"),
-	   MPP_FUNCTION(0x1, "pulllow", NULL)),
+	   MPP_FUNCTION(0x0, "jtag", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(23,
-	   MPP_FUNCTION(0x0, "led", "led3"),
-	   MPP_FUNCTION(0x1, "pulllow", NULL)),
+	   MPP_FUNCTION(0x0, "jtag", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(24,
+	   MPP_FUNCTION(0x0, "jtag", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(25,
+	   MPP_FUNCTION(0x0, "uart1", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(26,
+	   MPP_FUNCTION(0x0, "uart1", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(27,
+	   MPP_FUNCTION(0x0, "mmc", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(28,
+	   MPP_FUNCTION(0x0, "mmc", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(29,
+	   MPP_FUNCTION(0x0, "mmc", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(30,
+	   MPP_FUNCTION(0x0, "mmc", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(31,
+	   MPP_FUNCTION(0x0, "mmc", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(32,
+	   MPP_FUNCTION(0x0, "mmc", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(33,
+	   MPP_FUNCTION(0x0, "mmc", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(34,
+	   MPP_FUNCTION(0x0, "mmc", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(35,
+	   MPP_FUNCTION(0x0, "mmc", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	/*
+	 * The mpp36 is not a GPIO pin exposed to the user.
+	 * It is dedicated to spi function.
+	 */
+	MPP_MODE(36,
+	   MPP_FUNCTION(0x0, "spi", NULL)),
+};
+
+/* North bridge pins' configs setting bitmaps, this array idx is north bridge pin id. */
+static struct armada_3700_mpp_setting_bitmap armada_3700_nb_mpp_bitmap[] = {
+	/* mask			config_num	configs */
+	{BIT(10),		2,		{0, BIT(10)}			},	/* pin 0 */
+	{BIT(10),		2,		{0, BIT(10)}			},	/* pin 1 */
+	{BIT(9),		2,		{0, BIT(9)}			},	/* pin 2 */
+	{BIT(9),		2,		{0, BIT(9)}			},	/* pin 3 */
+	{BIT(16),		2,		{0, BIT(16)}			},	/* pin 4 */
+	{0,			1,		{0}				},	/* pin 5 */
+	{BIT(8),		2,		{0, BIT(8)}			},	/* pin 6 */
+	{BIT(7),		2,		{0, BIT(7)}			},	/* pin 7 */
+	{BIT(1),		2,		{0, BIT(1)}			},	/* pin 8 */
+	{BIT(1) | BIT(19),	3,		{0, BIT(1), BIT(1) | BIT(19)}	},	/* pin 9 */
+	{BIT(1) | BIT(19),	3,		{0, BIT(1), BIT(1) | BIT(19)}	},	/* pin 10 */
+	{BIT(3) | BIT(20),	3,		{0, BIT(3), BIT(3) | BIT(20)}	},	/* pin 11 */
+	{BIT(4) | BIT(21),	3,		{0, BIT(4), BIT(4) | BIT(21)}	},	/* pin 12 */
+	{BIT(5) | BIT(22),	3,		{0, BIT(5), BIT(5) | BIT(22)}	},	/* pin 13 */
+	{BIT(6) | BIT(23),	3,		{0, BIT(6), BIT(6) | BIT(23)}	},	/* pin 14 */
+	{BIT(18),		2,		{0, BIT(18)}			},	/* pin 15 */
+	{BIT(18),		2,		{0, BIT(18)}			},	/* pin 16 */
+	{BIT(12),		2,		{0, BIT(12)}			},	/* pin 17 */
+	{BIT(13) | BIT(19),	3,		{0, BIT(13), BIT(19)}		},	/* pin 18 */
+	{BIT(14) | BIT(19),	3,		{0, BIT(14), BIT(19)}		},	/* pin 19 */
+	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 20 */
+	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 21 */
+	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 22 */
+	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 23 */
+	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 24 */
+	{BIT(17),		2,		{0, BIT(17)}			},	/* pin 25 */
+	{BIT(17),		2,		{0, BIT(17)}			},	/* pin 26 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 27 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 28 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 29 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 30 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 31 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 32 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 33 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 34 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 35 */
+	{BIT(15),		1,		{0}				},	/* pin 36 */
+};
+
+static int armada_3700_nb_mpp_ctrl_get(unsigned pid, unsigned long *config)
+{
+	int rc;
+
+	if (pid > ARRAY_SIZE(armada_3700_nb_mpp_modes)) {
+		pr_err("North bridge pin id %u is out of range!\n", pid);
+		return -EINVAL;
+	}
+
+	rc = armada_3700_mpp_ctrl_get(pid, armada_3700_nb_mpp_bitmap, mpp_base[I_NORTHBRIDGE], config);
+	if (rc) {
+		pr_err("Failed to get north bridge pin %d's config!\n", pid);
+		return rc;
+	}
+
+	pr_debug("%s %d pid %d config %lu\n", __func__, __LINE__, pid, *config);
+	return 0;
+}
+
+static int armada_3700_nb_mpp_ctrl_set(unsigned pid, unsigned long config)
+{
+	int rc;
+
+	if (pid > ARRAY_SIZE(armada_3700_nb_mpp_modes)) {
+		pr_err("North bridge Pin id %u is out of range!\n", pid);
+		return -EINVAL;
+	}
+
+	rc = armada_3700_mpp_ctrl_set(pid, armada_3700_nb_mpp_bitmap, mpp_base[I_NORTHBRIDGE], config);
+	if (rc) {
+		pr_err("Failed to set config %lu for north bridge pin %d!\n", config, pid);
+		return rc;
+	}
+
+	pr_debug("%s %d pid %d config %lu\n", __func__, __LINE__, pid, config);
+	return 0;
+}
+
+static struct mvebu_mpp_ctrl armada_3700_nb_mpp_controls[] = {
+	MPP_FUNC_CTRL(0, 36, NULL, armada_3700_nb_mpp_ctrl),
 };
 
+/* The mpp36 is not a GPIO pin exposed to the user, excluded from the GPIO range. */
+static struct pinctrl_gpio_range armada_3700_nb_mpp_gpio_ranges[] = {
+	MPP_GPIO_RANGE(0, 0, 0, 36),
+};
+
+/* south bridge pin-ctl */
 static struct mvebu_mpp_mode armada_3700_sb_mpp_modes[] = {
 	MPP_MODE(0,
-	   MPP_FUNCTION(0x0, "usb32", NULL),
+	   MPP_FUNCTION(0x0, "usb32", "drvvbus0"),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(1,
-	   MPP_FUNCTION(0x0, "usb2", NULL),
+	   MPP_FUNCTION(0x0, "usb2", "drvvbus1"),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(2,
-	   MPP_FUNCTION(0x0, "sdio", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	   MPP_FUNCTION(0x0, "gpio", NULL)),
 	MPP_MODE(3,
-	   MPP_FUNCTION(0x0, "mii", NULL),
+	   MPP_FUNCTION(0x0, "pcie1", "resetn"),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(4,
-	   MPP_FUNCTION(0x0, "pcie1", NULL),
+	   MPP_FUNCTION(0x0, "pcie1", "clkreq"),
 	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(5,
-	   MPP_FUNCTION(0x0, "ptp", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	   MPP_FUNCTION(0x0, "gpio", NULL)),
 	MPP_MODE(6,
-	   MPP_FUNCTION(0x0, "ptp", "clk"),
-	   MPP_FUNCTION(0x1, "mii", "txerr")),
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(7,
-	   MPP_FUNCTION(0x0, "ptp", "trig"),
-	   MPP_FUNCTION(0x1, "mii", "carriersense")),
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
 	MPP_MODE(8,
-	   MPP_FUNCTION(0x0, "collision", NULL),
-	   MPP_FUNCTION(0x1, "mii", "txerr")),
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(9,
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(10,
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(11,
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(12,
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(13,
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(14,
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(15,
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(16,
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(17,
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(18,
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(19,
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(20,
+	   MPP_FUNCTION(0x0, "ptp/mii", NULL),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(21,
+	   MPP_FUNCTION(0x0, "ptp", "clk-req"),
+	   MPP_FUNCTION(0x1, "gpio", NULL),
+	   MPP_FUNCTION(0x2, "mii", "tx-err")),
+	MPP_MODE(22,
+	   MPP_FUNCTION(0x0, "ptp", "trig-gen"),
+	   MPP_FUNCTION(0x1, "gpio", NULL),
+	   MPP_FUNCTION(0x2, "mii", "carrier-sense")),
+	MPP_MODE(23,
+	   MPP_FUNCTION(0x0, "rgmii/mii/smi", "mii-collision"),
+	   MPP_FUNCTION(0x1, "gpio", NULL),
+	   MPP_FUNCTION(0x2, "mii", "tx-err")),
+	MPP_MODE(24,
+	   MPP_FUNCTION(0x0, "sdio", "sd0-d2"),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(25,
+	   MPP_FUNCTION(0x0, "sdio", "sd0-d3"),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(26,
+	   MPP_FUNCTION(0x0, "sdio", "sd0-d1"),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(27,
+	   MPP_FUNCTION(0x0, "sdio", "sd0-d0"),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(28,
+	   MPP_FUNCTION(0x0, "sdio", "sd0-cmd"),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+	MPP_MODE(29,
+	   MPP_FUNCTION(0x0, "sdio", "sd0-clk"),
+	   MPP_FUNCTION(0x1, "gpio", NULL)),
+};
+
+/* south bridge pins' configs setting bitmaps, this array idx is south bridge pin id */
+static struct armada_3700_mpp_setting_bitmap armada_3700_sb_mpp_bitmap[] = {
+	/*mask			config_num	configs*/
+	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 0 */
+	{BIT(1),		2,		{0, BIT(1)}			},	/* pin 1 */
+	{0,			1,		{0}				},	/* pin 2 */
+	{BIT(4),		2,		{0, BIT(4)}			},	/* pin 3 */
+	{BIT(4),		2,		{0, BIT(4)}			},	/* pin 4 */
+	{0,			1,		{0}				},	/* pin 5 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 6 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 7 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 8 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 9 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 10 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 11 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 12 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 13 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 14 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 15 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 16 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 17 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 18 */
+	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 19 */
+	{BIT(5),		2,		{0, BIT(5)}			},	/* pin 20 */
+	{BIT(5) | BIT(6),	3,		{0, BIT(5), BIT(6)}		},	/* pin 21 */
+	{BIT(5) | BIT(7),	3,		{0, BIT(5), BIT(7)}		},	/* pin 22 */
+	{BIT(3) | BIT(8),	3,		{0, BIT(3), BIT(8)}		},	/* pin 23 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 24 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 25 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 26 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 27 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 28 */
+	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 29 */
+};
+
+static int armada_3700_sb_mpp_ctrl_get(unsigned pid, unsigned long *config)
+{
+	int rc;
+
+	if (pid > ARRAY_SIZE(armada_3700_sb_mpp_modes)) {
+		pr_err("South bridge pin id %u is out of range!\n", pid);
+		return -EINVAL;
+	}
+
+	rc = armada_3700_mpp_ctrl_get(pid, armada_3700_sb_mpp_bitmap, mpp_base[I_SOUTHBRIDGE], config);
+	if (rc) {
+		pr_err("Failed to get south bridge pin %d's config!\n", pid);
+		return rc;
+	}
+
+	pr_debug("%s %d pid %d config %lu\n", __func__, __LINE__, pid, *config);
+	return 0;
+}
+
+static int armada_3700_sb_mpp_ctrl_set(unsigned pid, unsigned long config)
+{
+	int rc;
+
+	if (pid > ARRAY_SIZE(armada_3700_sb_mpp_modes)) {
+		pr_err("South bridge Pin id %u is out of range!\n", pid);
+		return -EINVAL;
+	}
+
+	rc = armada_3700_mpp_ctrl_set(pid, armada_3700_sb_mpp_bitmap, mpp_base[I_SOUTHBRIDGE], config);
+	if (rc) {
+		pr_err("Failed to set config %lu for south bridge pin %d!\n", config, pid);
+		return rc;
+	}
+
+	pr_debug("%s %d pid %d config %lu\n", __func__, __LINE__, pid, config);
+	return 0;
+}
+
+static unsigned int armada_3700_mpp_consistency_check(unsigned index)
+{
+	unsigned int i, bitmap_array_size, modes_array_size;
+	struct mvebu_mpp_mode *mpp_mode;
+	struct armada_3700_mpp_setting_bitmap *bit_map;
+	struct mvebu_mpp_ctrl_setting *set;
+
+	switch (index) {
+	case I_NORTHBRIDGE:
+		bitmap_array_size = ARRAY_SIZE(armada_3700_nb_mpp_bitmap);
+		modes_array_size = ARRAY_SIZE(armada_3700_nb_mpp_modes);
+		mpp_mode = armada_3700_nb_mpp_modes;
+		bit_map = armada_3700_nb_mpp_bitmap;
+		break;
+	case I_SOUTHBRIDGE:
+		bitmap_array_size = ARRAY_SIZE(armada_3700_sb_mpp_bitmap);
+		modes_array_size = ARRAY_SIZE(armada_3700_sb_mpp_modes);
+		mpp_mode = armada_3700_sb_mpp_modes;
+		bit_map = armada_3700_sb_mpp_bitmap;
+		break;
+	default:
+		return -EFAULT;
+	}
+
+	if (bitmap_array_size != modes_array_size) {
+		pr_err("The sizes of bitmap and modes arrays are not same for bank %d!\n", index);
+		return -EFAULT;
+	}
+
+	for (i = 0; i < bitmap_array_size; i++) {
+		unsigned int setting_num = 0;
+
+		/* get mpp pin i's setting number */
+		for (set = mpp_mode[i].settings; set->name != NULL; set++)
+			setting_num++;
+
+		if (bit_map[i].config_num != setting_num) {
+			pr_err("bank %d pid %d's config num are not same in bitmap and modes arrays!\n", index, i);
+			return -EFAULT;
+		}
+	}
+
+	return 0;
+}
+
+static struct mvebu_mpp_ctrl armada_3700_sb_mpp_controls[] = {
+	MPP_FUNC_CTRL(0, 29, NULL, armada_3700_sb_mpp_ctrl),
+};
+
+/* south bridge gpio starts from global gpio id 36 */
+static struct pinctrl_gpio_range armada_3700_sb_mpp_gpio_ranges[] = {
+	MPP_GPIO_RANGE(0, 0, 36, 30),
 };
 
 static struct mvebu_pinctrl_soc_info armada_3700_pinctrl_info[I_MAXCONTROLLER];
@@ -174,23 +560,6 @@ static const struct of_device_id armada_3700_pinctrl_of_match[] = {
 	{ },
 };
 
-static struct mvebu_mpp_ctrl armada_3700_nb_mpp_controls[] = {
-	MPP_FUNC_CTRL(0, 23, NULL, armada_3700_nb_mpp_ctrl),
-};
-
-static struct mvebu_mpp_ctrl armada_3700_sb_mpp_controls[] = {
-	MPP_FUNC_CTRL(0, 8, NULL, armada_3700_sb_mpp_ctrl),
-};
-
-static struct pinctrl_gpio_range armada_3700_nb_mpp_gpio_ranges[] = {
-	MPP_GPIO_RANGE(0,   0,  0, 24),
-};
-
-static struct pinctrl_gpio_range armada_3700_sb_mpp_gpio_ranges[] = {
-	MPP_GPIO_RANGE(0,   0,  0, 9),
-};
-
-
 static int armada_3700_pinctrl_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *match =
@@ -208,8 +577,8 @@ static int armada_3700_pinctrl_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	/* armada3700 need to set mpps_per_reg */
-	mvebu_pinctrl_set_mpps(MVEBU_MPPS_PER_REG);
+	if (armada_3700_mpp_consistency_check(index) != 0)
+		return -EFAULT;
 
 	soc = &armada_3700_pinctrl_info[index];
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-- 
1.9.1

