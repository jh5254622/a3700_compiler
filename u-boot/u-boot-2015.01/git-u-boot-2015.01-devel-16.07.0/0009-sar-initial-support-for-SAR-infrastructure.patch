From c1b4c1b01c7b984631d812c41f895400cbb424c6 Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Mon, 10 Feb 2014 16:28:31 +0200
Subject: [PATCH 0009/1240] sar: initial support for SAR infrastructure

Change-Id: I90b3d9074d148c030603d402af28c9d2729297af
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
---
 board/mvebu/armada8021-pxp/Makefile       |  20 +-
 board/mvebu/armada8021-pxp/board-info.c   |  30 +++
 board/mvebu/armada8021-pxp/board-info.h   |   1 +
 board/mvebu/armada8021-pxp/db-8210-info.c |   7 +
 board/mvebu/common/Makefile               |  21 +-
 board/mvebu/common/board-common.c         |  18 ++
 board/mvebu/common/board.h                |  17 +-
 board/mvebu/common/sar.c                  | 379 ++++++++++++++++++++++++++++++
 board/mvebu/common/sar.h                  |  67 ++++++
 board/mvebu/common/var.h                  |  44 ++++
 common/mvebu/Makefile                     |   1 +
 common/mvebu/cmd_sar.c                    |  94 ++++++++
 include/configs/armada8021-pxp.h          |   4 +-
 13 files changed, 690 insertions(+), 13 deletions(-)
 create mode 100644 board/mvebu/common/sar.c
 create mode 100644 board/mvebu/common/sar.h
 create mode 100644 board/mvebu/common/var.h
 create mode 100644 common/mvebu/cmd_sar.c

diff --git a/board/mvebu/armada8021-pxp/Makefile b/board/mvebu/armada8021-pxp/Makefile
index 0e3c374..2610972 100644
--- a/board/mvebu/armada8021-pxp/Makefile
+++ b/board/mvebu/armada8021-pxp/Makefile
@@ -1,11 +1,23 @@
 #
-# (C) Copyright 2000-2004
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+# *****************************************************************************
+#  Copyright (C) Marvell International Ltd. and its affiliates
+# *****************************************************************************
+# Marvell GPL License Option
+# If you received this File from Marvell, you may opt to use, redistribute
+# and/or modify this File in accordance with the terms and conditions of the
+# General Public License Version 2, June 1991 (the "GPL License"), a copy of
+# which is available along with the File in the license.txt file or by writing
+# to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 #
-# SPDX-License-Identifier:	GPL-2.0+
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+# EXPRESSLY DISCLAIMED.  The GPL License provides additional details about this
+# warranty disclaimer.
+# *****************************************************************************
 #
 
-obj-y	:= armada8021-pxp.o
+obj-y	+= armada8021-pxp.o
 obj-y	+= board-info.o
 obj-y	+= db-8210-info.o
 obj-y	+= rd-8210-info.o
diff --git a/board/mvebu/armada8021-pxp/board-info.c b/board/mvebu/armada8021-pxp/board-info.c
index 24d9b25..2e6e5bf 100644
--- a/board/mvebu/armada8021-pxp/board-info.c
+++ b/board/mvebu/armada8021-pxp/board-info.c
@@ -22,6 +22,35 @@
 #include <asm/arch-mvebu/unit-info.h>
 #include "board-info.h"
 
+#define SATR_EEPROM0_ADDR	0x22
+
+/* Define all SAR variables available for SOC */
+/* Assuming their location is equal on all boards */
+struct sar_var a8k_sar_lookup[MAX_SAR] = {
+	[CPUS_NUM_SAR] = {0, 2, 3,
+		{{0x0, "Single CPU", 0},
+		 {0x2, "Dual CPU", 0},
+		 {0x3, "Quad CPU", VAR_IS_DEFUALT} },
+	},
+	[FREQ_SAR] = {2, 5, 2,
+		{{0x0, "800 / 400 / 400"},
+		 {0x5, "1200 / 600 / 600"} },
+	},
+	[BOOT_SRC_SAR] = {7, 2, 3,
+		{{0x0, "NAND boot", 0},
+		 {0x2, "SPI boot", VAR_IS_DEFUALT},
+		 {0x3, "NOR boot", 0} },
+	}
+};
+
+/* Define general SAR information */
+struct sar_data a8k_sar = {
+	.chip_addr    = {0x4c, 0x4d, 0x4e, 0x4f},
+	.chip_count   = 4,
+	.bit_width    = 5,
+	.sar_lookup   = a8k_sar_lookup
+};
+
 struct mvebu_board_info *a8k_board_lookup[MAX_BOARD_ID] = {
 	[ARMADA_8021_DB_ID] = &a8021_db_info,
 	[ARMADA_8021_RD_ID] = &a8021_rd_info
@@ -31,5 +60,6 @@ struct mvebu_board_family a8k_board_family = {
 	.default_id = ARMADA_8021_DB_ID,
 	.board_cnt = MAX_BOARD_ID,
 	.boards_info = a8k_board_lookup,
+	.sar = &a8k_sar,
 };
 
diff --git a/board/mvebu/armada8021-pxp/board-info.h b/board/mvebu/armada8021-pxp/board-info.h
index 1ce914a..58ca3e2 100644
--- a/board/mvebu/armada8021-pxp/board-info.h
+++ b/board/mvebu/armada8021-pxp/board-info.h
@@ -21,6 +21,7 @@
 #define _BOARD_INFO_H_
 
 #include "../common/board.h"
+#include "../common/sar.h"
 
 enum a8k_board_types {
 	ARMADA_8021_DB_ID,
diff --git a/board/mvebu/armada8021-pxp/db-8210-info.c b/board/mvebu/armada8021-pxp/db-8210-info.c
index 807115d..ab6aec0 100644
--- a/board/mvebu/armada8021-pxp/db-8210-info.c
+++ b/board/mvebu/armada8021-pxp/db-8210-info.c
@@ -22,8 +22,15 @@
 #include <asm/arch-mvebu/unit-info.h>
 #include "board-info.h"
 
+struct mvebu_board_config a8021_db_config = {
+	.sar_cnt = 2,
+	.supported_sar = {BOOT_SRC_SAR, CPUS_NUM_SAR},
+};
+
 struct mvebu_board_info a8021_db_info = {
 	.name = "DB-MV8021",
 	.id = ARMADA_8021_DB_ID,
+	.configurable = 1,
+	.config_data = &a8021_db_config,
 };
 
diff --git a/board/mvebu/common/Makefile b/board/mvebu/common/Makefile
index 65b2ebd..1d7d6f3 100644
--- a/board/mvebu/common/Makefile
+++ b/board/mvebu/common/Makefile
@@ -1,8 +1,21 @@
 #
-# (C) Copyright 2000-2004
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+# *****************************************************************************
+#  Copyright (C) Marvell International Ltd. and its affiliates
+# *****************************************************************************
+# Marvell GPL License Option
+# If you received this File from Marvell, you may opt to use, redistribute
+# and/or modify this File in accordance with the terms and conditions of the
+# General Public License Version 2, June 1991 (the "GPL License"), a copy of
+# which is available along with the File in the license.txt file or by writing
+# to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 #
-# SPDX-License-Identifier:	GPL-2.0+
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+# EXPRESSLY DISCLAIMED.  The GPL License provides additional details about this
+# warranty disclaimer.
+# *****************************************************************************
 #
 
-obj-y	:= board-common.o
+obj-y	+= board-common.o
+obj-y	+= sar.o
diff --git a/board/mvebu/common/board-common.c b/board/mvebu/common/board-common.c
index 5ee55f9..b6d8d48 100644
--- a/board/mvebu/common/board-common.c
+++ b/board/mvebu/common/board-common.c
@@ -60,11 +60,29 @@ int common_board_init(struct mvebu_board_family *board_family)
 
 	printf("Board: %s\n", curr_board->name);
 
+	/* Update active units list for board */
 	if (curr_board->unit_mask)
 		update_unit_info(unit_mask, curr_board->unit_mask,
 				 curr_board->unit_update_mode);
 
+	/* Update sar tables */
+	if (curr_board->configurable) {
+		if (curr_board->config_data->sar_override)
+			/* update_sar_table();*/
+	}
+
 	return 0;
 }
 
+struct sar_data *board_get_sar(void)
+{
+	return brd->sar;
+}
 
+struct sar_var *board_get_sar_table(void)
+{
+	if (brd->sar)
+		return brd->sar->sar_lookup;
+	else
+		return NULL;
+}
diff --git a/board/mvebu/common/board.h b/board/mvebu/common/board.h
index 3e3b461..f1e8db5 100644
--- a/board/mvebu/common/board.h
+++ b/board/mvebu/common/board.h
@@ -24,15 +24,21 @@
 #include <asm/arch-mvebu/mvebu.h>
 #include <asm/arch-mvebu/unit-info.h>
 #include <linux/compiler.h>
+#include "sar.h"
 
-#define MAX_BOARD_NAME	16
+#define MAX_BOARD_NAME		16
 
 /*
  * mvebu_board_config  - Describes board configuration features
  *
+ * sar_cnt - number of suported SAR options
+ * supported_sar - array of supported SAR variables
+ * sar_override - table that overrides the default sar table
  */
 struct mvebu_board_config {
-	int x;
+	int sar_cnt;
+	enum sar_variables supported_sar[MAX_SAR];
+	struct sar_var *sar_override;
 };
 
 
@@ -56,7 +62,8 @@ struct mvebu_board_info {
 	u32  id;
 	u16  *unit_mask;
 	enum unit_update_mode unit_update_mode;
-	struct mvebu_board_config *config;
+	bool configurable;
+	struct mvebu_board_config *config_data;
 };
 
 /*
@@ -66,6 +73,7 @@ struct mvebu_board_info {
  * board_cnt - number of different boards
  * curr_board - pointer to current board's info
  * boards_info - pointer to table containing
+ * sar - General SAR information for all boards (optional)
  *
  */
 struct mvebu_board_family {
@@ -73,9 +81,12 @@ struct mvebu_board_family {
 	int  board_cnt;
 	struct mvebu_board_info *curr_board;
 	struct mvebu_board_info **boards_info;
+	struct sar_data *sar;
 };
 
 
 int common_board_init(struct mvebu_board_family *board_family);
+struct sar_data *board_get_sar(void);
+struct sar_var  *board_get_sar_table(void);
 
 #endif /* _BOARD_H_ */
diff --git a/board/mvebu/common/sar.c b/board/mvebu/common/sar.c
new file mode 100644
index 0000000..d402fa0
--- /dev/null
+++ b/board/mvebu/common/sar.c
@@ -0,0 +1,379 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) Marvell International Ltd. and its affiliates
+ * ***************************************************************************
+ * Marvell GPL License Option
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of the
+ * General Public License Version 2, June 1991 (the "GPL License"), a copy of
+ * which is available along with the File in the license.txt file or by writing
+ * to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+ * EXPRESSLY DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * ***************************************************************************
+ */
+
+#define DEBUG
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/bitops.h>
+#include <linux/compiler.h>
+#include "board.h"
+#include "sar.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct var_desc sar_desc_table[MAX_SAR] = {
+	[CPUS_NUM_SAR] =	{ "cpusnum", "Number of active CPUs"},
+	[CPU0_ENDIANES_SAR] =	{ "cpuend", "CPU endianes mode"},
+	[FREQ_SAR] =		{ "freq", "SOC frequency configiuration (CPU/ Fabric/ DDR)"},
+	[CPU_FREQ_SAR] =	{ "cpufreq", "CPU Frequency"},
+	[FAB_REQ_SAR] =		{ "fabfreq", "Fabric (L2) frequency"},
+	[BOOT_SRC_SAR] =	{ "bootsrc", "Boot device source"},
+	[BOOT_WIDTH_SAR] =	{ "bootwidth", "Width of boot device read"},
+	[PEX_MODE_SAR] =	{ "pexmode", "Pex configuration"},
+	[L2_SIZE_SAR] =		{ "l2size", "Size of L2 cache"},
+	[DRAM_ECC_SAR] =	{ "dramecc", "Enables DRAM ECC"},
+	[DRAM_BUS_WIDTH_SAR] =	{ "dramwidth", "DRAM bus width"}
+};
+
+#define I2C_DUMMY_BASE ((int)0x91000000)
+
+/* I2C interface commands */
+static int i2c_write_dummy(uchar chip, uint addr, int alen, uchar *buffer, int len)
+{
+	uintptr_t reg = (uintptr_t)(I2C_DUMMY_BASE) + addr;
+	writeb(*buffer, reg);
+	return 0;
+}
+
+static int i2c_read_dummy(uchar chip, uint addr, int alen, uchar *buffer, int len)
+{
+	uintptr_t reg = (uintptr_t)(I2C_DUMMY_BASE) + addr;
+	(*buffer) = (uchar)readb(reg);
+	return 0;
+}
+
+static int sar_read_reg(u32 *reg)
+{
+	uchar byte = 0;
+	int ret, chip;
+	u32 sar_reg = 0;
+	struct sar_data *sar = board_get_sar();
+	int reg_width = sar->bit_width;
+	u8  reg_mask = (1 << reg_width) - 1;
+
+	for (chip = 0; chip  < sar->chip_count; chip++) {
+		/*ret = i2c_read(var->chip_addr, var->reg_offset, 1, &byte, 1);*/
+		ret = i2c_read_dummy(sar->chip_addr[chip], 0, 1, &byte, 1);
+		if (ret) {
+			printf("Error: %s: Failed reading from chip 0x%x\n",
+			       __func__, sar->chip_addr[chip]);
+			return -1;
+		}
+		sar_reg |= (byte & reg_mask) << (chip * reg_width);
+	}
+	debug("read: sar register = 0x%08x\n", sar_reg);
+	*reg = sar_reg;
+
+	return 0;
+}
+
+int sar_write_reg(u32 sar_reg)
+{
+	uchar byte = 0;
+	int ret, chip;
+	struct sar_data *sar = board_get_sar();
+	int reg_width = sar->bit_width;
+	u8  reg_mask = (1 << reg_width) - 1;
+
+	for (chip = 0; chip  < sar->chip_count; chip++) {
+		/*ret = i2c_write(uchar chip, uint addr, int alen, uchar *buffer, int len)*/
+		byte = (sar_reg >> (chip * reg_width)) & reg_mask;
+		ret = i2c_write_dummy(sar->chip_addr[chip], 0, 1, &byte, 1);
+		if (ret) {
+			printf("Error: %s: Failed writing to chip 0x%x\n",
+			       __func__, sar->chip_addr[chip]);
+			return -1;
+		}
+	}
+	debug("write: sar register = 0x%08x\n", sar_reg);
+
+	return 0;
+}
+
+
+int sar_read_var(struct sar_var *var, int *val)
+{
+	u32 sar_reg;
+	u32 var_mask = (1 << var->bit_length) - 1;
+
+	if (sar_read_reg(&sar_reg))
+		return -1;
+
+	(*val) = (sar_reg >> var->start_bit) & var_mask;
+
+	debug("var offet = %d len = %d val = 0x%x\n", var->start_bit, var->bit_length, (*val));
+
+	return 0;
+}
+
+int sar_write_var(struct sar_var *var, int val)
+{
+	u32 sar_reg;
+	u32 var_mask = (1 << var->bit_length) - 1;
+
+	if (sar_read_reg(&sar_reg))
+		return -1;
+
+	/* Update the bitfield inside the sar register */
+	val &= var_mask;
+	sar_reg &= ~(var_mask << var->start_bit);
+	sar_reg |= (val << var->start_bit);
+
+	/* Write the full sar register back to i2c */
+	if (sar_write_reg(sar_reg))
+		return -1;
+
+	return 0;
+}
+
+static int sar_default_var(struct sar_var *var)
+{
+	struct var_opts *opts;
+	struct var_opts *dflt =	NULL;
+	int i;
+
+	opts = var->option_desc;
+	for (i = 0; i < var->option_cnt; i++, opts++) {
+		if (opts->flags & VAR_IS_DEFUALT)
+			dflt = opts;
+	}
+
+	if (dflt == NULL) {
+		printf("Error: Failed to find default option");
+		return 1;
+	}
+
+	if (sar_write_var(var, dflt->value)) {
+		printf("Error: Failed to write default value");
+		return 1;
+	}
+
+	debug("Wrote default value 0x%x = %s\n", dflt->value, dflt->desc);
+	return 0;
+}
+
+int sar_get_key_id(const char *key)
+{
+	int id;
+
+	for (id = 0; id < MAX_SAR; id++) {
+		if (strcmp(key, sar_desc_table[id].key) == 0)
+			return id;
+	}
+	return -1;
+}
+
+int sar_is_var_active(int id)
+{
+	struct sar_var *sar_table = board_get_sar_table();
+	return ((sar_table[id].option_cnt > 0) ? 1 : 0);
+}
+
+struct var_opts *sar_get_var_opts(int id, int *cnt)
+{
+	struct sar_var *sar_table = board_get_sar_table();
+
+	(*cnt) = sar_table[id].option_cnt;
+
+	return sar_table[id].option_desc;
+}
+
+int sar_validate_key(const char *key)
+{
+	int id = sar_get_key_id(key);
+
+	if (id  == -1) {
+		printf("Satr: Error: Unknown key \"%s\"\n", key);
+		return -1;
+	}
+	if (sar_is_var_active(id) == 0) {
+		printf("Satr: Error: Key \"%s\" is inactive on this board\n", key);
+		return -1;
+	}
+	return id;
+}
+
+struct sar_var *sar_id_to_var(int id)
+{
+	struct sar_var *sar_table = board_get_sar_table();
+	sar_table += id;
+	return sar_table;
+}
+
+
+/* Interface to SatR command */
+int sar_is_avaialble(void)
+{
+	if (board_get_sar_table() == NULL)
+		return 0;
+	else
+		return 1;
+}
+
+void sar_print_var(int id, bool print_opts)
+{
+	int cnt;
+	struct var_opts *opts;
+
+	printf("%-10s %s\n", sar_desc_table[id].key,
+	       sar_desc_table[id].description);
+
+	if (print_opts) {
+		opts = sar_get_var_opts(id, &cnt);
+		while (cnt--) {
+			printf("\t0x%-2x %s ", opts->value, opts->desc);
+			if (opts->flags & VAR_IS_DEFUALT)
+				printf("[Default]");
+			printf("\n");
+			opts++;
+		}
+	}
+}
+
+
+void sar_list_keys(void)
+{
+	int id;
+
+	printf("\n");
+	for (id = 0; id < MAX_SAR; id++) {
+		if (sar_is_var_active(id))
+			sar_print_var(id, 0);
+	}
+	printf("\n");
+}
+
+int sar_list_key_opts(const char *key)
+{
+	int id = sar_validate_key(key);
+
+	if (id == -1)
+		return -EINVAL;
+
+	printf("\n");
+	sar_print_var(id, 1);
+	printf("\n");
+
+	return 0;
+}
+
+
+int  sar_print_key(const char *key)
+{
+	int id = sar_validate_key(key);
+	struct sar_var *var;
+	struct var_opts *opts;
+	char *desc = NULL;
+	int val, ret, cnt;
+
+	if (id == -1)
+		return -EINVAL;
+
+	var = sar_id_to_var(id);
+	ret = sar_read_var(var, &val);
+	if (ret)
+		return ret;
+
+	opts = sar_get_var_opts(id, &cnt);
+	while (cnt--) {
+		if (opts->value == val)
+			desc = opts->desc;
+		opts++;
+	}
+
+	if (desc == NULL)
+		printf("%s = 0x%x  ERROR: UNKNOWN OPTION\n", key, val);
+	else
+		printf("%s = 0x%x  %s\n", key, val, desc);
+
+	return 0;
+}
+
+int  sar_write_key(const char *key, int val)
+{
+	int id = sar_validate_key(key);
+	struct sar_var *var;
+	struct var_opts *opts;
+	char *desc = NULL;
+	int cnt;
+
+	if (id == -1)
+		return -EINVAL;
+
+	var = sar_id_to_var(id);
+	opts = sar_get_var_opts(id, &cnt);
+	while (cnt--) {
+		if (opts->value == val)
+			desc = opts->desc;
+		opts++;
+	}
+
+	if (desc == NULL) {
+		printf("ERROR: value 0x%x not supported for key %s\n", val, key);
+		printf("use \"SatR list %s\" to print supported values\n", key);
+	}
+
+	if (sar_write_var(var, val))
+		return -1;
+
+	/* Display the updated variable */
+	sar_print_key(key);
+
+	return 0;
+}
+
+int sar_defualt_all(void)
+{
+	struct sar_var *var;
+	int id;
+	int ret = 0;
+
+	for (id = 0; id < MAX_SAR; id++) {
+		var = sar_id_to_var(id);
+		if (sar_is_var_active(id)) {
+			ret |= sar_default_var(var);
+			sar_print_key(sar_desc_table[id].key);
+		}
+	}
+
+	return ret;
+}
+
+int  sar_default_key(const char *key)
+{
+	int id = sar_validate_key(key);
+	struct sar_var *var;
+	int ret;
+
+	if (id == -1)
+		return -EINVAL;
+
+	var = sar_id_to_var(id);
+	ret = sar_default_var(var);
+	if (ret)
+		return ret;
+
+	/* Display the updated variable */
+	sar_print_key(key);
+
+	return 0;
+}
+
diff --git a/board/mvebu/common/sar.h b/board/mvebu/common/sar.h
new file mode 100644
index 0000000..286b669
--- /dev/null
+++ b/board/mvebu/common/sar.h
@@ -0,0 +1,67 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) Marvell International Ltd. and its affiliates
+ * ***************************************************************************
+ * Marvell GPL License Option
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of the
+ * General Public License Version 2, June 1991 (the "GPL License"), a copy of
+ * which is available along with the File in the license.txt file or by writing
+ * to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+ * EXPRESSLY DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * ***************************************************************************
+ */
+
+#ifndef _SAR_H_
+#define _SAR_H_
+
+#include <common.h>
+#include <asm/arch-mvebu/mvebu.h>
+#include <linux/compiler.h>
+#include "var.h"
+
+#define MAX_SAR_CHIPS	4
+
+struct sar_var {
+	u8 start_bit;
+	u8 bit_length;
+	u8 option_cnt;
+	struct var_opts option_desc[MAX_VAR_OPTIONS];
+};
+
+struct sar_data {
+	u32	chip_addr[MAX_SAR_CHIPS];
+	u8	chip_count;
+	u8	bit_width;
+	struct sar_var *sar_lookup;
+};
+
+enum sar_variables {
+	CPUS_NUM_SAR = 0,
+	CPU0_ENDIANES_SAR,
+	FREQ_SAR,
+	CPU_FREQ_SAR,
+	FAB_REQ_SAR,
+	BOOT_SRC_SAR,
+	BOOT_WIDTH_SAR,
+	PEX_MODE_SAR,
+	L2_SIZE_SAR,
+	DRAM_ECC_SAR,
+	DRAM_BUS_WIDTH_SAR,
+	MAX_SAR
+};
+
+int  sar_default_key(const char *key);
+int  sar_defualt_all(void);
+int  sar_write_key(const char *key, int val);
+int  sar_print_key(const char *key);
+void sar_list_keys(void);
+int  sar_list_key_opts(const char *key);
+int  sar_is_avaialble(void);
+
+#endif /* _SAR_H_ */
diff --git a/board/mvebu/common/var.h b/board/mvebu/common/var.h
new file mode 100644
index 0000000..82b94e3
--- /dev/null
+++ b/board/mvebu/common/var.h
@@ -0,0 +1,44 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) Marvell International Ltd. and its affiliates
+ * ***************************************************************************
+ * Marvell GPL License Option
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of the
+ * General Public License Version 2, June 1991 (the "GPL License"), a copy of
+ * which is available along with the File in the license.txt file or by writing
+ * to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+ * EXPRESSLY DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * ***************************************************************************
+ */
+
+#ifndef _VAR_H_
+#define _VAR_H_
+
+#include <common.h>
+#include <linux/compiler.h>
+
+#define INVALID_KEY	0xFF
+#define MAX_VAR_OPTIONS	10
+
+#define VAR_IS_DEFUALT	0x1
+#define VAR_IS_LAST	0x2
+
+struct var_opts {
+	u8 value;
+	char *desc;
+	u8 flags;
+};
+
+struct var_desc {
+	char *key;
+	char *description;
+};
+
+
+#endif /* _VAR_H_ */
diff --git a/common/mvebu/Makefile b/common/mvebu/Makefile
index 2aa43f5..42c68df 100644
--- a/common/mvebu/Makefile
+++ b/common/mvebu/Makefile
@@ -18,3 +18,4 @@
 #
 
 obj-y += cmd_misc.o
+obj-y += cmd_sar.o
diff --git a/common/mvebu/cmd_sar.c b/common/mvebu/cmd_sar.c
new file mode 100644
index 0000000..bb2f823
--- /dev/null
+++ b/common/mvebu/cmd_sar.c
@@ -0,0 +1,94 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) Marvell International Ltd. and its affiliates
+ * ***************************************************************************
+ * Marvell GPL License Option
+ * If you received this File from Marvell, you may opt to use, redistribute
+ * and/or modify this File in accordance with the terms and conditions of the
+ * General Public License Version 2, June 1991 (the "GPL License"), a copy of
+ * which is available along with the File in the license.txt file or by writing
+ * to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+ * EXPRESSLY DISCLAIMED. The GPL License provides additional details about this
+ * warranty disclaimer.
+ * ***************************************************************************
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <vsprintf.h>
+#include <errno.h>
+
+#include "../../board/mvebu/common/sar.h"
+
+int do_sar_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
+			char * const argv[])
+{
+	const char *cmd = argv[1];
+	const char *key = NULL;
+	int value = 0;
+
+	if (sar_is_avaialble() == 0) {
+		printf("Error: SAR variables not available for this board\n");
+		return 1;
+	}
+
+	if ((strcmp(cmd, "read") == 0) && (argc < 3)) {
+		printf("Error: Please specify SAR key\n");
+		return 1;
+	}
+
+	if ((strcmp(cmd, "write") == 0) && (argc < 4)) {
+		printf("Error: Please specify SAR key and value\n");
+		return 1;
+	}
+
+	if (argc > 2)
+		key = argv[2];
+	if (argc > 3)
+		value = (int)simple_strtoul(argv[3], NULL, 16);
+
+	if (strcmp(cmd, "list") == 0) {
+		if (argc < 3) {
+			sar_list_keys();
+		} else {
+			if (sar_list_key_opts(key))
+				return -EINVAL;
+		}
+	} else if (strcmp(cmd, "default") == 0) {
+		if (argc < 3) {
+			sar_defualt_all();
+		} else {
+			if (sar_default_key(key))
+				return -EINVAL;
+		}
+	} else if (strcmp(cmd, "read") == 0) {
+		if (sar_print_key(key))
+			return -EINVAL;
+	} else if (strcmp(cmd, "write") == 0) {
+		if (sar_write_key(key, value))
+			return -EINVAL;
+	} else {
+		printf("ERROR: unknown command to SatR: \"%s\"\n", cmd);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	SatR,      6,     1,      do_sar_cmd,
+	"SatR - Modify SOC's sample at reset (SAR) values\n",
+	"\n"
+	"Modify SOC's sample at reset values\n"
+	"\tlist		- Display all availble SAR variables\n"
+	"\tlist <x>	- Display options for SAR variable x\n"
+	"\tdefault	- Set all SAR variable to default value\n"
+	"\tdefault <x>	- Set SAR variable x default value\n"
+	"\twrite x y	- Write y to SAR variable x\n"
+	"\tread x	- Read SAR variable x\n"
+);
diff --git a/include/configs/armada8021-pxp.h b/include/configs/armada8021-pxp.h
index d09e994..2c0196b 100644
--- a/include/configs/armada8021-pxp.h
+++ b/include/configs/armada8021-pxp.h
@@ -120,8 +120,8 @@
 #define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128 * 1024)
 
 /* SMSC91C111 Ethernet Configuration */
-#define CONFIG_SMC91111			1
-#define CONFIG_SMC91111_BASE		(0x01A000000)
+/*#define CONFIG_SMC91111			1
+#define CONFIG_SMC91111_BASE		(0x01A000000)*/
 
 /* PL011 Serial Configuration */
 #define CONFIG_PL011_SERIAL
-- 
1.9.1

