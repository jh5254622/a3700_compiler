From 776f14a56d0f2b24d9325b640c3e26e6e27b909c Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Tue, 29 Jul 2014 19:52:31 +0300
Subject: [PATCH 0054/1240] a8k: ccu: updated the address decoding init
 function

	update the address decoding init function
	- added init function for CP winodws
	- added init function for RFU windows
	- update the target IDs (for CP and AP)
	- update the A8k Adec table

Change-Id: I818d217595363158e8a5b56f1748020e3a79113d
Signed-off-by: Hanna Hawa <hannah@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/9707
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
---
 arch/arm/cpu/armv8/armada8k/tables.c            |  11 +-
 arch/arm/cpu/mvebu-common/adec_ccu.c            | 186 +++++++++++++++++++-----
 arch/arm/include/asm/arch-armada8k/memory-map.h |  23 ++-
 arch/arm/include/asm/arch-armada8k/regs-base.h  |   4 +-
 arch/arm/include/asm/arch-mvebu/adec_ccu.h      | 104 +++++++++----
 5 files changed, 258 insertions(+), 70 deletions(-)

diff --git a/arch/arm/cpu/armv8/armada8k/tables.c b/arch/arm/cpu/armv8/armada8k/tables.c
index bb72e42..67f4f1a 100644
--- a/arch/arm/cpu/armv8/armada8k/tables.c
+++ b/arch/arm/cpu/armv8/armada8k/tables.c
@@ -25,10 +25,15 @@
 #include <asm/arch-mvebu/mpp.h>
 
 struct adec_win memory_map[] = {
-	{0x0,     0x40000000, DRAM_0_TID, 0},
-	{0x40000000, 0x20000000, IO_0_TID, 0},
+	{DRAM_0_TID,	DRAM_0_BASE_ADDR,	DRAM_0_SIZE,	ADEC_AP_WIN,	1},
+#ifndef CONFIG_PALLADIUM
+	{IO_0_TID,	IO_0_BASE_ADDR,		IO_0_SIZE,	ADEC_AP_WIN,	1},
+	{PEX0_TID,	PEX_BASE_ADDR(0),	PEX_SIZE(0),	ADEC_IOB_WIN,	1},
+	{PEX1_TID,	PEX_BASE_ADDR(1),	PEX_SIZE(1),	ADEC_IOB_WIN,	1},
+	{NSS_TID,	NSS_BASE_ADDR,		NSS_SIZE,	ADEC_IOB_WIN,	1},
+#endif
 	/* Delimiter */
-	{0x0, 0x0, INVALID_TID, 0}
+	{INVALID_TID,	0x0,			0x0,		0x0,		0},
 };
 
 /* List the maximum amount of units for all devices and boards */
diff --git a/arch/arm/cpu/mvebu-common/adec_ccu.c b/arch/arm/cpu/mvebu-common/adec_ccu.c
index 1eefa6e..93781d8 100644
--- a/arch/arm/cpu/mvebu-common/adec_ccu.c
+++ b/arch/arm/cpu/mvebu-common/adec_ccu.c
@@ -23,80 +23,194 @@
 #include <common.h>
 #include <asm/system.h>
 #include <asm/io.h>
-#include <asm/arch/regs-base.h>
+#include <asm/arch-mvebu/mvebu.h>
 #include <asm/arch-mvebu/adec.h>
 
-void __iomem *ap_adec_base;
+static void adec_win_check(struct adec_win *win, u32 win_num)
+{
+	/* check if address is aligned to the size */
+	if(IS_NOT_ALIGN(win->base_addr, win->win_size)) {
+		win->base_addr = ALIGN_UP(win->base_addr, win->win_size);
+		error("\n**********\nwindow number %d: base address is not aligned with the window size. "\
+				"Align up the base address to 0x%lx\n**********",\
+				win_num, win->base_addr);
+	}
+	/* size parameter validity check */
+	if(IS_NOT_ALIGN(win->win_size, CR_WIN_SIZE_ALIGNMENT)) {
+		win->win_size = ALIGN_UP(win->win_size, CR_WIN_SIZE_ALIGNMENT);
+		error("\n**********\nwindow number %d: window size is not aligned to 0x%x. "\
+				"Align up the size to 0x%lx\n**********",
+				win_num, CR_WIN_SIZE_ALIGNMENT, win->win_size);
+	}
+}
 
-static void adec_win_to_range(uintptr_t base_addr, uintptr_t win_size,
-			u32 *alr, u32 *ahr)
+static void adec_enable_rfu_win(struct adec_win *win, u32 win_id)
 {
-	uintptr_t end = (base_addr + win_size - 1);
+	u32 alr, ahr;
+	uintptr_t end_addr;
 
-	(*alr) = (u32)((base_addr >> ADDRESS_SHIFT) & ADDRESS_MASK);
-	(*ahr) = (u32)((end >> ADDRESS_SHIFT) & ADDRESS_MASK);
+	end_addr = (win->base_addr + win->win_size - 1);
+	alr = (u32)((win->base_addr >> ADDRESS_SHIFT) & ADDRESS_MASK);
+	alr |= WIN_ENABLE_BIT;
+	writel(alr, (unsigned long)RFU_WIN_ALR_OFFSET(win_id));
+
+	/* there's no ahr for bootrom window */
+	if (win_id == BOOTROM_RFU_WINDOW_NUM)
+		return ;
+
+	ahr = (u32)((end_addr >> ADDRESS_SHIFT) & ADDRESS_MASK);
+	writel(ahr, (unsigned long)RFU_WIN_AHR_OFFSET(win_id));
 }
 
-static void adec_enable_ap_win(struct adec_win *win, int win_id)
+static void adec_enable_iob_win(struct adec_win *win, u32 win_id)
 {
-	u32 ccu_win_cr;
+	u32 iob_win_reg;
 	u32 alr, ahr;
+	uintptr_t end_addr;
 
-	ccu_win_cr = WIN_ENABLE_BIT;
-	ccu_win_cr |= (win->target_id & TARGET_ID_MASK) << TARGET_ID_OFFSET;
-	ccu_win_cr |= (win->rar_enable & RAR_EN_MASK) << RAR_EN_OFFSET;
+	iob_win_reg = WIN_ENABLE_BIT;
+	iob_win_reg |= (win->target_id & IOB_TARGET_ID_MASK) << IOB_TARGET_ID_OFFSET;
+	writel(iob_win_reg, (unsigned long)IOB_WIN_CR_OFFSET(win_id));
 
-	writel(ccu_win_cr, ap_adec_base + CCU_WIN_CR_OFFSET(win_id));
+	end_addr = (win->base_addr + win->win_size - 1);
+	alr = (u32)((win->base_addr >> ADDRESS_SHIFT) & ADDRESS_MASK);
+	ahr = (u32)((end_addr >> ADDRESS_SHIFT) & ADDRESS_MASK);
 
-	adec_win_to_range(win->base_addr, win->win_size, &alr, &ahr);
+	writel(alr, (unsigned long)IOB_WIN_ALR_OFFSET(win_id));
+	writel(ahr, (unsigned long)IOB_WIN_AHR_OFFSET(win_id));
+}
 
-	writel(alr, ap_adec_base + CCU_WIN_ALR_OFFSET(win_id));
-	writel(ahr, ap_adec_base + CCU_WIN_AHR_OFFSET(win_id));
+static void adec_enable_ap_win(struct adec_win *win, u32 win_id)
+{
+	u32 ap_win_reg;
+	u32 alr, ahr;
+	uintptr_t end_addr;
+
+	ap_win_reg = WIN_ENABLE_BIT;
+	ap_win_reg |= (win->target_id & AP_TARGET_ID_MASK) << AP_TARGET_ID_OFFSET;
+	writel(ap_win_reg, (unsigned long)AP_WIN_CR_OFFSET(win_id));
+
+	end_addr = (win->base_addr + win->win_size - 1);
+	alr = (u32)((win->base_addr >> ADDRESS_SHIFT) & ADDRESS_MASK);
+	ahr = (u32)((end_addr >> ADDRESS_SHIFT) & ADDRESS_MASK);
+
+	writel(alr, (unsigned long)AP_WIN_ALR_OFFSET(win_id));
+	writel(ahr, (unsigned long)AP_WIN_AHR_OFFSET(win_id));
 }
 
 void adec_dump(void)
 {
-	int win_id;
-	u32 ccu_win_cr;
+	u32 win_id;
+	u32 win_cr;
 	u32 alr, ahr;
 	u8 target_id;
 	uintptr_t start, end;
 
+	/* Dump all AP windows */
 	printf("id target  start              end\n");
 	printf("----------------------------------------------\n");
-
-	/* Dump all AP windows */
 	for (win_id = 0; win_id < MAX_AP_WINDOWS; win_id++) {
-		ccu_win_cr = readl(ap_adec_base + CCU_WIN_CR_OFFSET(win_id));
-		if (ccu_win_cr & WIN_ENABLE_BIT) {
-			target_id = (ccu_win_cr >> TARGET_ID_OFFSET) & TARGET_ID_MASK;
-			alr = readl(ap_adec_base + CCU_WIN_ALR_OFFSET(win_id));
-			ahr = readl(ap_adec_base + CCU_WIN_AHR_OFFSET(win_id));
+		win_cr = readl((unsigned long)AP_WIN_CR_OFFSET(win_id));
+		if (win_cr & WIN_ENABLE_BIT) {
+			target_id = (win_cr >> AP_TARGET_ID_OFFSET) & AP_TARGET_ID_MASK;
+			alr = readl((unsigned long)AP_WIN_ALR_OFFSET(win_id));
+			ahr = readl((unsigned long)AP_WIN_AHR_OFFSET(win_id));
 			start = (uintptr_t)(alr << ADDRESS_SHIFT);
 			end = (uintptr_t)((ahr + 0x10) << ADDRESS_SHIFT);
 			printf("%02d %02d      0x%016lx 0x%016lx\n", win_id, target_id, start, end);
 		}
 	}
-
-	return;
+	/* Dump all RFU windows */
+	for (win_id = 0; win_id < MAX_RFU_WINDOWS; win_id++) {
+		alr = readl((unsigned long)RFU_WIN_ALR_OFFSET(win_id));
+		if (alr & WIN_ENABLE_BIT) {
+			alr = readl((unsigned long)RFU_WIN_ALR_OFFSET(win_id));
+			ahr = readl((unsigned long)RFU_WIN_AHR_OFFSET(win_id));
+			start = (uintptr_t)(alr << ADDRESS_SHIFT);
+			end = (uintptr_t)((ahr + 0x10) << ADDRESS_SHIFT);
+			printf("%02d         0x%016lx 0x%016lx\n", win_id, start, end);
+		}
+	}
+	/* Dump all IOB windows */
+	for (win_id = 0; win_id < MAX_IOB_WINDOWS; win_id++) {
+		win_cr = readl((unsigned long)IOB_WIN_CR_OFFSET(win_id));
+		if (win_cr & WIN_ENABLE_BIT) {
+			target_id = (win_cr >> IOB_TARGET_ID_OFFSET) & IOB_TARGET_ID_MASK;
+			alr = readl((unsigned long)IOB_WIN_ALR_OFFSET(win_id));
+			ahr = readl((unsigned long)IOB_WIN_AHR_OFFSET(win_id));
+			start = (uintptr_t)(alr << ADDRESS_SHIFT);
+			end = (uintptr_t)((ahr + 0x10) << ADDRESS_SHIFT);
+			printf("%02d %02d      0x%016lx 0x%016lx\n", win_id, target_id, start, end);
+		}
+	}
+	printf("\nnote: unmapped addresses will go to GCR\n");
+	return ;
 }
 
 int adec_init(struct adec_win *windows)
 {
-	int win_id;
+	u32 win_id;
+	u32 win_reg, target_id;
+
+	debug_enter();
+	debug("Initializing CCU Address decoding\n");
 
-	debug("Initializing CCU ADEC unit for AP\n");
-	ap_adec_base = (void *)MVEBU_ADEC_BASE;
+	/* disable all RFU windows */
+	for (win_id = 0; win_id < MAX_RFU_WINDOWS; win_id++) {
+		win_reg = readl((unsigned long)RFU_WIN_ALR_OFFSET(win_id));
+		win_reg &= ~WIN_ENABLE_BIT;
+		writel(win_reg, (unsigned long)RFU_WIN_ALR_OFFSET(win_id));
+	}
 
+	/* disable all AP windows */
 	for (win_id = 0; win_id < MAX_AP_WINDOWS; win_id++) {
-		if (windows->target_id == INVALID_TID)
-			break;
+		win_reg = readl((unsigned long)AP_WIN_CR_OFFSET(win_id));
+		target_id = (win_reg >> AP_TARGET_ID_OFFSET) & AP_TARGET_ID_MASK;
+		/* disable all the windows except DRAM and CFG_SPACE windows */
+		if (target_id == DRAM_0_TID || target_id == DRAM_1_TID || target_id == CFG_REG_TID)
+			continue;
+		win_reg &= ~WIN_ENABLE_BIT;
+		writel(win_reg, (unsigned long)AP_WIN_CR_OFFSET(win_id));
+
+		win_reg = ~AP_WIN_ENA_READ_SECURE;
+		win_reg |= ~AP_WIN_ENA_WRITE_SECURE;
+		writel(win_reg, (unsigned long)AP_WIN_SCR_OFFSET(win_id));
+	}
 
-		adec_enable_ap_win(windows, win_id);
-		windows++;
+	/* disable all IOB windows, start from win_id = 1 because can't disable internal register window */
+	for (win_id = 1; win_id < MAX_IOB_WINDOWS; win_id++) {
+		win_reg = readl((unsigned long)IOB_WIN_CR_OFFSET(win_id));
+		win_reg &= ~WIN_ENABLE_BIT;
+		writel(win_reg, (unsigned long)IOB_WIN_CR_OFFSET(win_id));
+
+		win_reg = ~IOB_WIN_ENA_CTRL_WRITE_SECURE;
+		win_reg |= ~IOB_WIN_ENA_CTRL_READ_SECURE;
+		win_reg |= ~IOB_WIN_ENA_WRITE_SECURE;
+		win_reg |= ~IOB_WIN_ENA_READ_SECURE;
+		writel(win_reg, (unsigned long)IOB_WIN_SCR_OFFSET(win_id));
 	}
-//TODO: add call initializing the windows of the CP
-	debug("Done AP ADEC init\n");
+
+	for (win_id = 0; windows[win_id].target_id != INVALID_TID; win_id++) {
+		if (windows[win_id].enabled) {
+			adec_win_check(&windows[win_id], win_id);
+			switch (windows[win_id].win_type) {
+			case ADEC_IOB_WIN:
+				adec_enable_iob_win(&windows[win_id], win_id);
+				break;
+			case ADEC_AP_WIN:
+				adec_enable_ap_win(&windows[win_id], win_id);
+				break;
+			case ADEC_RFU_WIN:
+				adec_enable_rfu_win(&windows[win_id], win_id);
+				break;
+			default:
+				error("Wrong window type, window number = %d, type number = %d\n", win_id, windows[win_id].win_type);
+			}
+		}
+	}
+
+	debug("Done CCU Address decoding Initializing\n");
+	debug_exit();
 
 	return 0;
 }
diff --git a/arch/arm/include/asm/arch-armada8k/memory-map.h b/arch/arm/include/asm/arch-armada8k/memory-map.h
index 1ccc40d..77e8d45 100644
--- a/arch/arm/include/asm/arch-armada8k/memory-map.h
+++ b/arch/arm/include/asm/arch-armada8k/memory-map.h
@@ -17,5 +17,24 @@
  * ***************************************************************************
  */
 
-#define MVEBU_REGS_BASE	(0xF0000000)
-#define MVEBU_REGS_SIZE (0x100000)
+/* Memory Map */
+/* 0x00000000 - 0x40000000 - DRAM */
+/* 0x40000000 - 0x60000000 - IO-0 */
+/* 0x60000000 - 0x61000000 - PEX-0 */
+/* 0x61000000 - 0x62000000 - PEX-1 */
+/* 0x62000000 - 0x63000000 - NSS */
+
+#define MVEBU_REGS_BASE		(0xF0000000)
+#define MVEBU_REGS_SIZE 	(0x100000)
+
+#define DRAM_0_BASE_ADDR	0x0
+#define DRAM_0_SIZE		0x40000000
+
+#define IO_0_BASE_ADDR		0x40000000
+#define IO_0_SIZE		0x20000000
+
+#define PEX_BASE_ADDR(id)	(0x60000000 + (0x1000000 * id))
+#define PEX_SIZE(id)		(0x1000000)
+
+#define NSS_BASE_ADDR		(0x62000000)
+#define NSS_SIZE		(0x1000000)
diff --git a/arch/arm/include/asm/arch-armada8k/regs-base.h b/arch/arm/include/asm/arch-armada8k/regs-base.h
index c5ec267..5f9efc3 100644
--- a/arch/arm/include/asm/arch-armada8k/regs-base.h
+++ b/arch/arm/include/asm/arch-armada8k/regs-base.h
@@ -25,7 +25,9 @@
 #define MPP_REGS_BASE	(MVEBU_REGS_BASE + 0x1000)
 
 /* List of register base for all units */
-#define MVEBU_ADEC_BASE 	(MVEBU_REGS_BASE + 0x0)
+#define MVEBU_ADEC_AP_BASE 	(MVEBU_REGS_BASE + 0x0)
+#define MVEBU_ADEC_RFU_BASE 	(MVEBU_REGS_BASE + 0x680000)
+#define MVEBU_ADEC_IOB_BASE 	(MVEBU_REGS_BASE + 0x2810000)
 
 #define MVEBU_UART_BASE(x)	(MVEBU_REGS_BASE + 0x512000 + (0x100 * x))
 #define MVEBU_MISC_REGS_BASE	(MVEBU_REGS_BASE + 0x18200)
diff --git a/arch/arm/include/asm/arch-mvebu/adec_ccu.h b/arch/arm/include/asm/arch-mvebu/adec_ccu.h
index 142daff..8aa750a 100644
--- a/arch/arm/include/asm/arch-mvebu/adec_ccu.h
+++ b/arch/arm/include/asm/arch-mvebu/adec_ccu.h
@@ -17,47 +17,95 @@
  * ***************************************************************************
  */
 
+#include <asm/arch/regs-base.h>
+
 struct adec_win {
+	u8 target_id;
 	uintptr_t base_addr;
 	uintptr_t win_size;
-	u8 target_id;
-	void *attribute;
-	u8 rar_enable;
+	u8 win_type;
+	u8 enabled;
 };
 
 enum adec_target_ids_ap {
-	IO_0_TID    = 0x0,
-	DRAM_0_TID  = 0x3,
-	DRAM_1_TID  = 0x6,
-	IO_1_TID    = 0x9,
-	CFG_REG_TID = 0x10,
-	INVALID_TID = 0x1F
+	IO_0_TID	= 0x00,
+	DRAM_0_TID	= 0x03,
+	IO_1_TID	= 0x0F,
+	CFG_REG_TID	= 0x10,
+	RAR_TID		= 0x20,
+	SRAM_TID	= 0x40,
+	DRAM_1_TID	= 0xC0,
+};
+
+enum adec_target_ids_iob {
+	INTERNAL_TID	= 0x0,
+	IOB_TID		= 0x1,
+	IHB1_TID	= 0x2,
+	PEX0_TID	= 0x3,
+	PEX1_TID	= 0x4,
+	PEX2_TID	= 0x5,
+	PEX3_TID	= 0x6,
+	NSS_TID		= 0x7,
+	NAND_TID	= 0x8,
+	RUNIT_TID	= 0x9,
+	INVALID_TID	= 0xFF
+};
+
+enum adec_win_type {
+	ADEC_AP_WIN,
+	ADEC_IOB_WIN,
+	ADEC_RFU_WIN,
 };
 
-#define RAR_EN_OFFSET		(13)
-#define RAR_EN_MASK		(1)
-#define TARGET_ID_OFFSET	(8)
-#define TARGET_ID_MASK		(0x1F)
-#define WIN_ENABLE_BIT		(0x1)
+/* common defines */
+#define WIN_ENABLE_BIT			(0x1)
+#define ADDRESS_SHIFT			(20)
+#define ADDRESS_MASK			(0xFFFFFFF0)
+#define CR_WIN_SIZE_ALIGNMENT		(0x10000)
+
+/* AP registers */
+#define MAX_AP_WINDOWS			(8)
+
+#define AP_WIN_CR_OFFSET(win)		(MVEBU_ADEC_AP_BASE + 0x0 + (0x10 * win))
+#define AP_TARGET_ID_OFFSET		(8)
+#define AP_TARGET_ID_MASK		(0x7F)
+
+#define AP_WIN_SCR_OFFSET(win)		(MVEBU_ADEC_AP_BASE + 0x4 + (0x10 * win))
+#define AP_WIN_ENA_READ_SECURE		(0x1)
+#define AP_WIN_ENA_WRITE_SECURE		(0x2)
+
+#define AP_WIN_ALR_OFFSET(win)		(MVEBU_ADEC_AP_BASE + 0x8 + (0x10 * win))
+#define AP_WIN_AHR_OFFSET(win)		(MVEBU_ADEC_AP_BASE + 0xC + (0x10 * win))
+
+#define AP_WIN_GCR_OFFSET		(MVEBU_ADEC_AP_BASE + 0xD0)
+
+/* RFU registers */
+#define MAX_RFU_WINDOWS			3
+#define BOOTROM_RFU_WINDOW_NUM		0
+#define STM_RFU_WINDOW_NUM		1
+#define SPI_RFU_WINDOW_NUM		2
+
+
+#define RFU_WIN_ALR_OFFSET(win)		(MVEBU_ADEC_RFU_BASE + 0x0 + (0x10 * win))
+#define RFU_WIN_AHR_OFFSET(win)		(MVEBU_ADEC_RFU_BASE + 0x8 + (0x10 * win))
 
-#define ADDRESS_SHIFT		(20)
-#define ADDRESS_MASK		(0xFFFFFFF0)
+/* IOB registers */
+#define MAX_IOB_WINDOWS			(23)
+#define INTERNAL_REG_WIN_NUM		(0)
 
-#define MAX_AP_WINDOWS		(8)
-#define MAX_CP_WINDOWS		(16)
+#define IOB_WIN_CR_OFFSET(win)		(MVEBU_ADEC_IOB_BASE + 0x0 + (0x32 * win))
+#define IOB_TARGET_ID_OFFSET		(8)
+#define IOB_TARGET_ID_MASK		(0xF)
 
-//TODO: split this file to be scisific for a38x and a8k
-#define MAX_MBUS_WINDOWS	(21)
-#define MBUS_INTREG_WIN		(20)
-#define MAX_MBUS_REMAP_WINS	(8)
+#define IOB_WIN_SCR_OFFSET(win)		(MVEBU_ADEC_IOB_BASE + 0x4 + (0x32 * win))
+#define IOB_WIN_ENA_CTRL_WRITE_SECURE	(0x1)
+#define IOB_WIN_ENA_CTRL_READ_SECURE	(0x2)
+#define IOB_WIN_ENA_WRITE_SECURE	(0x4)
+#define IOB_WIN_ENA_READ_SECURE		(0x8)
 
-#define MBUS_WIN_OFFSET(win)	((win < MAX_MBUS_REMAP_WINS) ? \
-				(win * 0x10) : (0x90 + (win-8)*0x08))
-#define TARGET_IS_DRAM(target)	(target == DRAM_0_TID) && (target == DRAM_1_TID)
+#define IOB_WIN_ALR_OFFSET(win)		(MVEBU_ADEC_IOB_BASE + 0x8 + (0x32 * win))
+#define IOB_WIN_AHR_OFFSET(win)		(MVEBU_ADEC_IOB_BASE + 0xC + (0x32 * win))
 
-#define CCU_WIN_CR_OFFSET(win)	(0 + (12 * win))
-#define CCU_WIN_ALR_OFFSET(win)	(4 + (12 * win))
-#define CCU_WIN_AHR_OFFSET(win)	(8 + (12 * win))
 
 void adec_dump(void);
 int adec_init(struct adec_win *windows);
-- 
1.9.1

