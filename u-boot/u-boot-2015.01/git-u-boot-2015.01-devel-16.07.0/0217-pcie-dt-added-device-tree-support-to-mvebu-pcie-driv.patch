From b93c799386d9c15ee86951a0453908029efcba70 Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Wed, 24 Jun 2015 11:06:43 +0300
Subject: [PATCH 0217/1240] pcie: dt: added device tree support to mvebu-pcie
 driver

This is a basic device tree support that lists the register
base and memory space per port

Change-Id: I3e87571589d469c9b294ba95ff0ba2e87bf4b607
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/20450
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
---
 arch/arm/dts/armada-385-db.dts                  |  21 ++-
 arch/arm/include/asm/arch-armada38x/regs-base.h |   2 -
 board/mvebu/common/Makefile                     |   1 -
 doc/device-tree-bindings/pci/mvebu-pci.txt      |  40 ++++++
 drivers/pci/pci_mvebu.c                         | 167 ++++++++++++++----------
 include/fdtdec.h                                |   2 +
 lib/fdtdec.c                                    |   1 +
 7 files changed, 159 insertions(+), 75 deletions(-)
 create mode 100644 doc/device-tree-bindings/pci/mvebu-pci.txt

diff --git a/arch/arm/dts/armada-385-db.dts b/arch/arm/dts/armada-385-db.dts
index e635f2d..65012c2 100644
--- a/arch/arm/dts/armada-385-db.dts
+++ b/arch/arm/dts/armada-385-db.dts
@@ -32,7 +32,7 @@
 	soc {
 		compatible = "marvell,armada380-mbus", "simple-bus";
 		#address-cells = <1>;
-		#size-cells = <0>;
+		#size-cells = <1>;
 
 		internal-regs {
 			compatible = "marvell,internal-regs";
@@ -100,6 +100,25 @@
 					0xfd000000 0x1000000 ATTR(0x0, 0x1, 0x2F)>;
 			};
 		};
+
+
+		pcie-controller {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "marvell,mvebu-pcie";
+
+			pcie@1,0 {
+				reg = <0x80000 0x2000>;
+				mem = <0xE0000000 0x2000000>;
+				status = "okay";
+			};
+
+			pcie@2,0 {
+				reg = <0x40000 0x2000>;
+				mem = <0xE2000000 0x2000000>;
+				status = "okay";
+			};
+		};
 	};
 
 	sar {
diff --git a/arch/arm/include/asm/arch-armada38x/regs-base.h b/arch/arm/include/asm/arch-armada38x/regs-base.h
index bd367c6..4e3a1ab 100644
--- a/arch/arm/include/asm/arch-armada38x/regs-base.h
+++ b/arch/arm/include/asm/arch-armada38x/regs-base.h
@@ -28,8 +28,6 @@
 #define MVEBU_UART_BASE(x)	(MVEBU_REGS_BASE + 0x12000 + (0x100 * x))
 #define MVEBU_GLOBAL_TIMER_BASE	(MVEBU_REGS_BASE + 0x20300)
 #define MVEBU_SPI_REGS_BASE(x)	(MVEBU_REGS_BASE + 0x10600 + (x * 0x80))
-#define MVEBU_PCIE_BASE(x)	((x == 0) ? (MVEBU_REGS_BASE + 0x80000) : \
-				(MVEBU_REGS_BASE + 0x40000 + (0x4000 * (x - 1))))
 #define MVEBU_NAND_REGS_BASE	(MVEBU_REGS_BASE + 0xD0000)
 #define MVEBU_MISC_REGS_BASE	(MVEBU_REGS_BASE + 0x18200)
 #define MVEBU_DEVICE_ID_REG	(MVEBU_MISC_REGS_BASE + 0x38)
diff --git a/board/mvebu/common/Makefile b/board/mvebu/common/Makefile
index 4899d48..936e21c 100644
--- a/board/mvebu/common/Makefile
+++ b/board/mvebu/common/Makefile
@@ -21,7 +21,6 @@ obj-y	+= board-common.o
 obj-y	+= entry.o
 obj-y	+= init.o
 obj-$(CONFIG_MVEBU_NAND) += nand_init.o
-obj-$(CONFIG_MVEBU_PCI)	+= pcie_init.o
 obj-$(CONFIG_CMD_NET)	+= eth_init.o
 
 ifdef CONFIG_DEVEL_BOARD
diff --git a/doc/device-tree-bindings/pci/mvebu-pci.txt b/doc/device-tree-bindings/pci/mvebu-pci.txt
new file mode 100644
index 0000000..862735d
--- /dev/null
+++ b/doc/device-tree-bindings/pci/mvebu-pci.txt
@@ -0,0 +1,40 @@
+Marvell MVEBU PCIe bindings
+===========================
+
+The mvebu-pcie driver controls a set of PCIe ports
+that make up PCIe bus.
+
+The mvebu-pcie requires the following proprties:
+	- compatible
+		should be "marvell,mvebu-pcie"
+	- pcie
+		a node describing a single PCIe port.
+		each pcie node contains the following properties
+		- reg
+			the register base of the pci port
+		- mem
+			an array describing the PCIe port's memory space
+		- endpoint
+			an optional boolean specifying this port should be
+			configured as PCIe endpoint.
+		- status
+			the pcie port's status. can be "okay" or "disabled".
+
+Example of a pinctl bank node:
+	pcie-controller {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "marvell,mvebu-pcie";
+
+		pcie@1,0 {
+			reg = <0x80000 0x2000>;
+			mem = <0xe0000000 0x2000000>;
+			status = "okay";
+		};
+
+		pcie@2,0 {
+			reg = <0x40000 0x2000>;
+			mem = <0xe2000000 0x2000000>;
+			status = "okay";
+		};
+	};
diff --git a/drivers/pci/pci_mvebu.c b/drivers/pci/pci_mvebu.c
index 6a4fae7..0fcecd8 100644
--- a/drivers/pci/pci_mvebu.c
+++ b/drivers/pci/pci_mvebu.c
@@ -19,9 +19,10 @@
 
 #include <common.h>
 #include <pci.h>
+#include <fdtdec.h>
 #include <asm/io.h>
-#include <asm/arch/regs-base.h>
 #include <asm/arch/memory-map.h>
+#include <asm/arch-mvebu/fdt.h>
 #include <errno.h>
 
 /* #define DEBUG */
@@ -37,32 +38,32 @@
  */
 
 /* Standard PCI-E header reigsters */
-#define PCIE_DEV_ID_OFF(x)		(MVEBU_PCIE_BASE(x) + 0x0)
-#define PCIE_CMD_OFF(x)			(MVEBU_PCIE_BASE(x) + 0x4)
-#define PCIE_DEV_REV_OFF(x)		(MVEBU_PCIE_BASE(x) + 0x8)
-#define PCIE_CAP_OFF(x)			(MVEBU_PCIE_BASE(x) + 0x60)
+#define PCIE_DEV_ID_OFF(x)		(x + 0x0)
+#define PCIE_CMD_OFF(x)			(x + 0x4)
+#define PCIE_DEV_REV_OFF(x)		(x + 0x8)
+#define PCIE_CAP_OFF(x)			(x + 0x60)
 #define PCIE_CAP_DEV_TYPE_MASK		(0xF << 20)
 #define PCIE_CAP_DEV_TYPE_EP		(0x1 << 20)
 #define PCIE_CAP_DEV_TYPE_RC		(0x4 << 20)
 
-#define PCIE_BAR_LO_OFF(x, n)		(MVEBU_PCIE_BASE(x) + (0x10 + (0x8 * n)))
-#define PCIE_BAR_HI_OFF(x, n)		(MVEBU_PCIE_BASE(x) + (0x14 + (0x8 * n)))
-#define PCIE_BAR_CTRL_OFF(x, n)		(MVEBU_PCIE_BASE(x) + (0x1800 + (0x4 * n)))
+#define PCIE_BAR_LO_OFF(x, n)		(x + (0x10 + (0x8 * n)))
+#define PCIE_BAR_HI_OFF(x, n)		(x + (0x14 + (0x8 * n)))
+#define PCIE_BAR_CTRL_OFF(x, n)		(x + (0x1800 + (0x4 * n)))
 #define PCIE_BAR_TYPE_MEM		(0xC)
 #define PCIE_BAR_ENABLE			(0x1)
 #define PCIE_BAR_CNT			(3)
 
 /* Memory access control */
 #define PCIE_WIN_OFF(n)			((n < 5) ? (0x0) : (0x10))
-#define PCIE_WIN_CTRL_OFF(x, n)		(MVEBU_PCIE_BASE(x) + 0x1820 + PCIE_WIN_OFF(n) + (0x10 * n))
-#define PCIE_WIN_BASE_OFF(x, n)		(MVEBU_PCIE_BASE(x) + 0x1824 + PCIE_WIN_OFF(n) + (0x10 * n))
-#define PCIE_WIN_REMAP_OFF(x, n)	(MVEBU_PCIE_BASE(x) + 0x182C + PCIE_WIN_OFF(n) + (0x10 * n))
+#define PCIE_WIN_CTRL_OFF(x, n)		(x + 0x1820 + PCIE_WIN_OFF(n) + (0x10 * n))
+#define PCIE_WIN_BASE_OFF(x, n)		(x + 0x1824 + PCIE_WIN_OFF(n) + (0x10 * n))
+#define PCIE_WIN_REMAP_OFF(x, n)	(x + 0x182C + PCIE_WIN_OFF(n) + (0x10 * n))
 #define PCIE_DDR_TARGET_ID		(0)
 #define PCIE_XBAR_WIN_CNT		(6)
 
 /* Configuration access */
-#define PCIE_CONF_ADDR_OFF(x)		(MVEBU_PCIE_BASE(x) + 0x18f8)
-#define PCIE_CONF_DATA_OFF(x)		(MVEBU_PCIE_BASE(x) + 0x18fc)
+#define PCIE_CONF_ADDR_OFF(x)		(x + 0x18f8)
+#define PCIE_CONF_DATA_OFF(x)		(x + 0x18fc)
 #define PCIE_CONF_ADDR_EN		0x80000000
 #define PCIE_CONF_REG(r)		((((r) & 0xf00) << 16) | ((r) & 0xfc))
 #define PCIE_CONF_BUS(b)		(((b) & 0xff) << 16)
@@ -71,7 +72,7 @@
 #define PCIE_CONF_ADDR(bdf, where)	(bdf | PCIE_CONF_REG(where) | PCIE_CONF_ADDR_EN)
 
 /* Controler status */
-#define PCIE_STAT_OFF(x)	(MVEBU_PCIE_BASE(x) + 0x1a04)
+#define PCIE_STAT_OFF(x)	(x + 0x1a04)
 #define PCIE_STAT_BUS_OFF	(8)
 #define PCIE_STAT_BUS_MASK	(0xFF << PCIE_STAT_BUS_OFF)
 #define PCIE_STAT_DEV_OFF	(16)
@@ -79,13 +80,20 @@
 #define PCIE_STAT_LINK		(1)
 
 /* Link status */
-#define PCIE_DBG_STATUS_OFF(x)	(MVEBU_PCIE_BASE(x) + 0x1a64)
+#define PCIE_DBG_STATUS_OFF(x)	(x + 0x1a64)
 #define PCIE_LTSSM_LINK_UP	0x7E
 #define PCIE_LTSSM_MASK		0x7F
-#define PCIE_LINK_CTL_OFF(x)	(MVEBU_PCIE_BASE(x) + 0x70)
+#define PCIE_LINK_CTL_OFF(x)	(x + 0x70)
+
+#define MAX_PCIE_PORTS		10
 
 DECLARE_GLOBAL_DATA_PTR;
 
+struct pcie_win {
+	u32 base;
+	u32 size;
+};
+
 static int mvebu_pcie_addr_valid(pci_dev_t d, int first_busno)
 {
 	/*
@@ -136,24 +144,24 @@ static int mvebu_pcie_write_config(struct pci_controller *hose, pci_dev_t bdf,
 	return 0;
 }
 
-static void mvebu_pcie_set_local_bus_nr(int hid, int nr)
+static void mvebu_pcie_set_local_bus_nr(u32 reg_base, int nr)
 {
 	u32 stat;
 
-	stat = readl(PCIE_STAT_OFF(hid));
+	stat = readl(PCIE_STAT_OFF(reg_base));
 	stat &= ~PCIE_STAT_BUS_MASK;
 	stat |= nr << PCIE_STAT_BUS_OFF;
-	writel(stat, PCIE_STAT_OFF(hid));
+	writel(stat, PCIE_STAT_OFF(reg_base));
 }
 
-static void mvebu_pcie_set_local_dev_nr(int hid, int nr)
+static void mvebu_pcie_set_local_dev_nr(u32 reg_base, int nr)
 {
 	u32 stat;
 
-	stat = readl(PCIE_STAT_OFF(hid));
+	stat = readl(PCIE_STAT_OFF(reg_base));
 	stat &= ~PCIE_STAT_DEV_MASK;
 	stat |= nr << PCIE_STAT_DEV_OFF;
-	writel(stat, PCIE_STAT_OFF(hid));
+	writel(stat, PCIE_STAT_OFF(reg_base));
 }
 
 /*
@@ -161,7 +169,7 @@ static void mvebu_pcie_set_local_dev_nr(int hid, int nr)
  * BAR[0,2] -> disabled, BAR[1] -> covers all DRAM banks
  * WIN[0-3] -> DRAM bank[0-3]
  */
-static void mvebu_pcie_setup_mapping(int hid)
+static void mvebu_pcie_setup_mapping(u32 reg_base)
 {
 	u32 size;
 	int i;
@@ -171,15 +179,15 @@ static void mvebu_pcie_setup_mapping(int hid)
 	 * BAR0 which is fixed to internal registers
 	 */
 	for (i = 1; i < PCIE_BAR_CNT; i++) {
-		writel(0, PCIE_BAR_CTRL_OFF(hid, i));
-		writel(0, PCIE_BAR_LO_OFF(hid, i));
-		writel(0, PCIE_BAR_HI_OFF(hid, i));
+		writel(0, PCIE_BAR_CTRL_OFF(reg_base, i));
+		writel(0, PCIE_BAR_LO_OFF(reg_base, i));
+		writel(0, PCIE_BAR_HI_OFF(reg_base, i));
 	}
 
 	for (i = 0; i < PCIE_XBAR_WIN_CNT; i++) {
-		writel(0, PCIE_WIN_CTRL_OFF(hid, i));
-		writel(0, PCIE_WIN_BASE_OFF(hid, i));
-		writel(0, PCIE_WIN_REMAP_OFF(hid, i));
+		writel(0, PCIE_WIN_CTRL_OFF(reg_base, i));
+		writel(0, PCIE_WIN_BASE_OFF(reg_base, i));
+		writel(0, PCIE_WIN_REMAP_OFF(reg_base, i));
 	}
 
 	/* Setup XBAR windows for DDR banks. */
@@ -194,9 +202,9 @@ static void mvebu_pcie_setup_mapping(int hid)
 		attr = ~(1 << i) & 0xF; /* Zero bit indicates the CS */
 		ctrl = size | (attr << 8) | (PCIE_DDR_TARGET_ID << 4) | 1;
 
-		writel(base, PCIE_WIN_BASE_OFF(hid, i));
-		writel(ctrl, PCIE_WIN_CTRL_OFF(hid, i));
-		writel(0, PCIE_WIN_REMAP_OFF(hid, i));
+		writel(base, PCIE_WIN_BASE_OFF(reg_base, i));
+		writel(ctrl, PCIE_WIN_CTRL_OFF(reg_base, i));
+		writel(0, PCIE_WIN_REMAP_OFF(reg_base, i));
 		debug("PCIE WIN-%d base = 0x%08x ctrl = 0x%08x\n", i, base, ctrl);
 	}
 
@@ -206,12 +214,12 @@ static void mvebu_pcie_setup_mapping(int hid)
 		size = 1 << fls(size);
 
 	/* Setup BAR[1] to all DRAM banks. */
-	writel(gd->bd->bi_dram[0].start | PCIE_BAR_TYPE_MEM, PCIE_BAR_LO_OFF(hid, 1));
-	writel(0, PCIE_BAR_HI_OFF(hid, 1));
-	writel(((size - 1) & 0xffff0000) | PCIE_BAR_ENABLE, PCIE_BAR_CTRL_OFF(hid, 1));
+	writel(gd->bd->bi_dram[0].start | PCIE_BAR_TYPE_MEM, PCIE_BAR_LO_OFF(reg_base, 1));
+	writel(0, PCIE_BAR_HI_OFF(reg_base, 1));
+	writel(((size - 1) & 0xffff0000) | PCIE_BAR_ENABLE, PCIE_BAR_CTRL_OFF(reg_base, 1));
 }
 
-static void mvebu_pcie_hw_init(int host_id, int first_busno)
+static void mvebu_pcie_hw_init(u32 reg_base, int first_busno)
 {
 	u32 cmd;
 
@@ -219,17 +227,17 @@ static void mvebu_pcie_hw_init(int host_id, int first_busno)
 	 * Set our controller as device No 1 to avoid
 	 * Answering CFG cycle by our host (memory controller)
 	 */
-	mvebu_pcie_set_local_dev_nr(host_id, 1);
-	mvebu_pcie_set_local_bus_nr(host_id, first_busno);
+	mvebu_pcie_set_local_dev_nr(reg_base, 1);
+	mvebu_pcie_set_local_bus_nr(reg_base, first_busno);
 
-	mvebu_pcie_setup_mapping(host_id);
+	mvebu_pcie_setup_mapping(reg_base);
 
 	/* Master + slave enable. */
-	cmd = readw(PCIE_CMD_OFF(host_id));
+	cmd = readw(PCIE_CMD_OFF(reg_base));
 	cmd |= PCI_COMMAND_IO;
 	cmd |= PCI_COMMAND_MEMORY;
 	cmd |= PCI_COMMAND_MASTER;
-	writew(cmd, PCIE_CMD_OFF(host_id));
+	writew(cmd, PCIE_CMD_OFF(reg_base));
 }
 
 /*
@@ -241,11 +249,11 @@ int pci_skip_dev(struct pci_controller *hose, pci_dev_t dev)
 	return 0;
 }
 
-static struct pci_controller	pci_hose[4];
+static struct pci_controller	pci_hose[MAX_PCIE_PORTS];
 static const char speed_str[3][8] = {"NA", "2.5GHz", "5GHz"};
 static const char width_str[5][8] = {"NA", "x1", "NA", "NA", "x4"};
 
-static int mvebu_pcie_init(int host_id, int first_busno)
+static int mvebu_pcie_init(int host_id, u32 reg_base, struct pcie_win *win, int first_busno)
 {
 	struct pci_controller *hose = &pci_hose[host_id];
 	u32 link, speed, width;
@@ -253,13 +261,10 @@ static int mvebu_pcie_init(int host_id, int first_busno)
 	memset(hose, 0, sizeof(hose));
 
 	/* Setup the HW */
-	mvebu_pcie_hw_init(host_id, first_busno);
+	mvebu_pcie_hw_init(reg_base, first_busno);
 
 	/* Set PCI regions */
-	pci_set_region(&hose->regions[0],
-		       MVEBU_PCIE_MEM_BASE(host_id), MVEBU_PCIE_MEM_BASE(host_id),
-		       MVEBU_PCIE_MEM_SIZE(host_id), PCI_REGION_MEM);
-
+	pci_set_region(&hose->regions[0], win->base, win->base, win->size, PCI_REGION_MEM);
 	hose->region_count = 1;
 
 	pci_set_ops(hose,
@@ -271,11 +276,8 @@ static int mvebu_pcie_init(int host_id, int first_busno)
 		    mvebu_pcie_write_config);
 
 	/* CFG cycle pointers */
-	hose->cfg_addr = (uint *)PCIE_CONF_ADDR_OFF(host_id);
-	hose->cfg_data = (unsigned char *)PCIE_CONF_DATA_OFF(host_id);
-
-	/* TODO - we might need this for IDE */
-	/*hose->config_table = mvebu_config_table;*/
+	hose->cfg_addr = (uint *)PCIE_CONF_ADDR_OFF(reg_base);
+	hose->cfg_data = (unsigned char *)PCIE_CONF_DATA_OFF(reg_base);
 
 	hose->first_busno = first_busno;
 
@@ -286,7 +288,7 @@ static int mvebu_pcie_init(int host_id, int first_busno)
 	hose->last_busno = pci_hose_scan(hose);
 
 	/* Check the link type - for info only */
-	link = readl(PCIE_LINK_CTL_OFF(host_id));
+	link = readl(PCIE_LINK_CTL_OFF(reg_base));
 	speed = (link >> 16) & 0xF;
 	width = (link >> 20) & 0x3F;
 
@@ -295,48 +297,71 @@ static int mvebu_pcie_init(int host_id, int first_busno)
 	return hose->last_busno + 1;
 }
 
-static int mvebu_pcie_check_link(int hid)
+static int mvebu_pcie_check_link(u32 reg_base)
 {
-	return readl(PCIE_STAT_OFF(hid)) &  PCIE_STAT_LINK;
+	return readl(PCIE_STAT_OFF(reg_base)) &  PCIE_STAT_LINK;
 }
 
-static void mvebu_pcie_set_endpoint(int hid)
+static void mvebu_pcie_set_endpoint(u32 hid, u32 reg_base)
 {
 	u32 capability;
 
 	/* Check the LTSSM state machine if something is connected */
-	capability = readl(PCIE_CAP_OFF(hid));
+	capability = readl(PCIE_CAP_OFF(reg_base));
 	capability &= ~PCIE_CAP_DEV_TYPE_MASK;
 	capability |= PCIE_CAP_DEV_TYPE_EP;
-	writel(capability, PCIE_CAP_OFF(hid));
+	writel(capability, PCIE_CAP_OFF(reg_base));
 
 	/* Open DRAM access for master */
-	mvebu_pcie_setup_mapping(hid);
+	mvebu_pcie_setup_mapping(reg_base);
 
 	printf("PCIE-%d: End point mode\n", hid);
 }
 
-void mvebu_pcie_init_board(int max_hosts, u16 active_mask, u16 ep_mask)
+void pci_init_board(void)
 {
-	int host_id;
+	int host_id = -1;
 	int first_busno = 0;
+	int bus_node, port_node, count;
+	const void *blob = gd->fdt_blob;
+	struct pcie_win win;
+	u32 reg_base;
+	int err;
+
+	count = fdtdec_find_aliases_for_id(blob, "pcie-controller",
+			COMPAT_MVEBU_PCIE, &bus_node, 1);
+
+	if (count <= 0)
+		return;
 
-	/* Loop over all active PCI ports */
-	for (host_id = 0; host_id < max_hosts; host_id++) {
-		/* Check if unit is enabled */
-		if ((active_mask & (1 << host_id)) == 0)
+	fdt_for_each_subnode(blob, port_node, bus_node) {
+		host_id++;
+
+		if (!fdtdec_get_is_enabled(blob, port_node))
+			continue;
+
+		reg_base = (u32)fdt_get_regs_offs(blob, port_node, "reg");
+		if (reg_base == 0) {
+			error("Missing registers in PCIe node\n");
 			continue;
+		}
 
-		/* Define host controller as endpoint */
-		if (ep_mask & (1 << host_id)) {
-			mvebu_pcie_set_endpoint(host_id);
+		if (fdtdec_get_bool(blob, port_node, "endpoint")) {
+			mvebu_pcie_set_endpoint(host_id, reg_base);
 			continue;
 		}
 
 		/* Don't register host if link is down */
-		if (mvebu_pcie_check_link(host_id))
+		if (mvebu_pcie_check_link(reg_base))
 			continue;
 
-		first_busno = mvebu_pcie_init(host_id, first_busno);
+		err = fdtdec_get_int_array(blob, port_node, "mem", (u32 *)&win, 2);
+		if (err) {
+			error("pcie: missing pci memory space in fdt\n");
+			continue;
+		}
+
+		/* If all is well register the host */
+		first_busno = mvebu_pcie_init(host_id, reg_base, &win, first_busno);
 	}
 }
diff --git a/include/fdtdec.h b/include/fdtdec.h
index 09bfdf4..9ad1123 100644
--- a/include/fdtdec.h
+++ b/include/fdtdec.h
@@ -132,6 +132,8 @@ enum fdt_compat_id {
 	COMPAT_MVEBU_CCU,
 	COMPAT_MVEBU_RFU,
 	COMPAT_MVEBU_IOB,
+	COMPAT_MVEBU_PCIE,
+
 	COMPAT_COUNT,
 };
 
diff --git a/lib/fdtdec.c b/lib/fdtdec.c
index a9571cf..68bcd36 100644
--- a/lib/fdtdec.c
+++ b/lib/fdtdec.c
@@ -94,6 +94,7 @@ static const char * const compat_names[COMPAT_COUNT] = {
 	COMPAT(MVEBU_CCU, "marvell,mvebu-ccu"),
 	COMPAT(MVEBU_RFU, "marvell,mvebu-rfu"),
 	COMPAT(MVEBU_IOB, "marvell,mvebu-iob"),
+	COMPAT(MVEBU_PCIE, "marvell,mvebu-pcie"),
 };
 
 const char *fdtdec_get_compatible(enum fdt_compat_id id)
-- 
1.9.1

