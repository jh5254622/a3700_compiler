From cbe7174d518da743558c50c37a30512fbab05146 Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Fri, 26 Jun 2015 16:16:40 +0300
Subject: [PATCH 0229/1240] ccu: added support for 64Bit addresses for CCU
 address decoding driver

Change-Id: Ib549f0cb3b45bc2eca3940f2c79aa1dead19871b
Signed-off-by: Hanna Hawa <hannah@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/20517
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
---
 arch/arm/dts/apn-806.dtsi                   |  2 +-
 doc/device-tree-bindings/misc/mvebu-ccu.txt | 13 +++++++++---
 drivers/misc/mvebu_ccu.c                    | 32 +++++++++++++++++------------
 3 files changed, 30 insertions(+), 17 deletions(-)

diff --git a/arch/arm/dts/apn-806.dtsi b/arch/arm/dts/apn-806.dtsi
index 4180e1f..51f9719 100644
--- a/arch/arm/dts/apn-806.dtsi
+++ b/arch/arm/dts/apn-806.dtsi
@@ -73,7 +73,7 @@
 				compatible = "marvell,mvebu-ccu";
 				reg = <0x4000 0x50>;
 				max-win = <8>;
-				windows = <0xf2000000 0xe000000 0x00 /* IO window */>;
+				windows = <0x0 0xf2000000 0xe000000 0x00 /* IO window */>;
 			};
 
 			rfu {
diff --git a/doc/device-tree-bindings/misc/mvebu-ccu.txt b/doc/device-tree-bindings/misc/mvebu-ccu.txt
index 883c56f..9dfbaba 100644
--- a/doc/device-tree-bindings/misc/mvebu-ccu.txt
+++ b/doc/device-tree-bindings/misc/mvebu-ccu.txt
@@ -9,16 +9,23 @@ The CCU node requires the following properties:
 	- reg: the base address of the CCU unit
 	- max-win: number of the max mbus windows
 	- windows: entry that include the configuration of the windows
-	  every window should have 3 parameters:
-	  - base address of the window
+	  every window should have 4 parameters:
+	  - high base address of the window
+	  - low base address of the window
 	  - size of the window
 	  - target-id of the window
 
+Note: if the base address is more than 32bit, it divided into high and low,
+	Example:
+		base address: 0x10f0000000 should divided into:
+		base address high: 0x10
+		base address low: 0xf0000000
+
 Example:
 	map-ccu {
 		compatible = "marvell,mvebu-ccu";
 		reg = <0x0 0x50>;
 		max-win = <8>;
-		windows = <0xf8000000 0x2000000 0x00 /* IO window */>;
+		windows = <0x0 0xf8000000 0x2000000 0x00 /* IO window */>;
 	};
 
diff --git a/drivers/misc/mvebu_ccu.c b/drivers/misc/mvebu_ccu.c
index 841d49a..27fbe00 100644
--- a/drivers/misc/mvebu_ccu.c
+++ b/drivers/misc/mvebu_ccu.c
@@ -62,7 +62,8 @@ struct ccu_configuration __attribute__((section(".data")))ccu_config;
 struct ccu_configuration __attribute__((section(".data")))*ccu_info = &ccu_config;
 
 struct ccu_win {
-	u32 base_addr;
+	u32 base_addr_high;
+	u32 base_addr_low;
 	u32 win_size;
 	u32 target_id;
 };
@@ -107,11 +108,15 @@ static char *ccu_target_name_get(enum ccu_target_ids trgt_id)
 
 static void ccu_win_check(struct ccu_win *win, u32 win_num)
 {
+	u64 start_addr;
 	/* check if address is aligned to 1M */
-	if (IS_NOT_ALIGN(win->base_addr, CCU_WIN_ALIGNMENT)) {
-		win->base_addr = ALIGN_UP(win->base_addr, CCU_WIN_ALIGNMENT);
+	start_addr = ((u64)win->base_addr_high << 32) + win->base_addr_low;
+	if (IS_NOT_ALIGN(start_addr, CCU_WIN_ALIGNMENT)) {
+		start_addr = ALIGN_UP(start_addr, CCU_WIN_ALIGNMENT);
 		error("Window %d: base address unaligned to 0x%x\n", win_num, CCU_WIN_ALIGNMENT);
-		printf("Align up the base address to 0x%x\n", win->base_addr);
+		printf("Align up the base address to 0x%llx\n", start_addr);
+		win->base_addr_high = (u32)(start_addr >> 32);
+		win->base_addr_low = (u32)(start_addr);
 	}
 
 	/* size parameter validity check */
@@ -126,14 +131,15 @@ static void ccu_enable_win(struct ccu_win *win, u32 win_id)
 {
 	u32 ccu_win_reg;
 	u32 alr, ahr;
-	uintptr_t end_addr;
+	u64 start_addr, end_addr;
 
 	ccu_win_reg = WIN_ENABLE_BIT;
 	ccu_win_reg |= (win->target_id & CCU_TARGET_ID_MASK) << CCU_TARGET_ID_OFFSET;
 	writel(ccu_win_reg, CCU_WIN_CR_OFFSET(win_id));
 
-	end_addr = (win->base_addr + win->win_size - 1);
-	alr = (u32)((win->base_addr >> ADDRESS_SHIFT) & ADDRESS_MASK);
+	start_addr = ((u64)win->base_addr_high << 32) + win->base_addr_low;
+	end_addr = (start_addr + (u64)win->win_size - 1);
+	alr = (u32)((start_addr >> ADDRESS_SHIFT) & ADDRESS_MASK);
 	ahr = (u32)((end_addr >> ADDRESS_SHIFT) & ADDRESS_MASK);
 
 	writel(alr, CCU_WIN_ALR_OFFSET(win_id));
@@ -144,7 +150,7 @@ void dump_ccu(void)
 {
 	u32 win_id, win_cr, alr, ahr;
 	u8 target_id;
-	uintptr_t start, end;
+	u64 start, end;
 
 	/* Dump all AP windows */
 	printf("bank  id target   start              end\n");
@@ -155,9 +161,9 @@ void dump_ccu(void)
 			target_id = (win_cr >> CCU_TARGET_ID_OFFSET) & CCU_TARGET_ID_MASK;
 			alr = readl(CCU_WIN_ALR_OFFSET(win_id));
 			ahr = readl(CCU_WIN_AHR_OFFSET(win_id));
-			start = (uintptr_t)(alr << ADDRESS_SHIFT);
-			end = (uintptr_t)((ahr + 0x10) << ADDRESS_SHIFT);
-			printf("ccu   %02x %s  0x%016lx 0x%016lx\n"
+			start = ((u64)alr << ADDRESS_SHIFT);
+			end = (((u64)ahr + 0x10) << ADDRESS_SHIFT);
+			printf("ccu   %02x %s  0x%016llx 0x%016llx\n"
 				, win_id, ccu_target_name_get(target_id), start, end);
 		}
 	}
@@ -201,12 +207,12 @@ int init_ccu(void)
 	}
 
 	/* Get the array of the windows and fill the map data */
-	win_count = fdtdec_get_int_array_count(blob, node, "windows", (u32 *)memory_map, ccu_info->max_win * 3);
+	win_count = fdtdec_get_int_array_count(blob, node, "windows", (u32 *)memory_map, ccu_info->max_win * 4);
 	if (win_count <= 0) {
 		debug("no windows configurations found\n");
 		return 0;
 	}
-	win_count = win_count/3; /* every window had 3 variables in FDT (base, size, target id) */
+	win_count = win_count/4; /* every window had 3 variables in FDT (base, size, target id) */
 
 	/* Set the default target ID to DRAM 0 */
 	win_reg = (DRAM_0_TID & CCU_GCR_TARGET_MASK) << CCU_GCR_TARGET_OFFSET;
-- 
1.9.1

