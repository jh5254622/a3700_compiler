From 6a4d3b1726d0369048eb99d8691efa7c0b39271a Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Wed, 8 Jul 2015 14:20:37 +0300
Subject: [PATCH 0251/1240] comphy: added basic support for COMPHY power up
 sequence for a38x

- Added basic support for COMPHY power up sequence for a38x
- The driver include basic PCIe power up (By 1 only)

Change-Id: Ib2b5689a7f12983f058bc0ca65fe646864a5c135
Signed-off-by: Hanna Hawa <hannah@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/21132
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
---
 arch/arm/include/asm/arch-mvebu/comphy.h       |  37 +++-
 arch/arm/include/asm/arch-mvebu/comphy_hpipe.h |  52 +++++
 drivers/phy/Makefile                           |   2 +
 drivers/phy/comphy_a38x.c                      | 244 ++++++++++++++++++++++++
 drivers/phy/comphy_core.c                      | 163 +---------------
 drivers/phy/comphy_pcie_config.c               | 254 +++++++++++++++++++++++++
 6 files changed, 583 insertions(+), 169 deletions(-)
 create mode 100644 arch/arm/include/asm/arch-mvebu/comphy_hpipe.h
 create mode 100644 drivers/phy/comphy_a38x.c
 create mode 100644 drivers/phy/comphy_pcie_config.c

diff --git a/arch/arm/include/asm/arch-mvebu/comphy.h b/arch/arm/include/asm/arch-mvebu/comphy.h
index 35f4a61..8de250a 100644
--- a/arch/arm/include/asm/arch-mvebu/comphy.h
+++ b/arch/arm/include/asm/arch-mvebu/comphy.h
@@ -19,6 +19,8 @@
 #ifndef _COMPHY_H_
 #define _COMPHY_H_
 
+#include <fdtdec.h>
+
 #define MAX_LANE_OPTIONS 10
 
 enum phy_speed {
@@ -57,22 +59,37 @@ enum phy_type {
 	INVALID_TYPE = 0xff
 };
 
+struct comphy_mux_options {
+	enum phy_type type;
+	u32 mux_value;
+};
+
+struct comphy_mux_data {
+	u32 max_lane_values;
+	struct comphy_mux_options mux_values[MAX_LANE_OPTIONS];
+};
+
 struct comphy_map {
 	enum phy_type type;
 	enum phy_speed speed;
 };
 
-u32 comphy_init(const void *blob);
+struct chip_serdes_phy_config {
+	enum fdt_compat_id compat;
+	struct comphy_mux_data *mux_data;
+	int (*ptr_comphy_chip_init)(struct chip_serdes_phy_config *, struct comphy_map *);
+	u32 comphy_base_addr;
+	u32 hpipe3_base_addr;
+	u32 comphy_lanes_count;
+	u32 comphy_mux_bitcount;
+};
 
-#ifdef CONFIG_TARGET_ARMADA_38X
-struct comphy_mux_data *get_a38x_comphy_mux_data(void);
-#endif
-#ifdef CONFIG_TARGET_ARMADA_8K
-struct comphy_mux_data *get_ap806_comphy_mux_data(void);
-#endif
-#ifdef CONFIG_TARGET_CP110
-struct comphy_mux_data *get_cp110_comphy_mux_data(void);
-#endif
+void reg_set(u32 addr, u32 mask, u32 data);
+u32 comphy_init(const void *blob);
+int comphy_a38x_init(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_map *comphy_map_data);
+void comphy_pcie_config_set(u32 comphy_max_count, struct comphy_map *serdes_map);
+void comphy_pcie_config_detect(u32 comphy_max_count, struct comphy_map *serdes_map);
+void comphy_pcie_unit_general_config(u32 pex_index);
 
 #endif /* _COMPHY_H_ */
 
diff --git a/arch/arm/include/asm/arch-mvebu/comphy_hpipe.h b/arch/arm/include/asm/arch-mvebu/comphy_hpipe.h
new file mode 100644
index 0000000..6e58385
--- /dev/null
+++ b/arch/arm/include/asm/arch-mvebu/comphy_hpipe.h
@@ -0,0 +1,52 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+#ifndef _COMPHY_HPIPE_H_
+#define _COMPHY_HPIPE_H_
+
+#define HPIPE_POWER_AND_PLL_CTRL_REG            0x004
+#define HPIPE_SQUELCH_FFE_SETTING_REG           0x018
+#define HPIPE_DFE_REG0                          0x01C
+#define HPIPE_G1_SETTINGS_0_REG                 0x034
+#define HPIPE_G1_SETTINGS_1_REG                 0x038
+#define HPIPE_G2_SETTINGS_1_REG                 0x040
+#define HPIPE_SYNC_PATTERN_REG                  0x090
+#define HPIPE_INTERFACE_REG                     0x094
+#define HPIPE_ISOLATE_REG                       0x098
+#define HPIPE_VTHIMPCAL_CTRL_REG                0x104
+#define HPIPE_PCIE_REG0                         0x120
+#define HPIPE_LANE_ALIGN_REG0                   0x124
+#define HPIPE_MISC_REG                          0x13C
+#define HPIPE_GLUE_REG                          0x140
+#define HPIPE_GENERATION_DIVIDER_FORCE_REG      0x144
+#define HPIPE_RESET_DFE_REG                     0x148
+#define HPIPE_PLLINTP_REG1                      0x150
+#define HPIPE_RX_REG3                           0x188
+#define HPIPE_PCIE_REG1                         0x288
+#define HPIPE_PCIE_REG3                         0x290
+#define HPIPE_G1_SETTINGS_3_REG                 0x440
+#define HPIPE_G1_SETTINGS_4_REG                 0x444
+#define HPIPE_G2_SETTINGS_3_REG                 0x448
+#define HPIPE_G2_SETTINGS_4_REG                 0x44C
+#define HPIPE_LANE_CFG4_REG                     0x620
+#define HPIPE_GLOBAL_CLK_CTRL                   0x704
+#define HPIPE_GLOBAL_MISC_CTRL                  0x718
+#define HPIPE_GLOBAL_PM_CTRL                    0x740
+
+#endif /* _COMPHY_HPIPE_H_ */
+
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index 40b9cf8..1df0c04 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -1 +1,3 @@
 obj-y += comphy_core.o
+obj-y += comphy_a38x.o
+obj-y += comphy_pcie_config.o
diff --git a/drivers/phy/comphy_a38x.c b/drivers/phy/comphy_a38x.c
new file mode 100644
index 0000000..fbdc23d
--- /dev/null
+++ b/drivers/phy/comphy_a38x.c
@@ -0,0 +1,244 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+/*#define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/comphy.h>
+#include <asm/arch-mvebu/comphy_hpipe.h>
+#include <asm/arch-mvebu/mvebu.h>
+
+#define COMMON_PHY_CONFIGURATION1_REG           0x0
+#define COMMON_PHY_CONFIGURATION2_REG           0x4
+#define COMMON_PHY_CONFIGURATION4_REG           0xC
+
+struct comphy_mux_data a38x_comphy_mux_data[] = {
+	{4, {{UNCONNECTED, 0x0}, {PEX0, 0x1}, {SATA0, 0x2}, {SGMII0, 0x3} } },
+	{8, {{UNCONNECTED, 0x0}, {PEX0, 0x1}, {PEX0, 0x2}, {SATA0, 0x3},
+		{SGMII0, 0x4}, {SGMII1, 0x5}, {USB3_HOST0, 0x6}, {QSGMII, 0x7} } },
+	{5, {{UNCONNECTED, 0x0}, {PEX1, 0x1}, {PEX0, 0x2}, {SATA1, 0x3}, {SGMII1, 0x4} } },
+	{7, {{UNCONNECTED, 0x0}, {PEX3, 0x1}, {PEX0, 0x2}, {SATA3, 0x3}, {SGMII2, 0x4},
+		{USB3_HOST0, 0x5}, {USB3_DEVICE, 0x6} } },
+	{7, {{UNCONNECTED, 0x0}, {PEX1, 0x1}, {SATA1, 0x2}, {SGMII1, 0x3}, {USB3_HOST0, 0x4},
+		{USB3_DEVICE, 0x5}, {SATA2, 0x6} } },
+	{6, {{UNCONNECTED, 0x0}, {PEX2, 0x1}, {SATA2, 0x2}, {SGMII2, 0x3}, {USB3_HOST1, 0x4},
+		{USB3_DEVICE, 0x5} } },
+};
+
+void reg_set(u32 addr, u32 mask, u32 data)
+{
+	u32 reg_data;
+	debug("Write to address = %#010x, data = %#010x (mask = %#010x) - ", addr, data, mask);
+	debug("old value = %#010x ==> ", readl(addr));
+	reg_data = readl(addr);
+	reg_data &= ~mask;
+	reg_data |= data;
+	writel(reg_data, addr);
+	debug("new value %#010x\n", readl(addr));
+}
+
+/* comphy_mux_check_config
+ * description: this function passes over the COMPHY lanes and check if the type
+ *              is valid for specific lane. If the type is not valid, the function
+ *              update the struct and set the type of the lane as UNCONNECTED */
+static void comphy_mux_check_config(struct comphy_mux_data *mux_data,
+		struct comphy_map *comphy_map_data, int comphy_max_lanes)
+{
+	struct comphy_mux_options *ptr_mux_opt;
+	int lane, opt, valid;
+	debug_enter();
+
+	for (lane = 0; lane < comphy_max_lanes; lane++, comphy_map_data++, mux_data++) {
+		ptr_mux_opt = mux_data->mux_values;
+		for (opt = 0, valid = 0; opt < mux_data->max_lane_values; opt++, ptr_mux_opt++) {
+			if (ptr_mux_opt->type == comphy_map_data->type) {
+				valid = 1;
+				break;
+			}
+		}
+		if (valid == 0) {
+			debug("lane number %d, had invalid type %d\n", lane, comphy_map_data->type);
+			debug("set lane %d as type %d\n", lane, UNCONNECTED);
+			comphy_map_data->type = UNCONNECTED;
+		} else {
+			debug("lane number %d, has type %d\n", lane, comphy_map_data->type);
+		}
+	}
+	debug_exit();
+}
+
+static u32 comphy_mux_get_mux_value(struct comphy_mux_data *mux_data, enum phy_type type, int lane)
+{
+	struct comphy_mux_options *ptr_mux_opt;
+	int opt;
+	ptr_mux_opt = mux_data->mux_values;
+	for (opt = 0 ; opt < mux_data->max_lane_values; opt++, ptr_mux_opt++)
+		if (ptr_mux_opt->type == type)
+			return ptr_mux_opt->mux_value;
+	return 0;
+}
+
+static void comphy_mux_reg_write(struct comphy_mux_data *mux_data,
+		struct comphy_map *comphy_map_data, int comphy_max_lanes, u32 base_addr, u32 bitcount)
+{
+	u32 lane, value, offset, mask;
+	u32 comphy_selector_base = base_addr + 0xfc;
+
+	debug_enter();
+	for (lane = 0; lane < comphy_max_lanes; lane++, comphy_map_data++, mux_data++) {
+		offset = lane * bitcount;
+		mask = (((1 << bitcount) - 1) << offset);
+		value = (comphy_mux_get_mux_value(mux_data, comphy_map_data->type, lane) << offset);
+		reg_set(comphy_selector_base, mask, value);
+	}
+	debug_exit();
+}
+
+static void comphy_mux_init(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_map *comphy_map_data)
+{
+	struct comphy_mux_data *mux_data;
+	u32 comphy_base, mux_bitcount;
+	u32 comphy_max_lanes;
+
+	debug_enter();
+
+	comphy_max_lanes = ptr_chip_cfg->comphy_lanes_count;
+	mux_data = ptr_chip_cfg->mux_data;
+	comphy_base = ptr_chip_cfg->comphy_base_addr;
+	mux_bitcount = ptr_chip_cfg->comphy_mux_bitcount;
+
+	/* check if the configuration is valid */
+	comphy_mux_check_config(mux_data, comphy_map_data, comphy_max_lanes);
+	/* Init COMPHY selectors */
+	comphy_mux_reg_write(mux_data, comphy_map_data, comphy_max_lanes, comphy_base, mux_bitcount);
+
+	debug_exit();
+}
+
+static int comphy_pcie_power_up(u32 lane, u32 pex_index, u32 comphy_addr, u32 hpipe_addr)
+{
+	debug_enter();
+
+	comphy_pcie_unit_general_config(pex_index);
+
+	/* power up sequence */
+	debug("**** start of PCIe comphy power up sequence ****\n");
+	reg_set(comphy_addr + COMMON_PHY_CONFIGURATION1_REG, 0x3FC7F806, 0x4471804);
+	reg_set(comphy_addr + COMMON_PHY_CONFIGURATION2_REG, 0x5C, 0x58);
+	reg_set(comphy_addr + COMMON_PHY_CONFIGURATION4_REG, 0x3, 0x1);
+	reg_set(comphy_addr + COMMON_PHY_CONFIGURATION1_REG, 0x7800, 0x6000);
+	reg_set(hpipe_addr + HPIPE_GLOBAL_CLK_CTRL, 0x3D, 0x35);
+	reg_set(hpipe_addr + HPIPE_GLOBAL_MISC_CTRL, 0xC0, 0x0);
+	reg_set(hpipe_addr + HPIPE_MISC_REG, 0x4C0, 0x80);
+	udelay(20);
+
+	/* TODO: Add configuration for 20Mhz */
+	/* configuration seq for REF_CLOCK_100MHz */
+	debug("**** start of PCIe comphy ref clock configuration ****\n");
+	reg_set(hpipe_addr + HPIPE_POWER_AND_PLL_CTRL_REG, 0x1F, 0x0);
+	reg_set(hpipe_addr + HPIPE_MISC_REG, 0x400, 0x0);
+	reg_set(hpipe_addr + HPIPE_GLOBAL_PM_CTRL, 0xFF, 0x1E);
+	reg_set(hpipe_addr + HPIPE_INTERFACE_REG, 0xC00, 0x400);
+	udelay(20);
+
+	/* PEX - electrical configuration seq */
+	debug("**** start of PCIe electrical configuration sequence ****\n");
+	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_0_REG, 0xF000, 0xB000);
+	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_1_REG, 0x3FF, 0x3C9);
+	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_3_REG, 0xFF, 0xCF);
+	reg_set(hpipe_addr + HPIPE_G2_SETTINGS_1_REG, 0x3FF, 0x3C9);
+	reg_set(hpipe_addr + HPIPE_G2_SETTINGS_3_REG, 0xFF, 0xAF);
+	reg_set(hpipe_addr + HPIPE_G2_SETTINGS_4_REG, 0x300, 0x300);
+	reg_set(hpipe_addr + HPIPE_DFE_REG0, 0x8000, 0x8000);
+	reg_set(hpipe_addr + HPIPE_PCIE_REG1, 0xF80, 0xD00);
+	reg_set(hpipe_addr + HPIPE_PCIE_REG3, 0xFF00, 0xAF00);
+	reg_set(hpipe_addr + HPIPE_LANE_CFG4_REG, 0x8, 0x8);
+	reg_set(hpipe_addr + HPIPE_VTHIMPCAL_CTRL_REG, 0xFF00, 0x3000);
+	udelay(20);
+
+	/* PEX - TX configuration sequence 2 */
+	debug("**** start of PCIe TX configuration sequence 2 ****\n");
+	reg_set(hpipe_addr + HPIPE_RESET_DFE_REG, 0x401, 0x401);
+	udelay(20);
+
+	/* PEX - TX configuration sequence 3 */
+	debug("**** start of PCIe TX configuration sequence 3 ****\n");
+	reg_set(hpipe_addr + HPIPE_RESET_DFE_REG, 0x401, 0x0);
+	udelay(20000);
+	reg_set(hpipe_addr + HPIPE_RX_REG3, 0xFF, 0xDC);
+	reg_set(hpipe_addr + HPIPE_RX_REG3, 0x100, 0x100);
+	reg_set(hpipe_addr + HPIPE_RX_REG3, 0x100, 0x0);
+
+	/* PEX - TX configuration sequence 1 */
+	debug("**** start of PCIe TX configuration sequence 1 ****\n");
+	reg_set(hpipe_addr + HPIPE_GLOBAL_CLK_CTRL, 0x1, 0x0);
+	udelay(20000);
+
+	debug_exit();
+	return 0;
+}
+
+int comphy_a38x_init(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_map *serdes_map)
+{
+	struct comphy_map *ptr_comphy_map;
+	u32 comphy_base_addr, hpipe3_base_addr;
+	u32 comphy_max_count, lane;
+	bool is_pex_enabled = false;
+
+	debug_enter();
+
+	/* PHY mux initialize */
+	ptr_chip_cfg->mux_data = a38x_comphy_mux_data;
+	if (ptr_chip_cfg->comphy_base_addr != 0)
+		comphy_mux_init(ptr_chip_cfg, serdes_map);
+
+	comphy_max_count = ptr_chip_cfg->comphy_lanes_count;
+	comphy_base_addr = ptr_chip_cfg->comphy_base_addr;
+	hpipe3_base_addr = ptr_chip_cfg->hpipe3_base_addr;
+	for (lane = 0, ptr_comphy_map = serdes_map; lane < comphy_max_count; lane++, ptr_comphy_map++) {
+		debug("Initialize serdes number %d\n", lane);
+		debug("Serdes type = 0x%x\n", ptr_comphy_map->type);
+		switch (ptr_comphy_map->type) {
+		case UNCONNECTED:
+			continue;
+			break;
+		case PEX0:
+		case PEX1:
+		case PEX2:
+		case PEX3:
+			is_pex_enabled = true;
+			/* TODO: add support for PEX by4 initialization */
+			comphy_pcie_power_up(lane, ptr_comphy_map->type - PEX0,
+					comphy_base_addr + 0x28 * lane, hpipe3_base_addr + 0x800 * lane);
+			udelay(20);
+			break;
+		default:
+			debug("Unknown SerDes type, skip initialize SerDes %d\n", lane);
+			break;
+		}
+	}
+
+	if (is_pex_enabled) {
+		/* PEX unit configuration set */
+		comphy_pcie_config_set(comphy_max_count, serdes_map);
+		comphy_pcie_config_detect(comphy_max_count, serdes_map);
+	}
+
+	debug_exit();
+	return 0;
+}
diff --git a/drivers/phy/comphy_core.c b/drivers/phy/comphy_core.c
index 0811049..6ca835d 100644
--- a/drivers/phy/comphy_core.c
+++ b/drivers/phy/comphy_core.c
@@ -25,86 +25,18 @@
 
 #define COMPHY_MAX_CHIP 4
 
-struct comphy_mux_options {
-	enum phy_type type;
-	u32 mux_value;
-};
-
-struct comphy_mux_data {
-	u32 max_lane_values;
-	struct comphy_mux_options mux_values[MAX_LANE_OPTIONS];
-};
-
-struct comphy_mux_data a38x_comphy_mux_data[] = {
-	{4, {{UNCONNECTED, 0x0}, {PEX0, 0x1}, {SATA0, 0x2}, {SGMII0, 0x3} } },
-	{8, {{UNCONNECTED, 0x0}, {PEX0, 0x1}, {PEX0, 0x2}, {SATA0, 0x3},
-		{SGMII0, 0x4}, {SGMII1, 0x5}, {USB3_HOST0, 0x6}, {QSGMII, 0x7} } },
-	{5, {{UNCONNECTED, 0x0}, {PEX1, 0x1}, {PEX0, 0x2}, {SATA1, 0x3}, {SGMII1, 0x4} } },
-	{7, {{UNCONNECTED, 0x0}, {PEX3, 0x1}, {PEX0, 0x2}, {SATA3, 0x3}, {SGMII2, 0x4},
-		{USB3_HOST0, 0x5}, {USB3_DEVICE, 0x6} } },
-	{7, {{UNCONNECTED, 0x0}, {PEX1, 0x1}, {SATA1, 0x2}, {SGMII1, 0x3}, {USB3_HOST0, 0x4},
-		{USB3_DEVICE, 0x5}, {SATA2, 0x6} } },
-	{6, {{UNCONNECTED, 0x0}, {PEX2, 0x1}, {SATA2, 0x2}, {SGMII2, 0x3}, {USB3_HOST1, 0x4},
-		{USB3_DEVICE, 0x5} } },
-};
-
-struct comphy_mux_data ap806_comphy_mux_data[] = {
-	{4, {{UNCONNECTED, 0x0}, {PEX0, 0x1}, {SATA0, 0x2}, {SGMII0, 0x3} } },
-	{8, {{UNCONNECTED, 0x0}, {PEX0, 0x1}, {PEX0, 0x2}, {SATA0, 0x3},
-		{SGMII0, 0x4}, {SGMII1, 0x5}, {USB3_HOST0, 0x6}, {QSGMII, 0x7} } },
-	{5, {{UNCONNECTED, 0x0}, {PEX1, 0x1}, {PEX0, 0x2}, {SATA1, 0x3}, {SGMII1, 0x4} } },
-	{7, {{UNCONNECTED, 0x0}, {PEX3, 0x1}, {PEX0, 0x2}, {SATA3, 0x3}, {SGMII2, 0x4},
-		{USB3_HOST0, 0x5}, {USB3_DEVICE, 0x6} } },
-	{7, {{UNCONNECTED, 0x0}, {PEX1, 0x1}, {SATA1, 0x2}, {SGMII1, 0x3}, {USB3_HOST0, 0x4},
-		{USB3_DEVICE, 0x5}, {SATA2, 0x6} } },
-	{6, {{UNCONNECTED, 0x0}, {PEX2, 0x1}, {SATA2, 0x2}, {SGMII2, 0x3}, {USB3_HOST1, 0x4},
-		{USB3_DEVICE, 0x5} } },
-};
-
-struct comphy_mux_data cp110_comphy_mux_data[] = {
-	{4, {{UNCONNECTED, 0x0}, {PEX0, 0x1}, {SATA0, 0x2}, {SGMII0, 0x3} } },
-	{8, {{UNCONNECTED, 0x0}, {PEX0, 0x1}, {PEX0, 0x2}, {SATA0, 0x3},
-		{SGMII0, 0x4}, {SGMII1, 0x5}, {USB3_HOST0, 0x6}, {QSGMII, 0x7} } },
-	{5, {{UNCONNECTED, 0x0}, {PEX1, 0x1}, {PEX0, 0x2}, {SATA1, 0x3}, {SGMII1, 0x4} } },
-	{7, {{UNCONNECTED, 0x0}, {PEX3, 0x1}, {PEX0, 0x2}, {SATA3, 0x3}, {SGMII2, 0x4},
-		{USB3_HOST0, 0x5}, {USB3_DEVICE, 0x6} } },
-	{7, {{UNCONNECTED, 0x0}, {PEX1, 0x1}, {SATA1, 0x2}, {SGMII1, 0x3}, {USB3_HOST0, 0x4},
-		{USB3_DEVICE, 0x5}, {SATA2, 0x6} } },
-	{6, {{UNCONNECTED, 0x0}, {PEX2, 0x1}, {SATA2, 0x2}, {SGMII2, 0x3}, {USB3_HOST1, 0x4},
-		{USB3_DEVICE, 0x5} } },
-};
-
-struct chip_serdes_phy_config {
-	enum fdt_compat_id compat;
-	struct comphy_mux_data *mux_data;
-	int (*ptr_serdes_phy_power_up)(struct chip_serdes_phy_config *, struct comphy_map *);
-	u32 comphy_base_addr;
-	u32 hpipe3_base_addr;
-	u32 comphy_lanes_count;
-	u32 comphy_mux_bitcount;
-};
-
-static int comphy_rev_2_1_power_up(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_map *comphy_map_data)
-{
-	printf("COMPHY power up sequence revision 2.1\n");
-	return 0;
-}
-
 struct chip_serdes_phy_config chip_config[] = {
 #ifdef CONFIG_TARGET_ARMADA_38X
 	{.compat = COMPAT_COMPHY_ARMADA_38X,
-	 .mux_data = a38x_comphy_mux_data,
-	 .ptr_serdes_phy_power_up = comphy_rev_2_1_power_up },
+	 .ptr_comphy_chip_init = comphy_a38x_init },
 #endif
 #ifdef CONFIG_TARGET_ARMADA_8K
 	{.compat = COMPAT_COMPHY_AP806,
-	 .mux_data = ap806_comphy_mux_data,
-	 .ptr_serdes_phy_power_up = comphy_rev_2_1_power_up },
+	 .ptr_comphy_chip_init = comphy_ap806_init },
 #endif
 #ifdef CONFIG_TARGET_CP110
 	{.compat = CP110,
-	 .mux_data = cp110_comphy_mux_data,
-	 .ptr_serdes_phy_power_up = comphy_rev_3_1_power_up },
+	 .ptr_comphy_chip_init = comphy_cp110_init },
 #endif
 	{.compat = COMPAT_UNKNOWN}
 };
@@ -141,89 +73,6 @@ static char *get_type_string(enum phy_type type)
 	return type_strings[type];
 }
 
-/* comphy_mux_check_config
- * description: this function passes over the COMPHY lanes and check if the type
- *              is valid for specific lane. If the type is not valid, the function
- *              update the struct and set the type of the lane as UNCONNECTED */
-static void comphy_mux_check_config(struct comphy_mux_data *mux_data,
-		struct comphy_map *comphy_map_data, int comphy_max_lanes)
-{
-	struct comphy_mux_options *ptr_mux_opt;
-	int lane, opt, valid;
-	debug_enter();
-
-	for (lane = 0; lane < comphy_max_lanes; lane++, comphy_map_data++, mux_data++) {
-		ptr_mux_opt = mux_data->mux_values;
-		for (opt = 0, valid = 0; opt < mux_data->max_lane_values; opt++, ptr_mux_opt++) {
-			if (ptr_mux_opt->type == comphy_map_data->type) {
-				valid = 1;
-				break;
-			}
-		}
-		if (valid == 0) {
-			debug("lane number %d, had invalid type %d\n", lane, comphy_map_data->type);
-			debug("set lane %d as type %d\n", lane, UNCONNECTED);
-			comphy_map_data->type = UNCONNECTED;
-		} else {
-			debug("lane number %d, has type %d\n", lane, comphy_map_data->type);
-		}
-	}
-	debug_exit();
-}
-
-static u32 comphy_mux_get_mux_value(struct comphy_mux_data *mux_data, enum phy_type type, int lane)
-{
-	struct comphy_mux_options *ptr_mux_opt;
-	int opt;
-	ptr_mux_opt = mux_data->mux_values;
-	for (opt = 0 ; opt < mux_data->max_lane_values; opt++, ptr_mux_opt++)
-		if (ptr_mux_opt->type == type)
-			return ptr_mux_opt->mux_value;
-	return 0;
-}
-
-static void comphy_mux_reg_write(struct comphy_mux_data *mux_data,
-		struct comphy_map *comphy_map_data, int comphy_max_lanes, u32 base_addr, u32 bitcount)
-{
-	u32 lane, reg_val;
-	u32 value, offset, mask;
-	u32 comphy_selector_base = base_addr + 0xfc;
-
-	for (lane = 0; lane < comphy_max_lanes; lane++, comphy_map_data++, mux_data++) {
-		offset = lane * bitcount;
-		mask = (((1 << bitcount) - 1) << offset);
-		value = (comphy_mux_get_mux_value(mux_data, comphy_map_data->type, lane) << offset);
-		reg_val = readl(comphy_selector_base);
-		debug("Write to address = %#010x, data = %#010x (mask = %#010x) - ", comphy_selector_base, value, mask);
-		debug("old value = %#010x ==> ", readl(comphy_selector_base));
-		reg_val &= ~mask;
-		reg_val |= value;
-		writel(reg_val, comphy_selector_base);
-		debug("new value %#010x\n", readl(comphy_selector_base));
-	}
-}
-
-static void comphy_mux_init(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_map *comphy_map_data)
-{
-	struct comphy_mux_data *mux_data;
-	u32 comphy_base, mux_bitcount;
-	u32 comphy_max_lanes;
-
-	debug_enter();
-
-	comphy_max_lanes = ptr_chip_cfg->comphy_lanes_count;
-	mux_data = ptr_chip_cfg->mux_data;
-	comphy_base = ptr_chip_cfg->comphy_base_addr;
-	mux_bitcount = ptr_chip_cfg->comphy_mux_bitcount;
-
-	/* check if the configuration is valid */
-	comphy_mux_check_config(mux_data, comphy_map_data, comphy_max_lanes);
-	/* Init COMPHY selectors */
-	comphy_mux_reg_write(mux_data, comphy_map_data,	comphy_max_lanes, comphy_base, mux_bitcount);
-
-	debug_exit();
-}
-
 void comphy_print(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_map *comphy_map_data)
 {
 	u32 lane;
@@ -309,14 +158,10 @@ u32 comphy_init(const void *blob)
 			lane++;
 		}
 
-		/* PHY mux initialize */
-		if (ptr_chip_cfg->comphy_base_addr != 0)
-			comphy_mux_init(ptr_chip_cfg, comphy_map_data);
-
 		/* PHY print SerDes status */
 		comphy_print(ptr_chip_cfg, comphy_map_data);
 		/* PHY power UP sequence */
-		ptr_chip_cfg->ptr_serdes_phy_power_up(ptr_chip_cfg, comphy_map_data);
+		ptr_chip_cfg->ptr_comphy_chip_init(ptr_chip_cfg, comphy_map_data);
 	}
 	debug_exit();
 
diff --git a/drivers/phy/comphy_pcie_config.c b/drivers/phy/comphy_pcie_config.c
new file mode 100644
index 0000000..fbeba1e
--- /dev/null
+++ b/drivers/phy/comphy_pcie_config.c
@@ -0,0 +1,254 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+/*#define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/comphy.h>
+#include <asm/arch-mvebu/mvebu.h>
+
+#define SOC_CONTROL_REG                         0xd0018204
+
+#define MV_PEX_IF_REGS_OFFSET(pex_if)			(pex_if > 0 ? (0x40000 + (pex_if-1)*0x4000) : 0x80000)
+#define MV_PEX_IF_REGS_BASE(unit)				(0xd0000000 + MV_PEX_IF_REGS_OFFSET(unit))
+#define PEX_CAPABILITIES_REG(pex_if)			((MV_PEX_IF_REGS_BASE(pex_if)) + 0x60)
+#define PEX_LINK_CAPABILITIES_REG(pex_if)		((MV_PEX_IF_REGS_BASE(pex_if)) + 0x6C)
+#define PEX_LINK_CTRL_STATUS_REG(pex_if)		((MV_PEX_IF_REGS_BASE(pex_if)) + 0x70)
+#define PEX_LINK_CTRL_STATUS2_REG(pex_if)        ((MV_PEX_IF_REGS_BASE(pex_if)) + 0x90)
+#define PEX_CTRL_REG(pex_if)                     ((MV_PEX_IF_REGS_BASE(pex_if)) + 0x1A00)
+#define PEX_STATUS_REG(pex_if)                   ((MV_PEX_IF_REGS_BASE(pex_if)) + 0x1A04)
+#define PEX_DBG_STATUS_REG(pex_if)               ((MV_PEX_IF_REGS_BASE(pex_if)) + 0x1A64)
+#define PEX_CFG_ADDR_REG(pex_if)                 ((MV_PEX_IF_REGS_BASE(pex_if)) + 0x18F8)
+#define PEX_CFG_DATA_REG(pex_if)                 ((MV_PEX_IF_REGS_BASE(pex_if)) + 0x18FC)
+#define PEX_CFG_DIRECT_ACCESS(pex_if, cfg_reg)    (MV_PEX_IF_REGS_BASE(pex_if) + (cfg_reg))
+#define PEX_LINK_CAPABILITY_REG                 0x6C
+#define PEX_LINK_CTRL_STAT_REG                  0x70
+#define PXSR_PEX_DEV_NUM_OFFS                   16  /* Device Number Indication */
+#define PXSR_PEX_DEV_NUM_MASK                   (0x1f << PXSR_PEX_DEV_NUM_OFFS)
+#define PXSR_PEX_BUS_NUM_OFFS                   8 /* Bus Number Indication */
+#define PXSR_PEX_BUS_NUM_MASK                   (0xff << PXSR_PEX_BUS_NUM_OFFS)
+
+/* PEX_CAPABILITIES_REG fields */
+#define PCIE0_ENABLE_OFFS                       0
+#define PCIE0_ENABLE_MASK                       (0x1 << PCIE0_ENABLE_OFFS)
+#define PCIE1_ENABLE_OFFS                       1
+#define PCIE1_ENABLE_MASK                       (0x1 << PCIE1_ENABLE_OFFS)
+#define PCIE2_ENABLE_OFFS                       2
+#define PCIE2_ENABLE_MASK                       (0x1 << PCIE2_ENABLE_OFFS)
+#define PCIE3_ENABLE_OFFS                       3
+#define PCIE4_ENABLE_MASK                       (0x1 << PCIE3_ENABLE_OFFS)
+
+/* PCI Express Configuration Address Register */
+#define PXCAR_REG_NUM_OFFS                      2
+#define PXCAR_REG_NUM_MAX                       0x3F
+#define PXCAR_REG_NUM_MASK                      (PXCAR_REG_NUM_MAX << PXCAR_REG_NUM_OFFS)
+#define PXCAR_FUNC_NUM_OFFS                     8
+#define PXCAR_FUNC_NUM_MAX                      0x7
+#define PXCAR_FUNC_NUM_MASK                     (PXCAR_FUNC_NUM_MAX << PXCAR_FUNC_NUM_OFFS)
+#define PXCAR_DEVICE_NUM_OFFS                   11
+#define PXCAR_DEVICE_NUM_MAX                    0x1F
+#define PXCAR_DEVICE_NUM_MASK                   (PXCAR_DEVICE_NUM_MAX << PXCAR_DEVICE_NUM_OFFS)
+#define PXCAR_BUS_NUM_OFFS                      16
+#define PXCAR_BUS_NUM_MAX                       0xFF
+#define PXCAR_BUS_NUM_MASK                      (PXCAR_BUS_NUM_MAX << PXCAR_BUS_NUM_OFFS)
+#define PXCAR_EXT_REG_NUM_OFFS                  24
+#define PXCAR_EXT_REG_NUM_MAX                   0xF
+
+#define PXCAR_REAL_EXT_REG_NUM_OFFS             8
+#define PXCAR_REAL_EXT_REG_NUM_MASK             (0xF << PXCAR_REAL_EXT_REG_NUM_OFFS)
+
+#define PXCAR_CONFIG_EN                         (0x1 << 31)
+#define PEX_STATUS_AND_COMMAND                  0x004
+
+static u32 pex_config_read(u32 pex_index, u32 bus, u32 dev, u32 func, u32 reg_off)
+{
+	u32 pex_data, pex_status, temp_data;
+	u32 locat_dev, local_bus;
+
+	pex_status = readl(PEX_STATUS_REG(pex_index));
+	locat_dev = (pex_status & PXSR_PEX_DEV_NUM_MASK) >> PXSR_PEX_DEV_NUM_OFFS;
+	local_bus = (pex_status & PXSR_PEX_BUS_NUM_MASK) >> PXSR_PEX_BUS_NUM_OFFS;
+
+	/* in PCI Express we have only one device number */
+	/* and this number is the first number we encounter else that the localDev */
+	/* spec pex define return on config read/write on any device */
+
+	if (bus == local_bus) {
+		if (local_bus == 0) {
+			/* if local dev is 0 then the first number we encounter after 0 is 1 */
+			if ((dev != 1) && (dev != locat_dev))
+				return -1;
+		} else {
+			/* if local dev is not 0 then the first number we encounter is 0 */
+			if ((dev != 0) && (dev != locat_dev))
+				return -1;
+		}
+	}
+
+	/* Creating PEX address to be passed */
+	pex_data = (bus << PXCAR_BUS_NUM_OFFS);
+	pex_data |= (dev << PXCAR_DEVICE_NUM_OFFS);
+	pex_data |= (func << PXCAR_FUNC_NUM_OFFS);
+	pex_data |= (reg_off & PXCAR_REG_NUM_MASK); /* lgacy register space */
+	/* extended register space */
+	pex_data |= ((reg_off & PXCAR_REAL_EXT_REG_NUM_MASK)
+				>> PXCAR_REAL_EXT_REG_NUM_OFFS) << PXCAR_EXT_REG_NUM_OFFS;
+	pex_data |= PXCAR_CONFIG_EN;
+
+	/* Write the address to the PEX configuration address register */
+	writel(pex_data, PEX_CFG_ADDR_REG(pex_index));
+
+	/* In order to let the PEX controller absorbed the address of the read  */
+	/* transaction we perform a validity check that the address was written */
+	if (pex_data != readl(PEX_CFG_ADDR_REG(pex_index)))
+		return -1;
+
+	/* cleaning Master Abort */
+	temp_data = readl(PEX_CFG_DIRECT_ACCESS(pex_index, PEX_STATUS_AND_COMMAND));
+	temp_data &= ~(0x1 << 29);
+	temp_data |= (0x1 << 29);
+	writel(temp_data, PEX_CFG_DIRECT_ACCESS(pex_index, PEX_STATUS_AND_COMMAND));
+	/* Read the Data returned in the PEX Data register */
+	pex_data = readl(PEX_CFG_DATA_REG(pex_index));
+
+	debug("%s: return address 0x%x", __func__, pex_data);
+
+	return pex_data;
+}
+
+void comphy_pcie_config_set(u32 comphy_max_count, struct comphy_map *serdes_map)
+{
+	u32 pex_index, lane;
+	u32 pex_enable_offs = 0;
+
+	debug_enter();
+	for (lane = 0; lane < comphy_max_count; lane++, serdes_map++) {
+		if (serdes_map->type < PEX0 || serdes_map->type > PEX3)
+			continue;
+		pex_index = serdes_map->type - PEX0;
+		reg_set(PEX_CAPABILITIES_REG(pex_index), 0xf << 20, 0x4 << 20);
+
+		switch (serdes_map->type) {
+		case PEX0:
+			pex_enable_offs |= 0x1 << PCIE0_ENABLE_OFFS;
+			break;
+		case PEX1:
+			pex_enable_offs |= 0x1 << PCIE1_ENABLE_OFFS;
+			break;
+		case PEX2:
+			pex_enable_offs |= 0x1 << PCIE2_ENABLE_OFFS;
+			break;
+		case PEX3:
+			pex_enable_offs |= 0x1 << PCIE3_ENABLE_OFFS;
+			break;
+		default:
+			break;
+		}
+	}
+	reg_set(SOC_CONTROL_REG, 0x3, pex_enable_offs);
+	udelay(10000);
+
+	debug_exit();
+}
+
+void comphy_pcie_config_detect(u32 comphy_max_count, struct comphy_map *serdes_map)
+{
+	u32 pex_index, lane;
+	u32 next_bus, first_bus, reg_data, addr;
+
+	debug_enter();
+	next_bus = 0;
+	for (lane = 0; lane < comphy_max_count; lane++, serdes_map++) {
+		if (serdes_map->type < PEX0 || serdes_map->type > PEX3)
+			continue;
+		pex_index = serdes_map->type - PEX0;
+		first_bus = next_bus;
+		reg_data = readl(PEX_DBG_STATUS_REG(pex_index));
+
+		if ((reg_data & 0x7f) != 0x7e) {
+			printf("PCIe - %d: detected no link\n", pex_index);
+			continue;
+		}
+
+		next_bus++;
+		reg_data = readl(PEX_CFG_DIRECT_ACCESS(pex_index, PEX_LINK_CAPABILITY_REG)) & 0xf;
+
+		if (reg_data != 0x2) {
+			printf("PCIe - %d: detected no link\n", pex_index);
+			continue;
+		}
+
+		reg_data = (readl(PEX_CFG_DIRECT_ACCESS(pex_index, PEX_LINK_CTRL_STAT_REG)) & 0xF0000) >> 16;
+		debug("Checking if the link established is gen1\n");
+		if (reg_data != 0x1) {
+			printf("PCIe - %d: detected no link\n", pex_index);
+			continue;
+		}
+
+		reg_data = (first_bus << PXSR_PEX_BUS_NUM_OFFS) & PXSR_PEX_BUS_NUM_MASK;
+		reg_set(PEX_STATUS_REG(pex_index), PXSR_PEX_BUS_NUM_MASK, reg_data);
+		reg_data = (1 << PXSR_PEX_DEV_NUM_OFFS) & PXSR_PEX_DEV_NUM_MASK;
+		reg_set(PEX_STATUS_REG(pex_index), PXSR_PEX_DEV_NUM_MASK, reg_data);
+		printf("PCIe - %d: Link is Gen1, check the EP capability\n", pex_index);
+
+		/* link is Gen1, check the EP capability */
+		addr = pex_config_read(pex_index, first_bus, 0, 0, 0x34) & 0xff;
+		if (addr == 0xff) {
+			printf("PCIe - %d: remains Gen1.\n", pex_index);
+			continue;
+		}
+
+		while ((pex_config_read(pex_index, first_bus, 0, 0, addr) & 0xFF) != 0x10)
+			addr = (pex_config_read(pex_index, first_bus, 0, 0, addr) & 0xFF00) >> 8;
+
+		/* check for Gen2 and above */
+		if ((pex_config_read(pex_index, first_bus, 0, 0, addr + 0xC) & 0xF) >= 0x2) {
+			reg_data = readl(PEX_LINK_CTRL_STATUS2_REG(pex_index));
+			reg_data &= ~(0x3);
+			reg_data |= 0x42;
+			writel(reg_data, PEX_LINK_CTRL_STATUS2_REG(pex_index));
+			reg_data = readl(PEX_CTRL_REG(pex_index));
+			reg_data |= (0x1 << 10);
+			writel(reg_data, PEX_CTRL_REG(pex_index));
+			/* We need to wait 10ms before reading the PEX_DBG_STATUS_REG in order not
+			   to read the status of the former state*/
+			udelay(10000);
+			printf("PCIe - %d: Link upgraded to Gen2 based on client cpabilities\n", pex_index);
+		} else {
+			printf("PCIe - %d: remains Gen1\n", pex_index);
+		}
+	}
+	debug_exit();
+}
+
+void comphy_pcie_unit_general_config(u32 pex_index)
+{
+	debug_enter();
+
+	debug("**** start of general configuration for PCIe comphy ****\n");
+	/* the following should be done for PEXx1 and for PEX by 4-for the first lane only */
+	reg_set(SOC_CONTROL_REG, 0x4000, 0x4000);
+	/* Setup link width bit[9:4] */
+	reg_set(PEX_LINK_CAPABILITIES_REG(pex_index), 0x3F0, 0x10);
+	/* Setup maximum link speed bit[3:0] */
+	reg_set(PEX_LINK_CAPABILITIES_REG(pex_index), 0xF, 0x2);
+	/* Setup common clock configuration bit[6] */
+	reg_set(PEX_LINK_CTRL_STATUS_REG(pex_index), 0x40, 0x40);
+
+	debug_exit();
+}
-- 
1.9.1

