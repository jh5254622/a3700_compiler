From 7e4cc10e528ccd70b56efb4315a03f7974f31525 Mon Sep 17 00:00:00 2001
From: Neta Zur <neta@marvell.com>
Date: Mon, 27 Jul 2015 09:04:09 +0300
Subject: [PATCH 0264/1240] ahci: Fix compiling warnings under 64bit platforms

When compling under 64bit platforms, there are lots of warnings,
like:

drivers/block/ahci.c:114:18: warning: cast to pointer from integer
 of different size [-Wint-to-pointer-cast]
  u8 *port_mmio = (u8 *)probe_ent->port[port].port_mmio;
                  ^
drivers/block/ahci.c: In function ?.hci_host_init?.
drivers/block/ahci.c:218:49: warning: cast from pointer to integer
 of different size [-Wpointer-to-int-cast]
   probe_ent->port[i].port_mmio = ahci_port_base((u32) mmio, i);

......

Change-Id: If44c4e1dbe9dcc1563920dafd4494af77818ec25
Reviewed-by: Simon Glass <sjg@chromium.org>
Signed-off-by: Shaohui Xie <Shaohui.Xie@freescale.com>
Signed-off-by: Tang Yuantian <Yuantian.Tang@freescale.com>
Signed-off-by: Neta Zur <neta@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/22178
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
---
 drivers/block/ahci.c       | 63 +++++++++++++++++++++++++---------------------
 drivers/block/dwc_ahsata.c | 15 ++++++-----
 include/ahci.h             |  8 +++---
 3 files changed, 47 insertions(+), 39 deletions(-)

diff --git a/drivers/block/ahci.c b/drivers/block/ahci.c
index d5a0075..4109ad0 100644
--- a/drivers/block/ahci.c
+++ b/drivers/block/ahci.c
@@ -43,13 +43,13 @@ u16 *ataid[AHCI_MAX_PORTS];
 #define WAIT_MS_FLUSH	5000
 #define WAIT_MS_LINKUP	200
 
-static inline u32 ahci_port_base(u32 base, u32 port)
+static inline void __iomem *ahci_port_base(void __iomem *base, u32 port)
 {
 	return base + 0x100 + (port * 0x80);
 }
 
 
-static void ahci_setup_port(struct ahci_ioports *port, unsigned long base,
+static void ahci_setup_port(struct ahci_ioports *port, void __iomem *base,
 			    unsigned int port_idx)
 {
 	base = ahci_port_base(base, port_idx);
@@ -61,7 +61,7 @@ static void ahci_setup_port(struct ahci_ioports *port, unsigned long base,
 
 #define msleep(a) udelay(a * 1000)
 
-static void ahci_dcache_flush_range(unsigned begin, unsigned len)
+static void ahci_dcache_flush_range(unsigned long begin, unsigned long len)
 {
 	const unsigned long start = begin;
 	const unsigned long end = start + len;
@@ -75,7 +75,7 @@ static void ahci_dcache_flush_range(unsigned begin, unsigned len)
  * controller is invalidated from dcache; next access comes from
  * physical RAM.
  */
-static void ahci_dcache_invalidate_range(unsigned begin, unsigned len)
+static void ahci_dcache_invalidate_range(unsigned long begin, unsigned long len)
 {
 	const unsigned long start = begin;
 	const unsigned long end = start + len;
@@ -94,7 +94,7 @@ static void ahci_dcache_flush_sata_cmd(struct ahci_ioports *pp)
 				AHCI_PORT_PRIV_DMA_SZ);
 }
 
-static int waiting_for_cmd_completed(volatile u8 *offset,
+static int waiting_for_cmd_completed(void __iomem *offset,
 				     int timeout_msec,
 				     u32 sign)
 {
@@ -111,7 +111,7 @@ int __weak ahci_link_up(struct ahci_probe_ent *probe_ent, u8 port)
 {
 	u32 tmp;
 	int j = 0;
-	u8 *port_mmio = (u8 *)probe_ent->port[port].port_mmio;
+	void __iomem *port_mmio = probe_ent->port[port].port_mmio;
 
 	/*
 	 * Bring up SATA link.
@@ -131,7 +131,7 @@ int __weak ahci_link_up(struct ahci_probe_ent *probe_ent, u8 port)
 
 #ifdef CONFIG_SUNXI_AHCI
 /* The sunxi AHCI controller requires this undocumented setup */
-static void sunxi_dma_init(volatile u8 *port_mmio)
+static void sunxi_dma_init(void __iomem *port_mmio)
 {
 	clrsetbits_le32(port_mmio + PORT_P0DMACR, 0x0000ff00, 0x00004400);
 }
@@ -171,10 +171,10 @@ static int ahci_host_init(struct ahci_probe_ent *probe_ent)
 	u16 tmp16;
 	unsigned short vendor;
 #endif
-	volatile u8 *mmio = (volatile u8 *)probe_ent->mmio_base;
+	void __iomem *mmio = probe_ent->mmio_base;
 	u32 tmp, cap_save, cmd;
 	int i, j, ret;
-	volatile u8 *port_mmio;
+	void __iomem *port_mmio;
 	u32 port_map;
 
 	debug("ahci_host_init: start\n");
@@ -215,9 +215,9 @@ static int ahci_host_init(struct ahci_probe_ent *probe_ent)
 	for (i = 0; i < probe_ent->n_ports; i++) {
 		if (!(port_map & (1 << i)))
 			continue;
-		probe_ent->port[i].port_mmio = ahci_port_base((u32) mmio, i);
+		probe_ent->port[i].port_mmio = ahci_port_base(mmio, i);
 		port_mmio = (u8 *) probe_ent->port[i].port_mmio;
-		ahci_setup_port(&probe_ent->port[i], (unsigned long)mmio, i);
+		ahci_setup_port(&probe_ent->port[i], mmio, i);
 
 		/* make sure port is not active */
 		tmp = readl(port_mmio + PORT_CMD);
@@ -329,7 +329,7 @@ static void ahci_print_info(struct ahci_probe_ent *probe_ent)
 	pci_dev_t pdev = probe_ent->dev;
 	u16 cc;
 #endif
-	volatile u8 *mmio = (volatile u8 *)probe_ent->mmio_base;
+	void __iomem *mmio = probe_ent->mmio_base;
 	u32 vers, cap, cap2, impl, speed;
 	const char *speed_s;
 	const char *scc_s;
@@ -462,7 +462,7 @@ static int ahci_fill_sg(u8 port, unsigned char *buf, int buf_len)
 
 	for (i = 0; i < sg_count; i++) {
 		ahci_sg->addr =
-		    cpu_to_le32((u32) buf + i * MAX_DATA_BYTE_COUNT);
+		    cpu_to_le32((unsigned long)buf + i * MAX_DATA_BYTE_COUNT);
 		ahci_sg->addr_hi = 0;
 		ahci_sg->flags_size = cpu_to_le32(0x3fffff &
 					  (buf_len < MAX_DATA_BYTE_COUNT
@@ -480,8 +480,11 @@ static void ahci_fill_cmd_slot(struct ahci_ioports *pp, u32 opts)
 {
 	pp->cmd_slot->opts = cpu_to_le32(opts);
 	pp->cmd_slot->status = 0;
-	pp->cmd_slot->tbl_addr = cpu_to_le32(pp->cmd_tbl & 0xffffffff);
-	pp->cmd_slot->tbl_addr_hi = 0;
+	pp->cmd_slot->tbl_addr = cpu_to_le32((u32)pp->cmd_tbl & 0xffffffff);
+#ifdef CONFIG_PHYS_64BIT
+	pp->cmd_slot->tbl_addr_hi =
+	    cpu_to_le32((u32)(((pp->cmd_tbl) >> 16) >> 16));
+#endif
 }
 
 
@@ -489,7 +492,7 @@ static void ahci_fill_cmd_slot(struct ahci_ioports *pp, u32 opts)
 static void ahci_set_feature(u8 port)
 {
 	struct ahci_ioports *pp = &(probe_ent->port[port]);
-	volatile u8 *port_mmio = (volatile u8 *)pp->port_mmio;
+	void __iomem *port_mmio = pp->port_mmio;
 	u32 cmd_fis_len = 5;	/* five dwords */
 	u8 fis[20];
 
@@ -518,9 +521,9 @@ static void ahci_set_feature(u8 port)
 static int ahci_port_start(u8 port)
 {
 	struct ahci_ioports *pp = &(probe_ent->port[port]);
-	volatile u8 *port_mmio = (volatile u8 *)pp->port_mmio;
+	void __iomem *port_mmio = pp->port_mmio;
 	u32 port_status;
-	u32 mem;
+	void __iomem *mem;
 
 	debug("Enter start port: %d\n", port);
 	port_status = readl(port_mmio + PORT_SCR_STAT);
@@ -530,23 +533,23 @@ static int ahci_port_start(u8 port)
 		return -1;
 	}
 
-	mem = (u32) malloc(AHCI_PORT_PRIV_DMA_SZ + 2048);
+	mem = malloc(AHCI_PORT_PRIV_DMA_SZ + 2048);
 	if (!mem) {
 		free(pp);
 		printf("%s: No mem for table!\n", __func__);
 		return -ENOMEM;
 	}
 
-	mem = (mem + 0x800) & (~0x7ff);	/* Aligned to 2048-bytes */
-	memset((u8 *) mem, 0, AHCI_PORT_PRIV_DMA_SZ);
-
+	/* Aligned to 2048-bytes */
+	mem = memalign(2048, AHCI_PORT_PRIV_DMA_SZ);
+	memset(mem, 0, AHCI_PORT_PRIV_DMA_SZ);
 	/*
 	 * First item in chunk of DMA memory: 32-slot command table,
 	 * 32 bytes each in size
 	 */
 	pp->cmd_slot =
 		(struct ahci_cmd_hdr *)(uintptr_t)virt_to_phys((void *)mem);
-	debug("cmd_slot = 0x%x\n", (unsigned)pp->cmd_slot);
+	debug("cmd_slot = %p\n", pp->cmd_slot);
 	mem += (AHCI_CMD_SLOT_SZ + 224);
 
 	/*
@@ -560,13 +563,14 @@ static int ahci_port_start(u8 port)
 	 * and its scatter-gather table
 	 */
 	pp->cmd_tbl = virt_to_phys((void *)mem);
-	debug("cmd_tbl_dma = 0x%x\n", pp->cmd_tbl);
+	debug("cmd_tbl_dma = %lx\n", pp->cmd_tbl);
 
 	mem += AHCI_CMD_TBL_HDR;
 	pp->cmd_tbl_sg =
 			(struct ahci_sg *)(uintptr_t)virt_to_phys((void *)mem);
 
-	writel_with_flush((u32) pp->cmd_slot, port_mmio + PORT_LST_ADDR);
+	writel_with_flush((unsigned long)pp->cmd_slot,
+			  port_mmio + PORT_LST_ADDR);
 
 	writel_with_flush(pp->rx_fis, port_mmio + PORT_FIS_ADDR);
 
@@ -589,7 +593,7 @@ static int ahci_device_data_io(u8 port, u8 *fis, int fis_len, u8 *buf,
 {
 
 	struct ahci_ioports *pp = &(probe_ent->port[port]);
-	volatile u8 *port_mmio = (volatile u8 *)pp->port_mmio;
+	void __iomem *port_mmio = pp->port_mmio;
 	u32 opts;
 	u32 port_status;
 	int sg_count;
@@ -614,7 +618,7 @@ static int ahci_device_data_io(u8 port, u8 *fis, int fis_len, u8 *buf,
 	ahci_fill_cmd_slot(pp, opts);
 
 	ahci_dcache_flush_sata_cmd(pp);
-	ahci_dcache_flush_range((unsigned)buf, (unsigned)buf_len);
+	ahci_dcache_flush_range((unsigned long)buf, (unsigned long)buf_len);
 
 	writel_with_flush(1, port_mmio + PORT_CMD_ISSUE);
 
@@ -624,7 +628,8 @@ static int ahci_device_data_io(u8 port, u8 *fis, int fis_len, u8 *buf,
 		return -1;
 	}
 
-	ahci_dcache_invalidate_range((unsigned)buf, (unsigned)buf_len);
+	ahci_dcache_invalidate_range((unsigned long)buf,
+				     (unsigned long)buf_len);
 	debug("%s: %d byte transferred.\n", __func__, pp->cmd_slot->status);
 
 	return 0;
@@ -988,7 +993,7 @@ static int ata_io_flush(u8 port)
 {
 	u8 fis[20];
 	struct ahci_ioports *pp = &(probe_ent->port[port]);
-	volatile u8 *port_mmio = (volatile u8 *)pp->port_mmio;
+	void __iomem *port_mmio = pp->port_mmio;
 	u32 cmd_fis_len = 5;	/* five dwords */
 
 	/* Preset the FIS */
diff --git a/drivers/block/dwc_ahsata.c b/drivers/block/dwc_ahsata.c
index cf3ef6b..cbfb276 100644
--- a/drivers/block/dwc_ahsata.c
+++ b/drivers/block/dwc_ahsata.c
@@ -80,7 +80,7 @@ struct sata_host_regs {
 
 static int is_ready;
 
-static inline u32 ahci_port_base(u32 base, u32 port)
+static inline void __iomem *ahci_port_base(void __iomem *base, u32 port)
 {
 	return base + 0x100 + (port * 0x80);
 }
@@ -167,7 +167,7 @@ static int ahci_host_init(struct ahci_probe_ent *probe_ent)
 
 	for (i = 0; i < probe_ent->n_ports; i++) {
 		probe_ent->port[i].port_mmio =
-			ahci_port_base((u32)host_mmio, i);
+			ahci_port_base(host_mmio, i);
 		port_mmio =
 			(struct sata_port_regs *)probe_ent->port[i].port_mmio;
 
@@ -399,9 +399,12 @@ static void ahci_fill_cmd_slot(struct ahci_ioports *pp, u32 cmd_slot, u32 opts)
 	memset(cmd_hdr, 0, AHCI_CMD_SLOT_SZ);
 	cmd_hdr->opts = cpu_to_le32(opts);
 	cmd_hdr->status = 0;
-	cmd_hdr->tbl_addr = cpu_to_le32(pp->cmd_tbl & 0xffffffff);
-	cmd_hdr->tbl_addr_hi = 0;
-}
+	pp->cmd_slot->tbl_addr = cpu_to_le32((u32)pp->cmd_tbl & 0xffffffff);
+#ifdef CONFIG_PHYS_64BIT
+	pp->cmd_slot->tbl_addr_hi =
+	    cpu_to_le32((u32)(((pp->cmd_tbl) >> 16) >> 16));
+
+#endif}
 
 #define AHCI_GET_CMD_SLOT(c) ((c) ? ffs(c) : 0)
 
@@ -520,7 +523,7 @@ static int ahci_port_start(struct ahci_probe_ent *probe_ent,
 	 * and its scatter-gather table
 	 */
 	pp->cmd_tbl = mem;
-	debug("cmd_tbl_dma = 0x%x\n", pp->cmd_tbl);
+	debug("cmd_tbl_dma = 0x%lx\n", pp->cmd_tbl);
 
 	mem += AHCI_CMD_TBL_HDR;
 
diff --git a/include/ahci.h b/include/ahci.h
index 6d91712..0bdedac 100644
--- a/include/ahci.h
+++ b/include/ahci.h
@@ -135,12 +135,12 @@ struct ahci_sg {
 };
 
 struct ahci_ioports {
-	u32	cmd_addr;
-	u32	scr_addr;
-	u32	port_mmio;
+	void __iomem	*cmd_addr;
+	void __iomem	*scr_addr;
+	void __iomem	*port_mmio;
 	struct ahci_cmd_hdr	*cmd_slot;
 	struct ahci_sg		*cmd_tbl_sg;
-	u32	cmd_tbl;
+	ulong	cmd_tbl;
 	u32	rx_fis;
 };
 
-- 
1.9.1

