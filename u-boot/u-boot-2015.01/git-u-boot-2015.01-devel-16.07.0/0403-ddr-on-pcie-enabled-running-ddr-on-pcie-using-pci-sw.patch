From 35afb4776193f945ac43e6507fbc40bb6454009a Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Thu, 3 Sep 2015 10:42:22 +0300
Subject: [PATCH 0403/1240] ddr-on-pcie: enabled running ddr-on-pcie using pci
 switch

This patch allows working with DDR on PCIe over a PCI switch
To allow this we:
- modify the BAR fixup in SPL to account for the new bus and device IDs
  caused by the switch topology
- fix the pci driver to maintian some switch configurations during
  u-boot scan
- Skip the DRAM controller during cfg cycle to retain it's configuration

We also shift the entire bus numbering to start at 1 to be compatible
with linux. linux mvebu_pci driver uses a virtual SW bridge that occupies
bus 0 so our PCI controller moves to bus 1. to avoid changing the bus number
in linux (which stops DDR access) we shift the first bus number to 1 in
u-boot.

Change-Id: I349c8a1e1c5c5cf5b1dfae78ccdc3efdb99e7460
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/23402
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
---
 arch/arm/cpu/mvebu-common/dram_over_pci.c | 26 ++++++++++++++++------
 drivers/pci/pci_mvebu.c                   | 36 +++++++++++++++++++++++++++----
 2 files changed, 51 insertions(+), 11 deletions(-)

diff --git a/arch/arm/cpu/mvebu-common/dram_over_pci.c b/arch/arm/cpu/mvebu-common/dram_over_pci.c
index 1760ca7..eed508e 100644
--- a/arch/arm/cpu/mvebu-common/dram_over_pci.c
+++ b/arch/arm/cpu/mvebu-common/dram_over_pci.c
@@ -123,6 +123,7 @@ void dram_over_pci_init(const void *fdt_blob)
 {
 	int linkup_timeout_ms = 1000;
 	struct pci_controller *hose;
+	pci_dev_t bdf;
 
 	dram_over_pci_window_config();
 
@@ -146,13 +147,24 @@ void dram_over_pci_init(const void *fdt_blob)
 
 	pci_init();
 
-	/* set device PCIE bars:
+	/* open 0 - 2G for address space beyound the main switch */
+	hose = pci_bus_to_hose(1);
+	bdf  = PCI_BDF(1, 0, 0);
+	hose->write_dword(hose, bdf, 0x20, 0x7fff0000);
+
+	/* open 0 - 1G for PCAC located behind for switch port */
+	hose = pci_bus_to_hose(2);
+	bdf  = PCI_BDF(2, 2, 0);
+	hose->write_dword(hose, bdf, 0x20, 0x3fff0000);
+	hose->write_dword(hose, bdf, 0x0, 0x0);
+
+	/* set DRAM device PCIE bars:
 	   bar 0 configuration space = 0xf1000000
 	   bar 1  address = 0x0 - dram address */
-	hose = pci_bus_to_hose(0);
-	hose->write_dword(hose, 0, BAR0_LOW_ADDR_OFFSET, PCI_DEVICE_CONFIG_SPACE);
-	hose->write_dword(hose, 0, BAR0_HIGH_ADDR_OFFSET, 0);
-
-	hose->write_dword(hose, 0, BAR1_LOW_ADDR_OFFSET, DRAM_OFFSET);
-	hose->write_dword(hose, 0, BAR1_HIGH_ADDR_OFFSET, 0);
+	hose = pci_bus_to_hose(3);
+	bdf  = PCI_BDF(3, 0, 0);
+	hose->write_dword(hose, bdf, BAR0_LOW_ADDR_OFFSET, PCI_DEVICE_CONFIG_SPACE);
+	hose->write_dword(hose, bdf, BAR0_HIGH_ADDR_OFFSET, 0);
+	hose->write_dword(hose, bdf, BAR1_LOW_ADDR_OFFSET, DRAM_OFFSET);
+	hose->write_dword(hose, bdf, BAR1_HIGH_ADDR_OFFSET, 0);
 }
diff --git a/drivers/pci/pci_mvebu.c b/drivers/pci/pci_mvebu.c
index ae57344..bea98a0 100644
--- a/drivers/pci/pci_mvebu.c
+++ b/drivers/pci/pci_mvebu.c
@@ -85,6 +85,11 @@
 #define PCIE_LINK_CTL_OFF(x)	(x + 0x70)
 
 #define MAX_PCIE_PORTS		10
+#ifdef CONFIG_MVEBU_SPL_DDR_OVER_PCI_SUPPORT
+#define FIRST_PCI_BUS		1
+#else
+#define FIRST_PCI_BUS		0
+#endif
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -134,12 +139,25 @@ static int mvebu_pcie_write_config(struct pci_controller *hose, pci_dev_t bdf,
 		return 1;
 	}
 
-	writel(PCIE_CONF_ADDR(bdf, where), hose->cfg_addr);
-	writel(val, hose->cfg_data);
-
+#if defined(CONFIG_MVEBU_SPL_DDR_OVER_PCI_SUPPORT) && !defined(CONFIG_SPL_BUILD)
+	/* Control modifications to switch ports that host
+	 * the DDR controller maintain DDR access over PCI */
+	if ((bdf == PCI_BDF(1, 0, 0)) || (bdf == PCI_BDF(2, 2, 0))) {
+		/* Never disable Master & Memory capabilities */
+		if (where == PCI_COMMAND)
+			val |= (PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
+
+		/* Avoid changing the main bridge BARs */
+		if (where == PCI_MEMORY_BASE)
+			return 0;
+	}
+#endif
 	debug_cfg("PCIE CFG write: (b,d,f)=(%2ld,%2ld,%2ld) (addr,val)=(0x%04x, 0x%08x)\n",
 		  PCI_BUS(bdf), PCI_DEV(bdf), PCI_FUNC(bdf), where, val);
 
+	writel(PCIE_CONF_ADDR(bdf, where), hose->cfg_addr);
+	writel(val, hose->cfg_data);
+
 	return 0;
 }
 
@@ -218,6 +236,7 @@ static void mvebu_pcie_setup_mapping(void __iomem *reg_base)
 	writel(((size - 1) & 0xffff0000) | PCIE_BAR_ENABLE, PCIE_BAR_CTRL_OFF(reg_base, 1));
 }
 
+
 static void mvebu_pcie_hw_init(void __iomem *reg_base, int first_busno)
 {
 	u32 cmd;
@@ -245,6 +264,14 @@ static void mvebu_pcie_hw_init(void __iomem *reg_base, int first_busno)
  */
 int pci_skip_dev(struct pci_controller *hose, pci_dev_t dev)
 {
+#if defined(CONFIG_MVEBU_SPL_DDR_OVER_PCI_SUPPORT) && !defined(CONFIG_SPL_BUILD)
+	/* skip the switch port connected to the DRAM
+	 * PCIe controller to retain its configuration */
+	if (dev == PCI_BDF(3, 0, 0)) {
+		debug_cfg("Skipping (b,d,f)=(%2ld,%2ld,%2ld)\n", PCI_BUS(dev), PCI_DEV(dev), PCI_FUNC(dev));
+		return 1;
+	}
+#endif
 	return 0;
 }
 
@@ -279,6 +306,7 @@ static int mvebu_pcie_init(int host_id, void __iomem *reg_base, struct pcie_win
 	hose->cfg_data = (unsigned char *)PCIE_CONF_DATA_OFF(reg_base);
 
 	hose->first_busno = first_busno;
+	hose->current_busno = first_busno;
 
 	/* Register the host */
 	pci_register_hose(hose);
@@ -320,7 +348,7 @@ static void mvebu_pcie_set_endpoint(u32 hid, void __iomem *reg_base)
 void pci_init_board(void)
 {
 	int host_id = -1;
-	int first_busno = 0;
+	int first_busno = FIRST_PCI_BUS;
 	int bus_node, port_node, count;
 	const void *blob = gd->fdt_blob;
 	struct pcie_win win;
-- 
1.9.1

