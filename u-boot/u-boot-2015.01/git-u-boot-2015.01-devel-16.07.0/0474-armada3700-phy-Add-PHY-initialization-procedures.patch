From 9fb16843416ad3ae171ab2dbc682947ad19f060d Mon Sep 17 00:00:00 2001
From: Konstantin Porotchkin <kostap@marvell.com>
Date: Wed, 28 Oct 2015 16:01:09 +0200
Subject: [PATCH 0474/1240] armada3700: phy: Add PHY initialization procedures

- Rename Arlada LP PHY support files to Armada-3700
- Add PHY initalization procedures for PCIe, USB3/2,
  SATA, SDIO/eMMC, SGMII
- Extend COMPHY common code for supporting 16-bit
  operations

Change-Id: Idd641338f849dc2fa3eac5c3a16a63b38d623c26
Signed-off-by: Konstantin Porotchkin <kostap@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/24467
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
---
 arch/arm/include/asm/arch-mvebu/comphy.h |   4 +-
 drivers/phy/Makefile                     |   2 +-
 drivers/phy/comphy_a3700.c               | 735 +++++++++++++++++++++++++++++++
 drivers/phy/comphy_a3700.h               | 208 +++++++++
 drivers/phy/comphy_armada_lp.c           |  75 ----
 drivers/phy/comphy_core.c                |  21 +-
 include/fdtdec.h                         |   2 +
 7 files changed, 968 insertions(+), 79 deletions(-)
 create mode 100644 drivers/phy/comphy_a3700.c
 create mode 100644 drivers/phy/comphy_a3700.h
 delete mode 100644 drivers/phy/comphy_armada_lp.c

diff --git a/arch/arm/include/asm/arch-mvebu/comphy.h b/arch/arm/include/asm/arch-mvebu/comphy.h
index 0b250a7..21427e7 100644
--- a/arch/arm/include/asm/arch-mvebu/comphy.h
+++ b/arch/arm/include/asm/arch-mvebu/comphy.h
@@ -86,6 +86,8 @@ struct chip_serdes_phy_config {
 
 void reg_set(void __iomem *addr, u32 data, u32 mask);
 void reg_set_silent(void __iomem *addr, u32 data, u32 mask);
+void reg_set16(void __iomem *addr, u16 data, u16 mask);
+void reg_set_silent16(void __iomem *addr, u16 data, u16 mask);
 u32 comphy_init(const void *blob);
 
 #ifdef CONFIG_TARGET_ARMADA_38X
@@ -93,7 +95,7 @@ int comphy_a38x_init(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_
 #elif defined(CONFIG_TARGET_ARMADA_8K)
 int comphy_ap806_init(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_map *serdes_map);
 #elif defined(CONFIG_TARGET_ARMADA_LP)
-int comphy_armada_lp_init(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_map *serdes_map);
+int comphy_a3700_init(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_map *serdes_map);
 #endif
 
 
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index 8528274..e2ca19e 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -1,5 +1,5 @@
 obj-y += comphy_core.o
 obj-y += comphy_a38x.o
 obj-y += comphy_ap806_z1.o
-obj-y += comphy_armada_lp.o
+obj-y += comphy_a3700.o
 obj-y += comphy_pcie_config.o
diff --git a/drivers/phy/comphy_a3700.c b/drivers/phy/comphy_a3700.c
new file mode 100644
index 0000000..539ba2c
--- /dev/null
+++ b/drivers/phy/comphy_a3700.c
@@ -0,0 +1,735 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+#define DEBUG
+#include <common.h>
+#include <fdtdec.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/fdt.h>
+#include <asm/arch-mvebu/mvebu.h>
+#include "comphy_a3700.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct sgmii_phy_init_data_fix {
+	u16 addr;
+	u16 value;
+};
+
+/* Changes to 40M1G25 mode data required for running 40M3G125 init mode */
+static struct sgmii_phy_init_data_fix sgmii_phy_init_fix[] = {
+	{0x005, 0x07CC}, {0x015, 0x0000}, {0x01B, 0x0000}, {0x01D, 0x0000},
+	{0x01E, 0x0000}, {0x01F, 0x0000}, {0x020, 0x0000}, {0x021, 0x0030},
+	{0x026, 0x0888}, {0x04D, 0x0152}, {0x04F, 0xA020}, {0x050, 0x07CC},
+	{0x053, 0xE9CA}, {0x055, 0xBD97}, {0x071, 0x3015}, {0x076, 0x03AA},
+	{0x07C, 0x0FDF}, {0x0C2, 0x3030}, {0x0C3, 0x8000}, {0x0E2, 0x5550},
+	{0x0E3, 0x12A4}, {0x0E4, 0x7D00}, {0x0E6, 0x0C83}, {0x101, 0xFCC0},
+	{0x104, 0x0C10}
+};
+
+/* 40M1G25 mode init data */
+static u16 sgmii_phy_init[512] = {
+		/* 0       1       2       3       4       5       6       7 */
+		/*-----------------------------------------------------------*/
+		/* 8       9       A       B       C       D       E       F */
+/* 00 */	0x3110, 0xFD83, 0x6430, 0x412F, 0x82C0, 0x06FA, 0x4500, 0x6D26,
+/* 08 */	0xAFC0, 0x8000, 0xC000, 0x0000, 0x2000, 0x49CC, 0x0BC9, 0x2A52,
+/* 10 */	0x0BD2, 0x0CDE, 0x13D2, 0x0CE8, 0x1149, 0x10E0, 0x0000, 0x0000,
+/* 18 */	0x0000, 0x0000, 0x0000, 0x0001, 0x0000, 0x4134, 0x0D2D, 0xFFFF,
+/* 20 */	0xFFE0, 0x4030, 0x1016, 0x0030, 0x0000, 0x0800, 0x0866, 0x0000,
+/* 28 */	0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
+/* 30 */	0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 38 */	0x0000, 0x0000, 0x000F, 0x6A62, 0x1988, 0x3100, 0x3100, 0x3100,
+/* 40 */	0x3100, 0xA708, 0x2430, 0x0830, 0x1030, 0x4610, 0xFF00, 0xFF00,
+/* 48 */	0x0060, 0x1000, 0x0400, 0x0040, 0x00F0, 0x0155, 0x1100, 0xA02A,
+/* 50 */	0x06FA, 0x0080, 0xB008, 0xE3ED, 0x5002, 0xB592, 0x7A80, 0x0001,
+/* 58 */	0x020A, 0x8820, 0x6014, 0x8054, 0xACAA, 0xFC88, 0x2A02, 0x45CF,
+/* 60 */	0x000F, 0x1817, 0x2860, 0x064F, 0x0000, 0x0204, 0x1800, 0x6000,
+/* 68 */	0x810F, 0x4F23, 0x4000, 0x4498, 0x0850, 0x0000, 0x000E, 0x1002,
+/* 70 */	0x9D3A, 0x3009, 0xD066, 0x0491, 0x0001, 0x6AB0, 0x0399, 0x3780,
+/* 78 */	0x0040, 0x5AC0, 0x4A80, 0x0000, 0x01DF, 0x0000, 0x0007, 0x0000,
+/* 80 */	0x2D54, 0x00A1, 0x4000, 0x0100, 0xA20A, 0x0000, 0x0000, 0x0000,
+/* 88 */	0x0000, 0x0000, 0x0000, 0x7400, 0x0E81, 0x1000, 0x1242, 0x0210,
+/* 90 */	0x80DF, 0x0F1F, 0x2F3F, 0x4F5F, 0x6F7F, 0x0F1F, 0x2F3F, 0x4F5F,
+/* 98 */	0x6F7F, 0x4BAD, 0x0000, 0x0000, 0x0800, 0x0000, 0x2400, 0xB651,
+/* A0 */	0xC9E0, 0x4247, 0x0A24, 0x0000, 0xAF19, 0x1004, 0x0000, 0x0000,
+/* A8 */	0x0000, 0x0013, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* B0 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* B8 */	0x0000, 0x0000, 0x0000, 0x0060, 0x0000, 0x0000, 0x0000, 0x0000,
+/* C0 */	0x0000, 0x0000, 0x3010, 0xFA00, 0x0000, 0x0000, 0x0000, 0x0003,
+/* C8 */	0x1618, 0x8200, 0x8000, 0x0400, 0x050F, 0x0000, 0x0000, 0x0000,
+/* D0 */	0x4C93, 0x0000, 0x1000, 0x1120, 0x0010, 0x1242, 0x1242, 0x1E00,
+/* D8 */	0x0000, 0x0000, 0x0000, 0x00F8, 0x0000, 0x0041, 0x0800, 0x0000,
+/* E0 */	0x82A0, 0x572E, 0x2490, 0x14A9, 0x4E00, 0x0000, 0x0803, 0x0541,
+/* E8 */	0x0C15, 0x0000, 0x0000, 0x0400, 0x2626, 0x0000, 0x0000, 0x4200,
+/* F0 */	0x0000, 0xAA55, 0x1020, 0x0000, 0x0000, 0x5010, 0x0000, 0x0000,
+/* F8 */	0x0000, 0x0000, 0x5000, 0x0000, 0x0000, 0x0000, 0x02F2, 0x0000,
+/* 100 */	0x101F, 0xFDC0, 0x4000, 0x8010, 0x0110, 0x0006, 0x0000, 0x0000,
+/* 108 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 110 */	0x04CF, 0x0000, 0x04CF, 0x0000, 0x04CF, 0x0000, 0x04C6, 0x0000,
+/* 118 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 120 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 128 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 130 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 138 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 140 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 148 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 150 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 158 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 160 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 168 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 170 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 178 */	0x0000, 0x0000, 0x0000, 0x00F0, 0x08A2, 0x3112, 0x0A14, 0x0000,
+/* 180 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 188 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 190 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 198 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 1A0 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 1A8 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 1B0 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 1B8 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 1C0 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 1C8 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 1D0 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 1D8 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 1E0 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 1E8 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 1F0 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+/* 1F8 */	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
+	};
+
+static u8 sp_2g5 = 1;
+
+
+/***************************************************************************************************
+  * comphy_get_ref_clk
+  *
+  * return: reference clock in MHz (25 or 40)
+ ***************************************************************************************************/
+static u32 comphy_get_ref_clk(void)
+{
+	return DEFAULT_REFCLK_MHZ;
+}
+
+/***************************************************************************************************
+  * comphy_poll_reg
+  *
+  * return: 1 on success, 0 on timeout
+ ***************************************************************************************************/
+static u32 comphy_poll_reg(void *addr, u32 val, u32 mask, u32 timeout, u8 op_type)
+{
+	u32	rval = 0xDEAD;
+
+	for (; timeout > 0; timeout--) {
+		if (op_type == POLL_16B_REG)
+			rval = readw(addr);	/* 16 bit */
+		else
+			rval = readl(addr) ;	/* 32 bit */
+
+		if ((rval & mask) == val)
+			return 1;
+
+		udelay(10000);
+	}
+
+	debug("Time out waiting (%p = %#010x)\n", addr, rval);
+	return 0;
+}
+/***************************************************************************************************
+  * comphy_pcie_power_up
+  *
+  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
+ ***************************************************************************************************/
+static int comphy_pcie_power_up(void)
+{
+	int	ret;
+
+	debug_enter();
+
+	/*
+	 * 1. Enable max PLL.
+	 */
+	reg_set16((void __iomem *)LANE_CFG1_ADDR(PCIE), bf_use_max_pll_rate, 0);
+
+	/*
+	 * 2. Select 20 bit SERDES interface.
+	 */
+	reg_set16((void __iomem *)GLOB_CLK_SRC_LO_ADDR(PCIE), bf_cfg_sel_20b, 0);
+
+	/*
+	 * 3. Force to use reg setting for PCIe mode
+	 */
+	reg_set16((void __iomem *)MISC_REG1_ADDR(PCIE), bf_sel_bits_pcie_force, 0);
+
+	/*
+	 * 4. Change RX wait
+	 */
+	reg_set16((void __iomem *)PWR_MGM_TIM1_ADDR(PCIE), 0x10C, 0xFFFF);
+
+	/*
+	 * 5. Enable idle sync
+	 */
+	reg_set16((void __iomem *)UNIT_CTRL_ADDR(PCIE), 0x60 | rb_idle_sync_en, 0xFFFF);
+
+	/*
+	 * 6. Enable the output of 100M/125M/500M clock
+	 */
+	reg_set16((void __iomem *)MISC_REG0_ADDR(PCIE),
+		  0xA00D | rb_clk500m_en | rb_clk100m_125m_en, 0xFFFF);
+
+	/*
+	 * 7. Enable TX
+	 */
+	reg_set((void __iomem *)PHY_REF_CLK_ADDR, 0x1342, 0xFFFFFFFF);
+
+	/*
+	 * 8. Check crystal jumper setting and program the Power and PLL Control accordingly
+	 */
+	if (comphy_get_ref_clk() == 40)
+		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(PCIE), 0xFC63, 0xFFFF); /* 40 MHz */
+	else
+		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(PCIE), 0xFC62, 0xFFFF); /* 25 MHz */
+
+	/*
+	 * 9. Override Speed_PLL value and use MAC PLL
+	 */
+	reg_set16((void __iomem *)KVCO_CAL_CTRL_ADDR(PCIE), 0x0040 | rb_use_max_pll_rate, 0xFFFF);
+
+	/*
+	 * 10. Release SW reset
+	 */
+	reg_set16((void __iomem *)GLOB_PHY_CTRL0_ADDR(PCIE),
+		  rb_mode_core_clk_freq_sel | rb_mode_pipe_width_32,
+		  bf_soft_rst | bf_mode_refdiv);
+
+	/* Wait for > 55 us to allow PCLK be enabled */
+	udelay(PLL_SET_DELAY_US);
+
+	/* Assert PCLK enabled */
+	ret = comphy_poll_reg((void *)LANE_STAT1_ADDR(PCIE),	/* address */
+			      rb_txdclk_pclk_en,		/* value */
+			      rb_txdclk_pclk_en,		/* mask */
+			      PLL_LOCK_TIMEOUT,			/* timeout */
+			      POLL_16B_REG);			/* 16bit */
+	if (ret == 0)
+		error("Failed to lock PCIe PLL\n");
+
+	debug_exit();
+
+	/* Return the status of the PLL */
+	return ret;
+}
+
+/***************************************************************************************************
+  * comphy_sata_power_up
+  *
+  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
+ ***************************************************************************************************/
+static int comphy_sata_power_up(void)
+{
+	int	ret;
+
+	debug_enter();
+
+	/*
+	 * 1. Select 40-bit data width width
+	 */
+	reg_set((void __iomem *)rh_vsreg_addr, vphy_loopback_reg0, 0);
+	reg_set((void __iomem *)rh_vsreg_data, 0x800, bs_phyintf_40bit);
+
+	/*
+	 * 2. Select reference clock and PHY mode (SATA)
+	 */
+	reg_set((void __iomem *)rh_vsreg_addr, vphy_power_reg0, 0);
+	if (comphy_get_ref_clk() == 40)
+		reg_set((void __iomem *)rh_vsreg_data, 0x3, 0x00FF); /* 40 MHz */
+	else
+		reg_set((void __iomem *)rh_vsreg_data, 0x1, 0x00FF); /* 25 MHz */
+
+	/*
+	 * 3. Use maximum PLL rate (no power save)
+	 */
+	reg_set((void __iomem *)rh_vsreg_addr, vphy_calctl_reg, 0);
+	reg_set((void __iomem *)rh_vsreg_data, bs_max_pll_rate, bs_max_pll_rate);
+
+	/*
+	 * 4. Reset reserved bit (??)
+	 */
+	reg_set((void __iomem *)rh_vsreg_addr, vphy_reserve_reg, 0);
+	reg_set((void __iomem *)rh_vsreg_data, 0, bs_phyctrl_frm_pin);
+
+	/*
+	 * 5. Set vendor-specific configuration (??)
+	 */
+	reg_set((void __iomem *)rh_vs0_a, vsata_ctrl_reg, 0);
+	reg_set((void __iomem *)rh_vs0_d, bs_phy_pu_pll, 0);
+
+	/* Wait for > 55 us to allow PLL be enabled */
+	udelay(PLL_SET_DELAY_US);
+
+	/* Assert SATA PLL enabled */
+	reg_set((void __iomem *)rh_vsreg_addr, vphy_loopback_reg0, 0);
+	ret = comphy_poll_reg((void *)rh_vsreg_data,	/* address */
+			      bs_pll_ready_tx,		/* value */
+			      bs_pll_ready_tx,		/* mask */
+			      PLL_LOCK_TIMEOUT,		/* timeout */
+			      POLL_32B_REG);		/* 32bit */
+	if (ret == 0)
+		error("Failed to lock SATA PLL\n");
+
+	debug_exit();
+
+	return ret;
+}
+
+/***************************************************************************************************
+  * comphy_usb3_power_up
+  *
+  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
+ ***************************************************************************************************/
+static int comphy_usb3_power_up(void)
+{
+	int	ret;
+
+	debug_enter();
+
+	/*
+	 * 1. Power up OTG module
+	 */
+	reg_set((void __iomem *)USB2_PHY_OTG_CTRL_ADDR, rb_pu_otg, 0);
+
+	/*
+	 * 2. Set counter for 100us pulse in USB3 Host and Device
+	 */
+	reg_set((void __iomem *)USB3_CTRPUL_VAL_REG, 0x8 << 24, rb_usb3_ctr_100ns);
+	reg_set((void __iomem *)USB3H_CTRPUL_VAL_REG, 0x8 << 24, rb_usb3_ctr_100ns);
+
+	/*
+	 * 3. Check crystal jumper setting and program the Power and PLL Control accordingly
+	 */
+	if (comphy_get_ref_clk() == 40)
+		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(USB3), 0xFCA3, 0xFFFF); /* 40 MHz */
+	else
+		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(USB3), 0xFCA1, 0xFFFF); /* 25 MHz */
+
+	/*
+	 * 4. Change RX wait
+	 */
+	reg_set16((void __iomem *)PWR_MGM_TIM1_ADDR(USB3), 0x10C, 0xFFFF);
+
+	/*
+	 * 5. Enable idle sync
+	 */
+	reg_set16((void __iomem *)UNIT_CTRL_ADDR(USB3), 0x60 | rb_idle_sync_en, 0xFFFF);
+
+	/*
+	 * 6. Enable the output of 500M clock
+	 */
+	reg_set16((void __iomem *)MISC_REG0_ADDR(USB3), 0xA00D | rb_clk500m_en, 0xFFFF);
+
+	/*
+	 * 7. Set 20-bit data width
+	 */
+	reg_set16((void __iomem *)DIG_LB_EN_ADDR(USB3), 0x0400, 0xFFFF);
+
+	/*
+	 * 8. Override Speed_PLL value and use MAC PLL
+	 */
+	reg_set16((void __iomem *)KVCO_CAL_CTRL_ADDR(USB3), 0x0040 | rb_use_max_pll_rate, 0xFFFF);
+
+	/*
+	 * 10. Release SW reset
+	 */
+	reg_set16((void __iomem *)GLOB_PHY_CTRL0_ADDR(USB3),
+		  rb_mode_core_clk_freq_sel | rb_mode_pipe_width_32 | 0x20, bf_mode_refdiv);
+
+	/* Wait for > 55 us to allow PCLK be enabled */
+	udelay(PLL_SET_DELAY_US);
+
+	/* Assert PCLK enabled */
+	ret = comphy_poll_reg((void *)LANE_STAT1_ADDR(USB3),	/* address */
+			      rb_txdclk_pclk_en,		/* value */
+			      rb_txdclk_pclk_en,		/* mask */
+			      PLL_LOCK_TIMEOUT,			/* timeout */
+			      POLL_16B_REG);			/* 16bit */
+	if (ret == 0)
+		error("Failed to lock USB3 PLL\n");
+
+	debug_exit();
+
+	return ret;
+}
+
+/***************************************************************************************************
+  * comphy_usb2_power_up
+  *
+  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
+ ***************************************************************************************************/
+static int comphy_usb2_power_up(void)
+{
+	int	ret;
+
+	debug_enter();
+
+	/*
+	 * 1. PHY pull up and disable USB2 suspend
+	 */
+	reg_set((void __iomem *)USB2_OTG_PHY_CTRL_ADDR,
+		rb_usb2phy_suspm | rb_usb2phy_pu, 0);
+
+	/*
+	 * 2. Power up OTG module
+	 */
+	reg_set((void __iomem *)USB2_PHY_OTG_CTRL_ADDR, rb_pu_otg, 0);
+
+	/*
+	 * 3. Configure PHY charger detection
+	 */
+	reg_set((void __iomem *)USB2_PHY_CHRGR_DET_ADDR, 0,
+		rb_cdp_en | rb_dcp_en | rb_pd_en | rb_cdp_dm_auto |
+		rb_enswitch_dp | rb_enswitch_dm | rb_pu_chrg_dtc);
+
+	/* Assert PLL calibration done */
+	ret = comphy_poll_reg((void *)USB2_CAL_CTRL_ADDR,	/* address */
+			      rb_usb2phy_pllcal_done,		/* value */
+			      rb_usb2phy_pllcal_done,		/* mask */
+			      PLL_LOCK_TIMEOUT,			/* timeout */
+			      POLL_32B_REG);			/* 32bit */
+	if (ret == 0)
+		error("Failed to end USB2 PLL calibration\n");
+
+	/* Assert impedance calibration done */
+	ret = comphy_poll_reg((void *)USB2_CAL_CTRL_ADDR,	/* address */
+			      rb_usb2phy_impcal_done,		/* value */
+			      rb_usb2phy_impcal_done,		/* mask */
+			      PLL_LOCK_TIMEOUT,			/* timeout */
+			      POLL_32B_REG);			/* 32bit */
+	if (ret == 0)
+		error("Failed to end USB2 impedance calibration\n");
+
+	/* Assert squetch calibration done */
+	ret = comphy_poll_reg((void *)USB2_RX_CHAN_CTRL1_ADDR,	/* address */
+			      rb_usb2phy_sqcal_done,		/* value */
+			      rb_usb2phy_sqcal_done,		/* mask */
+			      PLL_LOCK_TIMEOUT,			/* timeout */
+			      POLL_32B_REG);			/* 32bit */
+	if (ret == 0)
+		error("Failed to end USB2 unknown calibration\n");
+
+	/* Assert PLL is ready */
+	ret = comphy_poll_reg((void *)USB2_PLL_CTRL0_ADDR,	/* address */
+			      rb_usb2phy_pll_ready,		/* value */
+			      rb_usb2phy_pll_ready,		/* mask */
+			      PLL_LOCK_TIMEOUT,			/* timeout */
+			      POLL_32B_REG);			/* 32bit */
+	if (ret == 0)
+		error("Failed to lock USB2 PLL\n");
+
+	debug_exit();
+
+	return ret;
+}
+
+/***************************************************************************************************
+  * comphy_emmc_power_up
+  *
+  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
+ ***************************************************************************************************/
+static int comphy_emmc_power_up(void)
+{
+	debug_enter();
+
+	/*
+	 * 1. Bus power ON, Bus voltage 1.8V
+	 */
+	reg_set((void __iomem *)SDIO_HOST_CTRL1_ADDR, 0xB00, 0x100);
+
+	/*
+	 * 2. Set FIFO parameters
+	 */
+	reg_set((void __iomem *)SDIO_SDHC_FIFO_ADDR, 0x315, 0);
+
+
+	/*
+	 * 3. Set Capabilities 1_2
+	 */
+	reg_set((void __iomem *)SDIO_CAP_12_ADDR, 0x25FAC8B2, 0);
+
+	/*
+	 * 4. Set Endian
+	 */
+	reg_set((void __iomem *)SDIO_ENDIAN_ADDR, 0x00c00000, 0);
+
+
+	/*
+	 * 4. Init PHY
+	 */
+	reg_set((void __iomem *)SDIO_PHY_TIMING_ADDR, 0x80000000, 0);
+	reg_set((void __iomem *)SDIO_PHY_PAD_CTRL0_ADDR, 0x50000000, 0);
+
+	/*
+	 * 5. DLL reset
+	 */
+	reg_set((void __iomem *)SDIO_DLL_RST_ADDR, 0xFFFFFFFF, 0);
+	reg_set((void __iomem *)SDIO_DLL_RST_ADDR, 0x00010000, 0);
+
+	debug_exit();
+
+	return 1;
+}
+
+/***************************************************************************************************
+  * comphy_sgmii_power_up
+  *
+  * return:
+ ***************************************************************************************************/
+static void comphy_sgmii_phy_init(u32 lane, u8 sp_2g5)
+{
+	int		addr, fix_idx;
+	const int	fix_arr_sz = sizeof(sgmii_phy_init_fix) / sizeof(struct sgmii_phy_init_data_fix);
+	u16		val;
+
+	fix_idx = 0;
+	for (addr = 0; addr < 512; addr++) {
+		if ((sp_2g5 != 0) && (sgmii_phy_init_fix[fix_idx].addr == addr)) {
+			/* Use new value */
+			val = sgmii_phy_init_fix[fix_idx].value;
+			if (fix_idx < fix_arr_sz)
+				fix_idx++;
+		} else {
+			val = sgmii_phy_init[addr];
+		}
+
+		phy_write16(lane, addr, val, 0xFFFF);
+	}
+}
+
+/***************************************************************************************************
+  * comphy_sgmii_power_up
+  *
+  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
+ ***************************************************************************************************/
+static int comphy_sgmii_power_up(u32 lane)
+{
+	int	ret;
+
+	debug_enter();
+
+	/*
+	  1. Configure PHY to SATA/SAS mode by setting pin PIN_PIPE_SEL=0
+	 */
+	reg_set((void __iomem *)COMPHY_SEL_ADDR, 0, rf_compy_select(lane));
+
+	/*
+	  2. Reset PHY by setting PHY input port PIN_RESET=1.
+	  3. Set PHY input port PIN_TX_IDLE=1, PIN_PU_IVREF=1 to keep
+	     PHY TXP/TXN output to idle state during PHY initialization
+	  4. Set PHY input port PIN_PU_PLL=0, PIN_PU_RX=0, PIN_PU_TX=0.
+	 */
+	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
+		rb_pin_reset_comphy | rb_pin_tx_idle | rb_pin_pu_iveref, /* data - fields to set */
+		rb_pin_pu_pll | rb_pin_pu_rx | rb_pin_pu_tx); /* mask - fields to reset */
+
+	/*
+	  5. Release reset to the PHY by setting PIN_RESET=0.
+	 */
+	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane), 0, rb_pin_reset_comphy);
+
+	/*
+	  7. Set PIN_PHY_GEN_TX[3:0] and PIN_PHY_GEN_RX[3:0] to decide COMPHY bit rate
+	 */
+	if (sp_2g5 == 1) { /* 3.125 GHz */
+		reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
+			(0x8 << rf_gen_rx_sel_shift) | (0x8 << rf_gen_tx_sel_shift), /* data - fields to set */
+			rf_gen_rx_select | rf_gen_tx_select); /* mask - fields to reset */
+
+	} else { /* 1.25 GHz */
+		reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
+			(0x6 << rf_gen_rx_sel_shift) | (0x6 << rf_gen_tx_sel_shift), /* data - fields to set */
+			rf_gen_rx_select | rf_gen_tx_select); /* mask - fields to reset */
+	}
+
+	debug("Running C-DPI phy init %s mode\n", sp_2g5 != 0 ? "2G5" : "1G");
+	comphy_sgmii_phy_init(lane, sp_2g5);
+
+	phy_write16(lane, PHY_REG_IFACE_REF_CLK_CTRL_ADDR,
+		    rb_ref1m_gen_div_force | (0x4 << rf_ref1m_gen_div_value_shift),
+		    rb_ref1m_gen_div_force | rf_ref1m_gen_div_value_mask);
+
+	phy_write16(lane, PHY_REG_ERR_CNT_CONST_CTRL_ADDR, rb_fast_dfe_enable, rb_fast_dfe_enable);
+
+	phy_write16(lane, PHY_REG_UNIT_CTRL_ADDR, rb_idle_sync_en, rb_idle_sync_en);
+
+	phy_write16(lane, PHY_REG_KVCO_CAL_CTRL_ADDR, rb_force_calibration_done, rb_force_calibration_done);
+
+	/*
+	   18. Set PHY input ports PIN_PU_PLL, PIN_PU_TX and PIN_PU_RX to 1 to start
+	   PHY power up sequence. All the PHY register programming should be done before
+	   PIN_PU_PLL=1.
+	   There should be no register programming for normal PHY operation from this point.
+	 */
+	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
+		rb_pin_pu_pll | rb_pin_pu_rx | rb_pin_pu_tx,
+		rb_pin_pu_pll | rb_pin_pu_rx | rb_pin_pu_tx);
+
+	/*
+	  19. Wait for PHY power up sequence to finish by checking output ports
+	  PIN_PLL_READY_TX=1 and PIN_PLL_READY_RX=1.
+	 */
+	ret = comphy_poll_reg((void *)COMPHY_PHY_STAT1_ADDR(lane),	/* address */
+			      rb_pll_ready_tx | rb_pll_ready_rx,	/* value */
+			      rb_pll_ready_tx | rb_pll_ready_rx,	/* mask */
+			      PLL_LOCK_TIMEOUT,				/* timeout */
+			      POLL_32B_REG);				/* 32bit */
+	if (ret == 0)
+		error("Failed to lock PLL for SGMII PHY %d\n", lane);
+
+	/*
+	  20. Set COMPHY input port PIN_TX_IDLE=0
+	 */
+	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane), 0x0, rb_pin_tx_idle);
+
+	/*
+	  21. After valid data appear on PIN_RXDATA bus, set PIN_RX_INIT=1.
+	  to start RX initialization. PIN_RX_INIT_DONE will be cleared to 0 by the PHY
+	  After RX initialization is done, PIN_RX_INIT_DONE will be set to 1 by COMPHY
+	  Set PIN_RX_INIT=0 after PIN_RX_INIT_DONE= 1.
+	  Please refer to RX initialization part for details.
+	 */
+	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane), rb_phy_rx_init, 0x0);
+
+
+	ret = comphy_poll_reg((void *)COMPHY_PHY_STAT1_ADDR(lane),	/* address */
+			       rb_rx_init_done,				/* value */
+			       rb_rx_init_done,				/* mask */
+			       PLL_LOCK_TIMEOUT,			/* timeout */
+			       POLL_32B_REG);				/* 32bit */
+	if (ret == 0)
+		error("Failed to init RX of SGMII PHY %d\n", lane);
+
+	debug_exit();
+
+	return ret;
+}
+
+
+/***************************************************************************************************
+  * comphy_dedicated_phys_init
+ ***************************************************************************************************/
+static void comphy_dedicated_phys_init(void)
+{
+	int node, subnode, count, ret = 1;
+	const void *blob = gd->fdt_blob;
+
+	debug_enter();
+
+	count = fdtdec_find_aliases_for_id(blob, "usb",
+			COMPAT_MVEBU_USB, &node, A3700_MAX_USB_CNT);
+
+	if (count > 0) {
+		fdt_for_each_subnode(blob, subnode, node) {
+			if (fdtdec_get_is_enabled(blob, subnode)) {
+				ret = comphy_usb2_power_up();
+				if (ret == 0)
+					error("Failed to initialize USB2 PHY\n");
+			}
+		}
+	}
+
+	count = fdtdec_find_aliases_for_id(blob, "sata",
+			COMPAT_MVEBU_USB, &node, A3700_MAX_SATA_CNT);
+
+	if (count > 0) {
+		fdt_for_each_subnode(blob, subnode, node) {
+			if (fdtdec_get_is_enabled(blob, subnode)) {
+				ret = comphy_sata_power_up();
+				if (ret == 0)
+					error("Failed to initialize SATA PHY\n");
+			}
+		}
+	}
+
+	count = fdtdec_find_aliases_for_id(blob, "sdio",
+		 COMPAT_MVEBU_USB, &node, A3700_MAX_SDIO_CNT);
+
+	if (count > 0) {
+		fdt_for_each_subnode(blob, subnode, node) {
+			if (fdtdec_get_is_enabled(blob, subnode)) {
+				ret = comphy_emmc_power_up();
+				if (ret == 0)
+					error("Failed to initialize SDIO/eMMC PHY\n");
+			}
+		}
+	}
+
+	debug_exit();
+}
+
+/***************************************************************************************************
+  * comphy_a3700_init
+ ***************************************************************************************************/
+int comphy_a3700_init(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_map *serdes_map)
+{
+	struct comphy_map *ptr_comphy_map;
+/*
+	TODO - Convert all COMPY REG addresses to be based on values from DT:
+	void __iomem *comphy_base_addr = ptr_chip_cfg->comphy_base_addr;
+	void __iomem *hpipe_base_addr = ptr_chip_cfg->hpipe3_base_addr;
+*/
+	u32 comphy_max_count = ptr_chip_cfg->comphy_lanes_count;
+	u32 lane, ret = 0;
+
+	debug_enter();
+
+	for (lane = 0, ptr_comphy_map = serdes_map; lane < comphy_max_count; lane++, ptr_comphy_map++) {
+		debug("Initialize serdes number %d\n", lane);
+		debug("Serdes type = 0x%x\n", ptr_comphy_map->type);
+
+		switch (ptr_comphy_map->type) {
+		case UNCONNECTED:
+			continue;
+			break;
+
+		case PEX0:
+			ret = comphy_pcie_power_up();
+			break;
+
+		case USB3_HOST0:
+		case USB3_DEVICE:
+			ret = comphy_usb3_power_up();
+			break;
+
+		case SGMII0:
+		case SGMII1:
+			ret = comphy_sgmii_power_up(lane);
+			break;
+
+		default:
+			debug("Unknown SerDes type, skip initialize SerDes %d\n", lane);
+			ret = 1;
+			break;
+		}
+		if (ret == 0)
+			error("PLL is not locked - Failed to initialize lane %d\n", lane);
+	}
+
+	comphy_dedicated_phys_init();
+
+	debug_exit();
+	return ret;
+}
diff --git a/drivers/phy/comphy_a3700.h b/drivers/phy/comphy_a3700.h
new file mode 100644
index 0000000..4b37fbe
--- /dev/null
+++ b/drivers/phy/comphy_a3700.h
@@ -0,0 +1,208 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+#ifndef _COMPHY_A3700_H_
+#define _COMPHY_A3700_H_
+
+#include <asm/arch-mvebu/comphy.h>
+#include <asm/arch-mvebu/comphy_hpipe.h>
+
+#define DEFAULT_REFCLK_MHZ		25
+#define PLL_SET_DELAY_US		60
+#define PLL_LOCK_TIMEOUT		10
+#define POLL_16B_REG			1
+#define POLL_32B_REG			0
+
+#define A3700_MAX_USB_CNT		1
+#define A3700_MAX_SATA_CNT		1
+#define A3700_MAX_SDIO_CNT		1
+
+/*************************/
+/* COMPHY SB definitions */
+/************************/
+#define COMPHY_SEL_ADDR			(MVEBU_REGS_BASE + 0x0183FC)
+#define rf_compy_select(lane)		(0x1 << (((lane) == 1) ? 4 : 0))
+
+#define COMPHY_PHY_CFG1_ADDR(lane)	(MVEBU_REGS_BASE + 0x018300 + (lane) * 0x28)
+#define rb_pin_pu_iveref		BIT1
+#define rb_pin_reset_comphy		BIT12
+#define rb_pin_pu_pll			BIT16
+#define rb_pin_pu_rx			BIT17
+#define rb_pin_pu_tx			BIT18
+#define rb_pin_tx_idle			BIT19
+#define rf_gen_rx_sel_shift		22
+#define rf_gen_rx_select		(0xFF << rf_gen_rx_sel_shift)
+#define rf_gen_tx_sel_shift		26
+#define rf_gen_tx_select		(0xFF << rf_gen_tx_sel_shift)
+#define rb_phy_rx_init			BIT30
+
+#define COMPHY_PHY_STAT1_ADDR(lane)	(MVEBU_REGS_BASE + 0x018318 + (lane) * 0x28)
+#define rb_rx_init_done			BIT0
+#define rb_pll_ready_rx			BIT2
+#define rb_pll_ready_tx			BIT3
+
+/******************************/
+/* PCIe/USB/SGMII definitions */
+/******************************/
+
+#define PCIE_BASE			(MVEBU_REGS_BASE + 0x070000)
+#define PCIETOP_BASE			(MVEBU_REGS_BASE + 0x080000)
+#define PCIE_RAMBASE			(MVEBU_REGS_BASE + 0x08C000)
+#define PCIEPHY_BASE			(MVEBU_REGS_BASE + 0x01F000)
+#define PCIEPHY_SHFT			2
+
+#define USB32_BASE			(MVEBU_REGS_BASE + 0x050000) /* usb3 device */
+#define USB32H_BASE			(MVEBU_REGS_BASE + 0x058000) /* usb3 host */
+#define USB3PHY_BASE			(MVEBU_REGS_BASE + 0x05C000)
+#define USB2PHY_BASE			(MVEBU_REGS_BASE + 0x05D000)
+#define USB32_CTRL_BASE			(MVEBU_REGS_BASE + 0x05D800)
+#define USB3PHY_SHFT			2
+
+#define SGMIIPHY_BASE(lane)		(lane == 1 ? USB3PHY_BASE : PCIEPHY_BASE)
+#define SGMIIPHY_ADDR(lane, addr)	(((addr & 0x00007FF) * 2) | SGMIIPHY_BASE(lane))
+
+#define phy_read16(lane, addr)			read16((void __iomem *)SGMIIPHY_ADDR(lane, addr))
+#define phy_write16(lane, addr, data, mask)	reg_set16((void __iomem *)SGMIIPHY_ADDR(lane, addr), data, mask)
+
+/* units */
+#define PCIE				1
+#define USB3				2
+
+#define PHY_BASE(unit)			((unit == PCIE) ? PCIEPHY_BASE : USB3PHY_BASE)
+#define PHY_SHFT(unit)			((unit == PCIE) ? PCIEPHY_SHFT : USB3PHY_SHFT)
+
+#define PWR_PLL_CTRL_ADDR(unit)		(0x01 * PHY_SHFT(unit) + PHY_BASE(unit))
+
+#define PHY_REG_KVCO_CAL_CTRL_ADDR	0x02	/* for phy_read16 and phy_write16 */
+#define KVCO_CAL_CTRL_ADDR(unit)	(PHY_REG_KVCO_CAL_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
+#define rb_use_max_pll_rate		BIT12
+#define rb_force_calibration_done	BIT9
+
+#define DIG_LB_EN_ADDR(unit)		(0x23 * PHY_SHFT(unit) + PHY_BASE(unit))
+
+#define PHY_REG_UNIT_CTRL_ADDR		0x48	/* for phy_read16 and phy_write16 */
+#define UNIT_CTRL_ADDR(unit)		(PHY_REG_UNIT_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
+#define rb_idle_sync_en			BIT12
+
+#define MISC_REG0_ADDR(unit)		(0x4F * PHY_SHFT(unit) + PHY_BASE(unit))
+#define rb_clk100m_125m_en		BIT4
+#define rb_clk500m_en			BIT7
+
+#define PHY_REG_IFACE_REF_CLK_CTRL_ADDR		0x51	/* for phy_read16 and phy_write16 */
+#define UNIT_IFACE_REF_CLK_CTRL_ADDR(unit)	(PHY_REG_IFACE_REF_CLK_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
+#define rb_ref1m_gen_div_force			BIT8
+#define rf_ref1m_gen_div_value_shift		0
+#define rf_ref1m_gen_div_value_mask		(0xFF << rf_ref1m_gen_div_value_shift)
+
+#define PHY_REG_ERR_CNT_CONST_CTRL_ADDR		0x6A	/* for phy_read16 and phy_write16 */
+#define UNIT_ERR_CNT_CONST_CTRL_ADDR(unit)	(PHY_REG_ERR_CNT_CONST_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
+#define rb_fast_dfe_enable			BIT13
+
+#define MISC_REG1_ADDR(unit)		(0x73 * PHY_SHFT(unit) + PHY_BASE(unit))
+#define bf_sel_bits_pcie_force		BIT15
+
+#define LANE_CFG0_ADDR(unit)		(0x180 * PHY_SHFT(unit) + PHY_BASE(unit))
+#define LANE_CFG1_ADDR(unit)		(0x181 * PHY_SHFT(unit) + PHY_BASE(unit))
+#define bf_use_max_pll_rate		BIT9
+
+#define LANE_STAT1_ADDR(unit)		(0x183 * PHY_SHFT(unit) + PHY_BASE(unit))
+#define rb_txdclk_pclk_en		BIT0
+
+#define GLOB_PHY_CTRL0_ADDR(unit)	(0x1C1 * PHY_SHFT(unit) + PHY_BASE(unit))
+#define bf_soft_rst			BIT0
+#define bf_mode_refdiv			0x30
+#define rb_mode_core_clk_freq_sel	BIT9
+#define rb_mode_pipe_width_32		BIT3
+
+#define GLOB_CLK_SRC_LO_ADDR(unit)	(0x1C3 * PHY_SHFT(unit) + PHY_BASE(unit))
+#define bf_cfg_sel_20b			BIT15
+
+#define PWR_MGM_TIM1_ADDR(unit)		(0x1D0 * PHY_SHFT(unit) + PHY_BASE(unit))
+
+#define PHY_REF_CLK_ADDR		(0x4814 + PCIE_BASE)
+
+
+#define USB3_CTRPUL_VAL_REG		(0x20 + USB32_BASE)
+#define USB3H_CTRPUL_VAL_REG		(0x3454 + USB32H_BASE)
+#define rb_usb3_ctr_100ns		0xff000000
+
+
+#define USB2_OTG_PHY_CTRL_ADDR		(0x820 + USB2PHY_BASE)
+#define rb_usb2phy_suspm		BIT14
+#define rb_usb2phy_pu			BIT0
+
+#define USB2_PHY_OTG_CTRL_ADDR		(0x34 + USB2PHY_BASE)
+#define rb_pu_otg			BIT4
+
+#define USB2_PHY_CHRGR_DET_ADDR		(0x38 + USB2PHY_BASE)
+#define rb_cdp_en			BIT2
+#define rb_dcp_en			BIT3
+#define rb_pd_en			BIT4
+#define rb_pu_chrg_dtc			BIT5
+#define rb_cdp_dm_auto			BIT7
+#define rb_enswitch_dp			BIT12
+#define rb_enswitch_dm			BIT13
+
+#define USB2_CAL_CTRL_ADDR		(0x8 + USB2PHY_BASE)
+#define rb_usb2phy_pllcal_done		BIT31
+#define rb_usb2phy_impcal_done		BIT23
+
+#define USB2_PLL_CTRL0_ADDR		(0x0 + USB2PHY_BASE)
+#define rb_usb2phy_pll_ready		BIT31
+
+#define USB2_RX_CHAN_CTRL1_ADDR		(0x18 + USB2PHY_BASE)
+#define rb_usb2phy_sqcal_done		BIT31
+
+/********************/
+/* SATA definitions */
+/********************/
+#define SAHCI_BASE			(MVEBU_REGS_BASE + 0xE0000)
+
+#define rh_vsreg_addr			(SAHCI_BASE + 0x178)
+#define rh_vsreg_data			(SAHCI_BASE + 0x17C)
+#define rh_vs0_a			(SAHCI_BASE + 0xA0)
+#define rh_vs0_d			(SAHCI_BASE + 0xA4)
+
+#define vphy_loopback_reg0		0x223
+#define bs_phyintf_40bit		0x0C00
+#define bs_pll_ready_tx			0x10
+
+#define vphy_power_reg0			0x201
+
+#define vphy_calctl_reg			0x202
+#define bs_max_pll_rate			BIT12
+
+#define vphy_reserve_reg		0x20e
+#define bs_phyctrl_frm_pin		BIT13
+
+#define vsata_ctrl_reg			0x00
+#define bs_phy_pu_pll			BIT6
+
+/*************************/
+/* SDIO/eMMC definitions */
+/*************************/
+#define SDIO_BASE			(MVEBU_REGS_BASE + 0xD8000)
+
+#define SDIO_HOST_CTRL1_ADDR		(SDIO_BASE + 0x28)
+#define SDIO_SDHC_FIFO_ADDR		(SDIO_BASE + 0x12C)
+#define SDIO_CAP_12_ADDR		(SDIO_BASE + 0x40)
+#define SDIO_ENDIAN_ADDR		(SDIO_BASE + 0x1A4)
+#define SDIO_PHY_TIMING_ADDR		(SDIO_BASE + 0x170)
+#define SDIO_PHY_PAD_CTRL0_ADDR		(SDIO_BASE + 0x178)
+#define SDIO_DLL_RST_ADDR		(SDIO_BASE + 0x148)
+
+#endif /* _COMPHY_A3700_H_ */
diff --git a/drivers/phy/comphy_armada_lp.c b/drivers/phy/comphy_armada_lp.c
deleted file mode 100644
index fa0d681..0000000
--- a/drivers/phy/comphy_armada_lp.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
-* ***************************************************************************
-* Copyright (C) 2015 Marvell International Ltd.
-* ***************************************************************************
-* This program is free software: you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the Free
-* Software Foundation, either version 2 of the License, or any later version.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program.  If not, see <http://www.gnu.org/licenses/>.
-* ***************************************************************************
-*/
-
-#define DEBUG
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch-mvebu/comphy.h>
-#include <asm/arch-mvebu/comphy_hpipe.h>
-#include <asm/arch-mvebu/mvebu.h>
-
-/***************************************************************************************************
-  * comphy_pcie_power_up
- ***************************************************************************************************/
-static int comphy_pcie_power_up(u32 lane, void __iomem *hpipe_base_addr, void __iomem *comphy_base_addr)
-{
-	debug_enter();
-
-	debug_exit();
-
-	/* Return the status of the PLL */
-	return 1;
-}
-
-/***************************************************************************************************
-  * comphy_armada_lp_init
- ***************************************************************************************************/
-int comphy_armada_lp_init(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_map *serdes_map)
-{
-	struct comphy_map *ptr_comphy_map;
-	void __iomem *comphy_base_addr, *hpipe_base_addr;
-	u32 comphy_max_count, lane, ret = 0;
-
-	debug_enter();
-
-	comphy_base_addr = ptr_chip_cfg->comphy_base_addr;
-	comphy_max_count = ptr_chip_cfg->comphy_lanes_count;
-	hpipe_base_addr = ptr_chip_cfg->hpipe3_base_addr;
-
-	for (lane = 0, ptr_comphy_map = serdes_map; lane < comphy_max_count; lane++, ptr_comphy_map++) {
-		debug("Initialize serdes number %d\n", lane);
-		debug("Serdes type = 0x%x\n", ptr_comphy_map->type);
-		switch (ptr_comphy_map->type) {
-		case UNCONNECTED:
-			continue;
-			break;
-		case PEX0:
-			ret = comphy_pcie_power_up(lane, hpipe_base_addr, comphy_base_addr);
-			udelay(20);
-			break;
-		default:
-			debug("Unknown SerDes type, skip initialize SerDes %d\n", lane);
-			break;
-		}
-		if (ret == 0)
-			error("PLL is not locked - Failed to initialize lane %d\n", lane);
-	}
-
-	debug_exit();
-	return 0;
-}
diff --git a/drivers/phy/comphy_core.c b/drivers/phy/comphy_core.c
index 23d66af..5e00108 100644
--- a/drivers/phy/comphy_core.c
+++ b/drivers/phy/comphy_core.c
@@ -15,7 +15,7 @@
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * ***************************************************************************
 */
-/* #define DEBUG */
+#define DEBUG
 #include <common.h>
 #include <fdtdec.h>
 #include <asm/io.h>
@@ -40,7 +40,7 @@ struct chip_serdes_phy_config chip_config[] = {
 #endif
 #ifdef CONFIG_TARGET_ARMADA_LP
 	{.compat = COMPAT_COMPHY_ARMADA_LP,
-	 .ptr_comphy_chip_init = comphy_armada_lp_init },
+	 .ptr_comphy_chip_init = comphy_a3700_init },
 #endif
 	{.compat = COMPAT_UNKNOWN}
 };
@@ -94,6 +94,23 @@ void reg_set_silent(void __iomem *addr, u32 data, u32 mask)
 	writel(reg_data, addr);
 }
 
+void reg_set16(void __iomem *addr, u16 data, u16 mask)
+{
+	debug("Write to address = %#010lx, data = %#06x (mask = %#06x) - ", (unsigned long)addr, data, mask);
+	debug("old value = %#06x ==> ", readw(addr));
+	reg_set_silent16(addr, data, mask);
+	debug("new value %#06x\n", readw(addr));
+}
+
+void reg_set_silent16(void __iomem *addr, u16 data, u16 mask)
+{
+	u16 reg_data;
+	reg_data = readw(addr);
+	reg_data &= ~mask;
+	reg_data |= data;
+	writew(reg_data, addr);
+}
+
 void comphy_print(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_map *comphy_map_data)
 {
 	u32 lane;
diff --git a/include/fdtdec.h b/include/fdtdec.h
index 6196fb6..8de03fb 100644
--- a/include/fdtdec.h
+++ b/include/fdtdec.h
@@ -129,6 +129,8 @@ enum fdt_compat_id {
 	COMPAT_MVEBU_I2C,
 	COMPAT_MVEBU_ARLP_I2C,
 	COMPAT_MVEBU_SATA,
+	COMPAT_MVEBU_USB,
+	COMPAT_MVEBU_SDIO,
 	COMPAT_MVEBU_SAR,
 	COMPAT_MVEBU_PINCTL,
 	COMPAT_MVEBU_MPP_BUS,
-- 
1.9.1

