From c06a2ead91963f3850c730bd437fa6ef8c87f732 Mon Sep 17 00:00:00 2001
From: Konstantin Porotchkin <kostap@marvell.com>
Date: Wed, 2 Dec 2015 11:50:43 +0200
Subject: [PATCH 0576/1240] clock: a3700: Add clock configuration functions

- Add functions allowing flexible clock setup
  according to a static array defining the entire
  clock tree configurations
- Add DDR clock configuration function
- Add 3 static clocks tree configurations.
- Remove old clock initialization functions

Change-Id: I24e5f144f12212ab77463fbcace7e84566960ea4
Signed-off-by: Konstantin Porotchkin <kostap@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/25551
Reviewed-by: Wilson Ding <dingwei@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Tested-by: Hanna Hawa <hannah@marvell.com>
---
 arch/arm/cpu/armv8/armadalp/mvebu_clock.c      | 789 +++++++++++++++++++------
 arch/arm/include/asm/arch-armadalp/clock.h     | 494 ++++++++++++++++
 arch/arm/include/asm/arch-armadalp/regs-base.h |   4 +-
 drivers/phy/comphy_a3700.c                     |  22 +-
 4 files changed, 1115 insertions(+), 194 deletions(-)
 create mode 100644 arch/arm/include/asm/arch-armadalp/clock.h

diff --git a/arch/arm/cpu/armv8/armadalp/mvebu_clock.c b/arch/arm/cpu/armv8/armadalp/mvebu_clock.c
index 72bcc47..e89057b 100644
--- a/arch/arm/cpu/armv8/armadalp/mvebu_clock.c
+++ b/arch/arm/cpu/armv8/armadalp/mvebu_clock.c
@@ -15,201 +15,634 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  * ***************************************************************************
  */
-
+/*#define DEBUG*/
 #include <common.h>
+#include <fdtdec.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/fdt.h>
 #include <asm/arch-mvebu/mvebu.h>
-#include <asm/arch-mvebu/clock.h>
+#include <asm/arch-armadalp/clock.h>
 #include <asm/io.h>
 
-/* north bridge clock source register */
-#define MVEBU_NORTH_CLOCK_SELEC_REG	0x10
-
-#define WCPU_CLK_SEL		(1 << 15)
-#define COUNTER_CLK_SEL		(1 << 13)
-#define TRACE_CLK_SEL		(1 << 12)
-#define DDR_FCLK_CLK_SEL	(1 << 11)
-#define DDR_PHY_CLK_SEL		(1 << 10)
-#define EIP97_CLK_SEL		(1 << 9)
-#define PWM_CLK_SEL		(1 << 8)
-#define SQF_CLK_SEL		(1 << 7)
-#define AVS_CLK_SEL		(1 << 6)
-#define SETM_TMX_CLK_SEL	(1 << 5)
-#define TSECM_CLK_SEL		(1 << 4)
-#define SEC_DAP_CLK_SEL		(1 << 3)
-#define SEC_AT_CLK_SEL		(1 << 2)
-#define SATA_HOST_CLK_SEL	(1 << 1)
-#define MMC_CLK_SEL		(1 << 0)
-/* change all clock source to PLL */
-#define NB_PLL_CLK_SOURCES	(WCPU_CLK_SEL | COUNTER_CLK_SEL | TRACE_CLK_SEL | DDR_FCLK_CLK_SEL |\
-				DDR_PHY_CLK_SEL | EIP97_CLK_SEL | PWM_CLK_SEL | SQF_CLK_SEL |\
-				AVS_CLK_SEL | SETM_TMX_CLK_SEL | TSECM_CLK_SEL | SEC_DAP_CLK_SEL |\
-				SEC_AT_CLK_SEL | SATA_HOST_CLK_SEL | MMC_CLK_SEL)
-
-/* north bridge clock enable register */
-#define MVEBU_NORTH_CLOCK_ENABLE_REG	0x14
-#define SB_AXI_CLK_EN		(0 << 27)
-#define EIP97_CLK_EN		(0 << 26)
-#define SATA_HOST_AXI_CLK_EN	(0 << 25)
-#define ATB_CLK_EN		(0 << 24)
-#define COUNTER_CLK_EN		(0 << 23)
-#define TRACE_CLK_EN		(0 << 22)
-#define DDR_FCLK_CLK_EN		(0 << 21)
-#define DDR_PHY_MCK_CLK_EN	(0 << 19)
-#define DDR_AXI_CLK_EN		(0 << 18)
-#define TWSI_1_CLK_EN		(0 << 17)
-#define TWSI_2_CLK_EN		(0 << 16)
-#define SEC_AXI_CLK_EN		(0 << 15)
-#define PWM_CLK_EN		(0 << 13)
-#define SQF_CLK_EN		(0 << 12)
-#define AVS_CLK_EN		(0 << 11)
-#define SETM_TMX_CLK_EN		(0 << 10)
-#define DMA_CLK_EN		(0 << 9)
-#define TSECM_CLK_EN		(0 << 8)
-#define SEC_DAP_CLK_EN		(0 << 7)
-#define SEC_AT_CLK_EN		(0 << 6)
-#define SEC_XTAL_CLK_EN		(0 << 5)
-#define CPU_CNT_EN		(0 << 4)
-#define SATA_HOST_CLK_EN	(0 << 3)
-#define MMC_CLK_CLK_EN		(0 << 2)
-#define MMC_SYSBUS_CLK_EN	(0 << 1)
-#define MMC_DEBOUNCE_CLK_EN	(0 << 0)
-
-/* enable all the north bridge clocks by default */
-#define NB_CLK_ENABLE		(SB_AXI_CLK_EN | EIP97_CLK_EN | SATA_HOST_AXI_CLK_EN | ATB_CLK_EN |\
-				COUNTER_CLK_EN | TRACE_CLK_EN | DDR_FCLK_CLK_EN | DDR_PHY_MCK_CLK_EN |\
-				DDR_AXI_CLK_EN | TWSI_1_CLK_EN | TWSI_2_CLK_EN | SEC_AXI_CLK_EN |\
-				PWM_CLK_EN | SQF_CLK_EN | AVS_CLK_EN | SETM_TMX_CLK_EN |\
-				DMA_CLK_EN | TSECM_CLK_EN | SEC_DAP_CLK_EN | SEC_AT_CLK_EN |\
-				SEC_XTAL_CLK_EN | CPU_CNT_EN | SATA_HOST_CLK_EN | MMC_CLK_CLK_EN |\
-				MMC_SYSBUS_CLK_EN | TSECM_CLK_EN)
-
-/* south bridge clock source register */
-#define MVEBU_SOUTH_CLOCK_SELEC_REG	0x10
-#define SB_AXI_CLK_SEL		(1 << 10)
-#define USB32_SS_SYS_CLK_SEL	(1 << 9)
-#define USB32_USB2_SYS_CLK_SEL	(1 << 8)
-#define SDIO_CLK_SEL		(1 << 7)
-#define GBE_CORE_CLK_SEL	(1 << 5)
-#define GBE_125_CLK_SEL		(1 << 3)
-#define GBE_50_CLK_SEL		(1 << 1)
-
-#define SB_PLL_CLK_SOURCES	(SB_AXI_CLK_SEL | USB32_SS_SYS_CLK_SEL | USB32_USB2_SYS_CLK_SEL |\
-				SDIO_CLK_SEL | GBE_CORE_CLK_SEL | GBE_125_CLK_SEL | GBE_50_CLK_SEL)
-
-/* south bridge clock enable register */
-#define MVEBU_SOUTH_CLOCK_ENABLE_REG	0x14
-#define GBE0_PWR_UP_CLK_EN	(1 << 20)
-#define GBE1_PWR_UP_CLK_EN	(1 << 19)
-#define USB32_AXI_CLK_EN	(0 << 18)
-#define USB32_SS_SYS_CLK_EN	(0 << 17)
-#define USB32_USB2_SYS_CLK_EN	(0 << 16)
-#define USB2_HOST_CLK_EN	(0 << 15)
-#define PCIE_CLKK_EN		(0 << 14)
-#define USB32_REF_CLK_EN	(0 << 13)
-#define USB2_HOST_REF_CLK_EN	(0 << 12)
-#define SDIO_CLK_EN		(0 << 11)
-#define SDIO_SYSBUS_CLK_EN	(0 << 10)
-#define GBE_BM_CORE_CLK_EN	(0 << 9)
-#define GBE_BM_AXI_CLK_EN	(0 << 8)
-#define GBE0_AXI_CLK_EN		(0 << 7)
-#define GBE1_AXI_CLK_EN		(0 << 6)
-#define GBE0_CORE_CLK_EN	(0 << 5)
-#define GBE1_CORE_CLK_EN	(0 << 4)
-#define GBE0_125_CLK_EN		(0 << 3)
-#define GBE1_125_CLK_EN		(0 << 2)
-#define GBE0_50_CLK_DIS_EN	(0 << 1)
-#define GBE1_50_CLK_DIS_EN	(0 << 0)
-/* enable all the south bridge clocks by default */
-#define SB_CLK_ENABLE		(GBE0_PWR_UP_CLK_EN | GBE1_PWR_UP_CLK_EN | USB32_AXI_CLK_EN | USB32_SS_SYS_CLK_EN |\
-				USB32_USB2_SYS_CLK_EN | USB2_HOST_CLK_EN | PCIE_CLKK_EN | USB32_REF_CLK_EN |\
-				USB2_HOST_REF_CLK_EN | SDIO_CLK_EN | SDIO_SYSBUS_CLK_EN | GBE_BM_CORE_CLK_EN |\
-				GBE_BM_AXI_CLK_EN | GBE0_AXI_CLK_EN | GBE1_AXI_CLK_EN | GBE0_CORE_CLK_EN |\
-				GBE1_CORE_CLK_EN | GBE0_125_CLK_EN | GBE1_125_CLK_EN | GBE0_50_CLK_DIS_EN |\
-				GBE1_50_CLK_DIS_EN)
-
-/* south bridge clock enable register */
-#define MVEBU_SOUTH_CLOCK_TBG_SELECT_REG		0x0
-#define MVEBU_SOUTH_CLOCK_GBE_125_CLK_SEL_OFFSET	(10)
-#define MVEBU_SOUTH_CLOCK_GBE_125_CLK_SEL_MASK	(0x3)
-#define MVEBU_SOUTH_CLOCK_CLK_SCR_SEL_TBG_B_S	(3)
-
-#define MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG	0x8
-#define MVEBU_SOUTH_CLOCK_GBE_125_CLK_PRSCL_MASK	(0x7)
-#define MVEBU_SOUTH_CLOCK_GBE_125_CLK_PRSCL1_OFF	(9)
-#define MVEBU_SOUTH_CLOCK_GBE_125_CLK_PRSCL2_OFF	(6)
-
-#define MVEBU_SOUTH_CLOCK_DIVIDER_2			(2)
-#define MVEBU_SOUTH_CLOCK_DIVIDER_3			(3)
-
-void init_a3700_neta_clock(void)
+static struct a3700_clock_cfg a3700_clock_configs[] = MVEBU_A3700_CLOCK_CFGS;
+
+/* TODO: Move to dedicated DDR driver */
+static u32 init_ddr_clock(u32 ddr_clock_mhz)
 {
-	u32 reg_value;
-
-	/* configure GBE_125 clock */
-	/* with default configuration, GBE_125 clock source is TBG-A_S, and it gets 75MHz,
-	  * which is not enough (125MHz), TX would not work in 1GB mode.
-	  * To get a right clock, change GBE_125 clock source to be TBG-B_S, change
-	  * GBE 125MHz clock prescalar_1 from 4 to 3, and prescalar_2 from 4 to 2,
-	  * this way GBE_125 gets 133.33MHz, which is not perfect, but it works for
-	  * GBE TX in 1GB mode.
-	  */
-	/* change clock source */
-	reg_value = readl(MVEBU_SOUTH_CLOCK_REGS_BASE + MVEBU_SOUTH_CLOCK_TBG_SELECT_REG);
-	reg_value = reg_value & ~(MVEBU_SOUTH_CLOCK_GBE_125_CLK_SEL_MASK << MVEBU_SOUTH_CLOCK_GBE_125_CLK_SEL_OFFSET);
-	reg_value = reg_value | (MVEBU_SOUTH_CLOCK_CLK_SCR_SEL_TBG_B_S << MVEBU_SOUTH_CLOCK_GBE_125_CLK_SEL_OFFSET);
-	writel(reg_value, MVEBU_SOUTH_CLOCK_REGS_BASE + MVEBU_SOUTH_CLOCK_TBG_SELECT_REG);
-	debug("South bridge CLK_TBG_SEL are 0x%x\n",
-	      readl(MVEBU_SOUTH_CLOCK_REGS_BASE + MVEBU_SOUTH_CLOCK_TBG_SELECT_REG));
-
-	/* change gbe_125 prescalor value */
-	reg_value = readl(MVEBU_SOUTH_CLOCK_REGS_BASE + MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG);
-	/* set prescalor 1 */
-	reg_value = reg_value & ~(MVEBU_SOUTH_CLOCK_GBE_125_CLK_PRSCL_MASK << MVEBU_SOUTH_CLOCK_GBE_125_CLK_PRSCL1_OFF);
-	reg_value = reg_value | (MVEBU_SOUTH_CLOCK_DIVIDER_3 << MVEBU_SOUTH_CLOCK_GBE_125_CLK_PRSCL1_OFF);
-	/* set prescalor 2 */
-	reg_value = reg_value & ~(MVEBU_SOUTH_CLOCK_GBE_125_CLK_PRSCL_MASK << MVEBU_SOUTH_CLOCK_GBE_125_CLK_PRSCL2_OFF);
-	reg_value = reg_value | (MVEBU_SOUTH_CLOCK_DIVIDER_2 << MVEBU_SOUTH_CLOCK_GBE_125_CLK_PRSCL2_OFF);
-	writel(reg_value, MVEBU_SOUTH_CLOCK_REGS_BASE + MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG);
-	debug("South bridge CLK_PRSCL are 0x%x\n",
-	      readl(MVEBU_SOUTH_CLOCK_REGS_BASE + MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG));
-
-	return;
+	u32	regval;
+
+	debug_enter();
+
+	writel(0x00404500, MVEBU_REGS_BASE + 0x00014008);
+	writel(0x00010000, MVEBU_REGS_BASE + 0x00002000);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x00002004);
+	writel(0x0f0f0fef, MVEBU_REGS_BASE + 0x00000340);
+	writel(0x100000aa, MVEBU_REGS_BASE + 0x00000344);
+	writel(0x00200000, MVEBU_REGS_BASE + 0x00000310);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x00000304);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x00000308);
+
+	writel(0x000E0001, MVEBU_REGS_BASE + 0x00000200);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x00000204);
+	writel(0x13020532, MVEBU_REGS_BASE + 0x00000220);
+	writel(0x00030200, MVEBU_REGS_BASE + 0x00000044);
+	writel(0x00006000, MVEBU_REGS_BASE + 0x000002c0);
+	writel(0x00100020, MVEBU_REGS_BASE + 0x000002c4);
+	writel(0x0000143f, MVEBU_REGS_BASE + 0x00000058);
+	writel(0x00000001, MVEBU_REGS_BASE + 0x00000048);
+	writel(0x00010200, MVEBU_REGS_BASE + 0x00000180);
+	writel(0x000001ff, MVEBU_REGS_BASE + 0x00000050);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x0000004c);
+	writel(0x00000480, MVEBU_REGS_BASE + 0x00000054);
+
+	if (ddr_clock_mhz == 800) {
+		/* ddr_clock_mhz == 800 */
+
+		writel(0x0000080B, MVEBU_REGS_BASE + 0x00000300);
+
+		/* DRAM Initialization Timing Control Register
+		   note: the following 3 registers are related to CPU clock */
+		writel(0x0007A120, MVEBU_REGS_BASE + 0x00000380);
+		writel(0x00030D40, MVEBU_REGS_BASE + 0x00000384);
+		writel(0x0960006B, MVEBU_REGS_BASE + 0x00000388);
+
+		writel(0x00000200, MVEBU_REGS_BASE + 0x0000038c);
+		writel(0x00400100, MVEBU_REGS_BASE + 0x00000390);
+		writel(0x00F003CF, MVEBU_REGS_BASE + 0x00000394);
+		writel(0x00F80200, MVEBU_REGS_BASE + 0x00000398);
+		writel(0x00000808, MVEBU_REGS_BASE + 0x0000039c);
+		writel(0x00040614, MVEBU_REGS_BASE + 0x000003a0);
+		writel(0x00000001, MVEBU_REGS_BASE + 0x000003a4);
+		writel(0x00000c04, MVEBU_REGS_BASE + 0x000003a8);
+		writel(0x202A0C1F, MVEBU_REGS_BASE + 0x000003ac);
+		writel(0x0C0C060C, MVEBU_REGS_BASE + 0x000003b0);
+		writel(0x04000600, MVEBU_REGS_BASE + 0x000003b4);
+		writel(0x00000800, MVEBU_REGS_BASE + 0x000003b8);
+
+		/* ddr_clock_mhz == 800 */
+	} else if (ddr_clock_mhz == 600) {
+		/* ddr_clock_mhz == 600 */
+
+		writel(0x00000708, MVEBU_REGS_BASE + 0x00000300);
+
+		/* DRAM Initialization Timing Control Register
+		   note: the following 3 registers are related to CPU clock */
+		writel(0x000001F5, MVEBU_REGS_BASE + 0x00000380);
+		writel(0x000003E9, MVEBU_REGS_BASE + 0x00000384);
+		writel(0x09600043, MVEBU_REGS_BASE + 0x00000388);
+
+		writel(0x00000200, MVEBU_REGS_BASE + 0x0000038c);
+		writel(0x00400100, MVEBU_REGS_BASE + 0x00000390);
+		writel(0x006B03CF, MVEBU_REGS_BASE + 0x00000394);
+		writel(0x00720200, MVEBU_REGS_BASE + 0x00000398);
+		writel(0x00120707, MVEBU_REGS_BASE + 0x0000039c);
+		writel(0x00040511, MVEBU_REGS_BASE + 0x000003a0);
+		writel(0x00000001, MVEBU_REGS_BASE + 0x000003a4);
+		writel(0x00000C04, MVEBU_REGS_BASE + 0x000003a8);
+		writel(0x15210919, MVEBU_REGS_BASE + 0x000003ac);
+		writel(0x090b0609, MVEBU_REGS_BASE + 0x000003b0);
+		writel(0x04000600, MVEBU_REGS_BASE + 0x000003b4);
+		writel(0x00000600, MVEBU_REGS_BASE + 0x000003b8);
+		/* ddr_clock_mhz == 600 */
+	} else {
+		error("Unsupported DDR clock - %d MHz\n", ddr_clock_mhz);
+		return 1;
+	}
+
+
+	writel(0x02020404, MVEBU_REGS_BASE + 0x000003bc);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x000003c0);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x000003c4);
+	writel(0x00081239, MVEBU_REGS_BASE + 0x000003dc);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x000002c8);
+	writel(0x00000006, MVEBU_REGS_BASE + 0x00000064);
+	writel(0x10077779, MVEBU_REGS_BASE + 0x00001004);
+	writel(0x1ff00770, MVEBU_REGS_BASE + 0x00001008);
+	writel(0x3f03fc77, MVEBU_REGS_BASE + 0x0000100c);
+	writel(0x00100118, MVEBU_REGS_BASE + 0x00001010);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x00001028);
+	writel(0x03800000, MVEBU_REGS_BASE + 0x00001030);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x00001034);
+	writel(0x00000400, MVEBU_REGS_BASE + 0x00001040);
+	writel(0x80000001, MVEBU_REGS_BASE + 0x000010c0);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x000010d0);
+	writel(0x00011ff0, MVEBU_REGS_BASE + 0x000010e0);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x00001090);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x00001094);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x00001098);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x0000109c);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x000010a0);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x000010a4);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x000010a8);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x000010ac);
+	writel(0x00000000, MVEBU_REGS_BASE + 0x000010b0);
+
+	/* dq_ext_dly: 3:0 */
+	writel(0x00044041, MVEBU_REGS_BASE + 0x00001000);
+	writel(0x00080200, MVEBU_REGS_BASE + 0x00001014);
+	writel(0x00000002, MVEBU_REGS_BASE + 0x00001038);
+	writel(0x00000010, MVEBU_REGS_BASE + 0x0000103c);
+
+	/*phy_rl_cycle_dly 11:8 */
+	writel(0x0000020a, MVEBU_REGS_BASE + 0x00001180);
+	writel(0x0000020a, MVEBU_REGS_BASE + 0x00001184);
+	writel(0x0000020a, MVEBU_REGS_BASE + 0x00001188);
+	writel(0x0000020a, MVEBU_REGS_BASE + 0x0000118c);
+	writel(0x0000020a, MVEBU_REGS_BASE + 0x00001190);
+	writel(0x0000020a, MVEBU_REGS_BASE + 0x00001194);
+	writel(0x0000020a, MVEBU_REGS_BASE + 0x00001198);
+	writel(0x0000020a, MVEBU_REGS_BASE + 0x0000119c);
+	writel(0x0000020a, MVEBU_REGS_BASE + 0x000011a0);
+
+	if (ddr_clock_mhz == 800) {
+		/* ddr_clock_mhz == 800 */
+		writel(0x20200000, MVEBU_REGS_BASE + 0x00001050);
+		writel(0x20200000, MVEBU_REGS_BASE + 0x00001054);
+		writel(0x20200000, MVEBU_REGS_BASE + 0x00001074);
+		/* ddr_clock_mhz == 800 */
+	} else if (ddr_clock_mhz == 600) {
+		/* ddr_clock_mhz == 600 */
+		writel(0x08080000, MVEBU_REGS_BASE + 0x00001050);
+		writel(0x08080000, MVEBU_REGS_BASE + 0x00001054);
+		/* ddr_clock_mhz == 600 */
+	}
+
+	writel(0x08080000, MVEBU_REGS_BASE + 0x00001058);
+	writel(0x08080000, MVEBU_REGS_BASE + 0x0000105c);
+	writel(0x08080000, MVEBU_REGS_BASE + 0x00001060);
+	writel(0x08080000, MVEBU_REGS_BASE + 0x00001064);
+	writel(0x08080000, MVEBU_REGS_BASE + 0x00001068);
+	writel(0x08080000, MVEBU_REGS_BASE + 0x0000106c);
+	writel(0x08080000, MVEBU_REGS_BASE + 0x00001070);
+
+	writel(0x20000000, MVEBU_REGS_BASE + 0x00001020);
+	writel(0x40000000, MVEBU_REGS_BASE + 0x00001020);
+	writel(0x80000000, MVEBU_REGS_BASE + 0x00001020);
+
+	writel(0x11000001, MVEBU_REGS_BASE + 0x00000020);
+
+	/* wait for ddr init done */
+	do {
+		regval = readl(MVEBU_REGS_BASE + 0x00000008) & BIT0;
+	} while (!regval);
+
+	debug_exit();
+	return 0;
 }
 
-int init_a3700_clock(void)
+/***************************************************************************************************
+  * get_a3700_ref_clk
+  *
+  * return: reference clock in MHz (25 or 40)
+ ***************************************************************************************************/
+u32 get_a3700_ref_clk(void)
 {
-	int ret = 0;
+	u32 regval;
+
+	regval = (readl(MVEBU_TEST_PIN_LATCH_N) & MVEBU_XTAL_MODE_MASK) >> MVEBU_XTAL_MODE_OFFS;
+
+	if (regval == MVEBU_XTAL_CLOCK_25MHZ)
+		return 25;
+	else
+		return 40;
+}
+
+/******************************************************************************
+* Name: get_a3700_tbg_vco_sel
+*
+* Description:	calculate the vco parameters for TBG based on the target clock.
+*
+* Input:	kvco_mhz - KVCO clock freq in MHz
+*
+* Output:	vco_intpi - Phase Interpolator Bias Current
+*		vco_range - VCO frequency range (0x8 - 0xF)
+*
+* Return: 0 - OK
+******************************************************************************/
+static int get_a3700_tbg_vco_sel(u32 kvco_mhz,
+				 u32 *vco_intpi,
+				 u32 *vco_range)
+{
+	u8  index;
+	u16 vco_top_ranges_mhz[8] = {1350, 1500, 1750, 2000, 2200, 2400, 2600, 3000};
 
 	debug_enter();
 
-	/* Both of north and south bridge clocks will be enabled by default.
-	 * But most of the clock sources will be from XTAL by default.
-	 * need to change clock sources from XTAL to PLL and enable all the clocks again.
+	if ((kvco_mhz <= MVEBU_KVCO_MIN) && (kvco_mhz >= MVEBU_KVCO_MAX)) {
+		error("Invalid KVCO CLK requested - %d MHz\n", kvco_mhz);
+		return 1;
+	}
+
+	/* Select the range the KVCO fits to.
+	   Valid values are 0x8 through 0xF.
+	   See TBG_A_KVCO and TBG_B_KVCO fields for details
+	 */
+	for (index = 0; index < 8; index++) {
+		if (kvco_mhz <= vco_top_ranges_mhz[index]) {
+			*vco_range = index + 8;
+			break;
+		}
+	}
+
+	/* INTPI - Phase Interpolator Bias Current
+	  8 <= KVCO is 2.5 ~ 3.0 GHz,
+	  6 <= KVCO is 2.0 ~ 2.5 GHz,
+	  5 <= KVCO is 1.5 ~ 2.0 GHz
 	 */
-	/* change north bridge clock source from XTAL to clock divider */
-	writel(NB_PLL_CLK_SOURCES, MVEBU_NORTH_CLOCK_REGS_BASE + MVEBU_NORTH_CLOCK_SELEC_REG);
-	debug("North bridge clock source is set to 0x%x\n",
-	      readl(MVEBU_NORTH_CLOCK_REGS_BASE + MVEBU_NORTH_CLOCK_SELEC_REG));
+	if (kvco_mhz > 2500)
+		*vco_intpi = 8;
+	else if (kvco_mhz < 2000)
+		*vco_intpi = 5;
+	else
+		*vco_intpi = 6;
+
+	debug_exit();
+	return 0;
+}
+
+/******************************************************************************
+* Name: set_a3700_tbg_clock
+*
+* Description:	Change the TBG(A/B) clock
+*		All affected North/South bridge clock sources should be
+*		switched to XTAL mode prior to calling this function!
+*
+* Input:	kvco_mhz:     AKVCO clock for TBG-X in MHz
+*		se_vco_div:   single-ended clock VCO divider (TBG_X_S)
+*		diff_vco_div: differential clock VCO post divider (TBG_X_P)
+*		tbg_typ:      TBG type (A/B)
+* Output:	None
+* Return:	0 if OK
+******************************************************************************/
+static u32 set_a3700_tbg_clock(u32 kvco_mhz,
+			       u32 se_vco_div,
+			       u32 diff_vco_div,
+			       enum a3700_clock_src tbg_typ)
+{
+	u32 vco_range = 0, vco_intpi = 0;
+	u32 tbg_M, tbg_N;
+	u32 icp;
+	u32 regval;
+	int ret;
+
+	debug_enter();
+
+	/* Try to keep Fref/M as close as possible to 10 MHz */
+	if (get_a3700_ref_clk() == 40) {
+		/* 40MHz */
+		debug("REF clock is 40MHz\n");
+		tbg_M = 4;	/* 10MHz */
+		icp = 5;	/* 8 */
+	} else	{
+		/* 25MHz */
+		debug("REF clock is 25MHz\n");
+		tbg_M = 3;	/* 8.33MHz */
+		icp = 6;	/* 9 */
+	}
+
+	ret = get_a3700_tbg_vco_sel(kvco_mhz, &vco_intpi, &vco_range);
+	if (ret != 0) {
+		error("Failed to obtain VCO divider selection\n");
+		return ret;
+	}
+
+	/* TBG frequency is calculated according to formula:
+		Ftbg = Fkvco / se_vco_div
+	   where
+		Fkvco = N * Fref * 4 / M
+
+	   N - TBG_A_FBDIV or TBG_B_FBDIV
+	   M - TBG_A_REFDIV or TBG_B_REFDIV
+	   se_vco_div - TBG_A_VCODIV_SEL_SE or TBG_B_VCODIV_SEL_SE
+	   Fref - reference clock 25MHz or 40 MHz
+	  */
+	tbg_N = (kvco_mhz * tbg_M / get_a3700_ref_clk()) >> 2;
+	debug("TBG-%s: SE vco_div %#x, DIFF vco_div %#x,vco_range %#x tbg_N %#x KVCO = %d MHz\n",
+	      tbg_typ == TBG_A ? "A" : "B", se_vco_div, diff_vco_div, vco_range, tbg_N, kvco_mhz);
+
+	/* 1. Switch all North/South Bridge clock sources to XTAL
+	      Should be already done by the function caller */
+
+	/* 2. Set TBG-A (bit[0]) or TBG-B (bit[16]) to reset state  */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
+	regval |= (tbg_typ == TBG_A) ? BIT0 : BIT16;
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
+
+	/* The A3700 FS requires to power down TGB before
+	   changing PLL parameters. However it turns out that
+	   this step is not essential. Putting TBG into reset
+	   state is enough.
+	   3. Power down TBG-A (bit[1]) or TBG-B (bit[17])
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
+	regval |= (tbg_typ == TBG_A) ? BIT1 : BIT17;
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
+	*/
 
-	/* enable north bridge clocks */
-	writel(NB_CLK_ENABLE, MVEBU_NORTH_CLOCK_REGS_BASE + MVEBU_NORTH_CLOCK_ENABLE_REG);
-	debug("North bridge clocks are enabled 0x%x\n",
-	      readl(MVEBU_NORTH_CLOCK_REGS_BASE + MVEBU_NORTH_CLOCK_ENABLE_REG));
+	/* 4. Set TBG-A (bit[10:2]) or TBG-B (bit[26:18]) FBDIV (N) value */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
+	regval &= (tbg_typ == TBG_A) ? ~(0xFFUL << 2) : ~(0xFFUL << 18);
+	regval |= (tbg_typ == TBG_A) ? (tbg_N << 2) : (tbg_N << 18);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
 
-	/* change south bridge clock source from XTAL to clock divider */
-	writel(SB_PLL_CLK_SOURCES, MVEBU_SOUTH_CLOCK_REGS_BASE + MVEBU_SOUTH_CLOCK_SELEC_REG);
-	debug("South bridge clock source is set to 0x%x\n",
-	      readl(MVEBU_SOUTH_CLOCK_REGS_BASE + MVEBU_SOUTH_CLOCK_SELEC_REG));
+	/* 5. Set TBG-A (bit[8:0]) or TBG-B (bit[24:16]) REFDIV (M) value */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL7);
+	regval &= (tbg_typ == TBG_A) ? ~(0x1FFUL << 0) : ~(0x1FFUL << 16);
+	regval |= (tbg_typ == TBG_A) ? (tbg_M << 0) : (tbg_M << 16);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL7);
 
-	/* enable south bridge clocks */
-	writel(SB_CLK_ENABLE, MVEBU_SOUTH_CLOCK_REGS_BASE + MVEBU_SOUTH_CLOCK_ENABLE_REG);
-	debug("South bridge clocks are enabled 0x%x\n",
-	      readl(MVEBU_SOUTH_CLOCK_REGS_BASE + MVEBU_SOUTH_CLOCK_ENABLE_REG));
+	/* 6a. Set TBG-A (bit[8:0]) or TBG-B (bit[24:16]) SE VCODIV value  */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
+	regval &= (tbg_typ == TBG_A) ? ~(0x1FFUL << 0) : ~(0x1FFUL << 16);
+	regval |= (tbg_typ == TBG_A) ? (se_vco_div << 0) : (se_vco_div << 16);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL1);
 
-	/* configure GBE_125 clock */
-	init_a3700_neta_clock();
+	/* 6b. Set TBG-A (bit[9:1]) or TBG-B (bit[25:17]) DIFF VCODIV value  */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL8);
+	regval &= (tbg_typ == TBG_A) ? ~(0x1FFUL << 1) : ~(0x1FFUL << 17);
+	regval |= (tbg_typ == TBG_A) ? (diff_vco_div << 1) : (diff_vco_div << 17);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL8);
+
+	/* 7. Set TBG-A (bit[11]) or TBG-B (bit[27]) PLL Bandwidth to normal (0x0) */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
+	regval &= (tbg_typ == TBG_A) ? ~(0x1UL << 11) : ~(0x1UL << 27);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL1);
+
+	/* 8. Set TBG-A (bit[11:8]) or TBG-B (bit[27:24]) ICP Charge Pump Current value */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL2);
+	regval &= (tbg_typ == TBG_A) ? ~(0xFUL << 8) : ~(0xFUL << 24);
+	regval |= (tbg_typ == TBG_A) ? (icp << 8) : (icp << 24);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL2);
+
+	/* 9. Set TBG-A (bit[3:0]) or TBG-B (bit[19:16]) KVCO range value  */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL3);
+	regval &= (tbg_typ == TBG_A) ? ~(0xFUL << 0) : ~(0xFUL << 16);
+	regval |= (tbg_typ == TBG_A) ? (vco_range << 0) : (vco_range << 16);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL3);
+
+	/* 10. Set TBG-A (bit[3:0]) or TBG-B (bit[19:16]) INTPI value  */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL2);
+	regval &= (tbg_typ == TBG_A) ? ~(0xFUL << 0) : ~(0xFUL << 16);
+	regval |= (tbg_typ == TBG_A) ? (vco_intpi << 0) : (vco_intpi << 16);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL2);
+
+	/* The A3700 FS requires to power down TGB before
+	   changing PLL parameters. However it turns out that
+	   this step is not essential. Putting TBG into reset
+	   state is enough.
+	   11. Power up TBG-A (bit[1]) or TBG-B (bit[17])
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
+	regval &= (tbg_typ == TBG_A) ? ~(BIT1) : ~(BIT17);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
+	*/
+
+	/* 12. Release TBG-A (bit[0]) or TBG-B (bit[16]) from reset */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
+	regval &= (tbg_typ == TBG_A) ? ~(BIT0) : ~(BIT16);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
+
+	/* 13. Set TBG-A (bit[9]) or TBG-B (bit[25]) Bypass to disable - get CLKOUT from PLL */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
+	regval &= (tbg_typ == TBG_A) ? ~(BIT9) : ~(BIT25);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL1);
+
+	/* 14. Wait for TBG-A (bit[15] and TBG-B (bit[31]) PLL lock */
+	do {
+		regval = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
+		regval &= BIT15 | BIT31;
+	} while (regval != (BIT15 | BIT31));
+
+	/* 15. Switch all North/South Bridge clock sources to clock divider
+	       Will be done by function caller when required */
+
+	/* Wait for stable clock output. The suggested 40us delay has increased
+	   due to wrong couter clock configration in SPL */
+	udelay(5000);
 
 	debug_exit();
-	return ret;
+	return 0;
+}
+
+#ifdef MVEBU_A3700_ENABLE_SSC
+/******************************************************************************
+* Name: set_a3700_ssc
+*
+* Description: Setup Spread Spectrum Clcok for TBG-A/B
+*
+* Input:	None
+* Output:	None
+* Return:	Non-zero on error
+******************************************************************************/
+static u32 set_a3700_ssc(void)
+{
+	debug_enter();
+	return 0;
+	debug_exit();
+}
+#endif /* MVEBU_A3700_ENABLE_SSC */
+
+/******************************************************************************
+* Name: set_a3700_clocks
+*
+* Description: Configure entire clock tree according to CPU and DDR frequency
+*
+* Input:	cpu_clk_mhz: required CPU clock
+*		ddr_clk_mhz: required DDR clock
+*		tbg_a_kvco_mhz: required TBG-A KVCO frequency or 0 for any available
+*		tbg_b_kvco_mhz: required TBG-B KVCO frequency or 0 for any available
+* Output:	None
+* Return:	Non-zero if the requested settings are not supported
+******************************************************************************/
+u32 set_a3700_clocks(u32 cpu_clk_mhz, u32 ddr_clk_mhz, u32 tbg_a_kvco_mhz, u32 tbg_b_kvco_mhz)
+{
+	u32 clock_cfgs_cnt = sizeof(a3700_clock_configs)/sizeof(a3700_clock_configs[0]);
+	u32 cfg;
+	struct a3700_clock_cfg *clk_cfg = 0;
+	u32 rval, reg_val;
+
+	debug_enter();
+
+	/* Search for the supported clock tree configuration */
+	for (cfg = 0; cfg < clock_cfgs_cnt; cfg++) {
+		if ((a3700_clock_configs[cfg].cpu_freq_mhz == cpu_clk_mhz) &&
+		    (a3700_clock_configs[cfg].ddr_freq_mhz == ddr_clk_mhz) &&
+		    ((tbg_a_kvco_mhz == 0) || (a3700_clock_configs[cfg].tbg_a.kvco_mhz == tbg_a_kvco_mhz)) &&
+		    ((tbg_b_kvco_mhz == 0) || (a3700_clock_configs[cfg].tbg_b.kvco_mhz == tbg_b_kvco_mhz))) {
+			clk_cfg = &a3700_clock_configs[cfg];
+			debug("Found requested clock configuration in DB[%d])\n", cfg);
+			break;
+		}
+	}
+
+	if (clk_cfg == 0) {
+		error("Unable to find clock configuration for CPU=%dMHz, DDR=%dMHz, TBG-A=%dMHz, TBG-B=%dMHz\n",
+		      cpu_clk_mhz, ddr_clk_mhz, tbg_a_kvco_mhz, tbg_b_kvco_mhz);
+		return 1;
+	}
+
+	/* Switch all North/South Bridge clock sources to XTAL
+	   prior to make any change to the clock configuration */
+	writel(0x00000000, MVEBU_NORTH_CLOCK_SELECT_REG);
+	writel(0x00000000, MVEBU_SOUTH_CLOCK_SELECT_REG);
+
+	debug("Setting TBG-A\n");
+	rval = set_a3700_tbg_clock(clk_cfg->tbg_a.kvco_mhz,
+				   clk_cfg->tbg_a.se_vcodiv,
+				   clk_cfg->tbg_a.diff_vcodiv,
+				   TBG_A);
+	if (rval) {
+		error("Failed to set TBG-A clock to %dMHz\n", clk_cfg->tbg_a.kvco_mhz);
+		return rval;
+	}
+
+	debug("Setting TBG-B\n");
+	rval = set_a3700_tbg_clock(clk_cfg->tbg_b.kvco_mhz,
+				   clk_cfg->tbg_b.se_vcodiv,
+				   clk_cfg->tbg_b.diff_vcodiv,
+				   TBG_B);
+	if (rval) {
+		error("Failed to set TBG-B clock to %dMHz\n", clk_cfg->tbg_b.kvco_mhz);
+		return rval;
+	}
+
+	/* North Bridge clock tree configuration */
+	/* Enable all clocks */
+	writel(NB_ALL_CLK_ENABLE, MVEBU_NORTH_CLOCK_ENABLE_REG);
+
+	/* Setup dividers */
+	reg_val = readl(MVEBU_NORTH_CLOCK_DIVIDER_SELECT0_REG);
+	reg_val &= NB_CLK_DIV0_MASK_ALL;
+	reg_val |= clk_cfg->nb_clk_cfg.div0.pwm_clk_prscl2 & 0x7;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.pwm_clk_prscl1 & 0x7) << 3;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.ddr_fclk_clk_prscl2 & 0x7) << 12;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.ddr_fclk_clk_prscl1 & 0x7) << 15;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.ddr_phy_mck_div_sel & 0x1) << 18;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.trace_div_sel & 0x7) << 20;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.counter_clk_prscl & 0x7) << 23;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.a53_cpu_clk_prscl & 0x7) << 28;
+	writel(reg_val, MVEBU_NORTH_CLOCK_DIVIDER_SELECT0_REG);
+
+	reg_val = readl(MVEBU_NORTH_CLOCK_DIVIDER_SELECT1_REG);
+	reg_val &= NB_CLK_DIV1_MASK_ALL;
+	reg_val |= clk_cfg->nb_clk_cfg.div1.sec_at_clk_prscl2 & 0x7;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.sec_at_clk_prscl1 & 0x7) << 3;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.sec_dap_clk_prscl2 & 0x7) << 6;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.sec_dap_clk_prscl1 & 0x7) << 9;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.tsecm_clk_prscl2 & 0x7) << 12;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.tsecm_clk_prscl1 & 0x7) << 15;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.setm_tmx_clk_prscl & 0x7) << 18;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.sqf_clk_prscl2 & 0x7) << 24;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.sqf_clk_prscl1 & 0x7) << 27;
+	writel(reg_val, MVEBU_NORTH_CLOCK_DIVIDER_SELECT1_REG);
+
+	reg_val = readl(MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG);
+	reg_val &= NB_CLK_DIV2_MASK_ALL;
+	reg_val |= clk_cfg->nb_clk_cfg.div2.wc_ahb_div_sel & 0x7;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.sata_h_clk_prscl2 & 0x7) << 7;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.sata_h_clk_prscl1 & 0x7) << 10;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.mmc_clk_prscl2 & 0x7) << 13;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.mmc_clk_prscl1 & 0x7) << 16;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.eip97_clk_prscl2 & 0x7) << 19;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.eip97_clk_prscl1 & 0x7) << 22;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.atb_clk_div_sel & 0x3) << 25;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.cpu_cnt_clk_div_sel & 0x3) << 27;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.plkdbg_clk_div_sel & 0x3) << 29;
+	writel(reg_val, MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG);
+
+	/* Setup connection to clock lines */
+	reg_val = readl(MVEBU_NORTH_CLOCK_TBG_SELECT_REG);
+	reg_val &= NB_CLK_TBG_SEL_MASK_ALL;
+	reg_val |= clk_cfg->nb_clk_cfg.clock_sel.mmc_pclk_sel & 0x3;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.sata_host_pclk_sel & 0x3) << 2;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.sec_at_pclk_sel & 0x3) << 4;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.sec_dap_pclk_sel & 0x3) << 6;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.tsecm_pclk_sel & 0x3) << 8;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.setm_tmx_pclk_sel & 0x3) << 10;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.sqf_pclk_sel & 0x3) << 12;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.pwm_pclk_sel & 0x3) << 14;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.ddr_fclk_pclk_sel & 0x3) << 16;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.trace_pclk_sel & 0x3) << 18;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.counter_pclk_sel & 0x3) << 20;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.a53_cpu_pclk_sel & 0x3) << 22;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.eip97_pclk_sel & 0x3) << 24;
+	writel(reg_val, MVEBU_NORTH_CLOCK_TBG_SELECT_REG);
+
+	/* South Bridge clock tree configuration */
+	/* Enable all clocks */
+	writel(SB_ALL_CLK_ENABLE, MVEBU_SOUTH_CLOCK_ENABLE_REG);
+
+	/* Setup dividers */
+	reg_val = readl(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT0_REG);
+	reg_val &= SB_CLK_DIV0_MASK_ALL;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.sdio_clk_prscl2 & 0x7) << 3;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.sdio_clk_prscl1 & 0x7) << 6;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.usb32_usb2_sys_clk_prscl2 & 0x7) << 9;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.usb32_usb2_sys_clk_prscl1 & 0x7) << 12;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.usb32_ss_sys_clk_prscl2 & 0x7) << 15;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.usb32_ss_sys_clk_prscl1 & 0x7) << 18;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.sb_axi_clk_prscl2 & 0x7) << 21;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.sb_axi_clk_prscl1 & 0x7) << 24;
+	writel(reg_val, MVEBU_SOUTH_CLOCK_DIVIDER_SELECT0_REG);
+
+	reg_val = readl(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG);
+	reg_val &= SB_CLK_DIV1_MASK_ALL;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_125_clk_prscl2 & 0x7) << 6;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_125_clk_prscl1 & 0x7) << 9;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_bm_core_clk_div2_sel & 0x1) << 12;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe1_core_clk_div2_sel & 0x1) << 13;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe0_core_clk_div2_sel & 0x1) << 14;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_core_clk_prscl2 & 0x7) << 18;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_core_clk_prscl1 & 0x7) << 21;
+	writel(reg_val, MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG);
+
+	reg_val = readl(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT2_REG);
+	reg_val &= SB_CLK_DIV2_MASK_ALL;
+	reg_val |= (clk_cfg->sb_clk_cfg.div2.gbe_50_clk_prscl2 & 0x7) << 6;
+	reg_val |= (clk_cfg->sb_clk_cfg.div2.gbe_50_clk_prscl1 & 0x7) << 9;
+	writel(reg_val, MVEBU_SOUTH_CLOCK_DIVIDER_SELECT2_REG);
+
+	/* Setup connection to clock lines */
+	reg_val = readl(MVEBU_SOUTH_CLOCK_TBG_SELECT_REG);
+	reg_val &= SB_CLK_TBG_SEL_MASK_ALL;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.gbe_50_pclk_sel & 0x3) << 6;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.gbe_core_pclk_sel & 0x3) << 8;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.gbe_125_pclk_sel & 0x3) << 10;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.sdio_pclk_sel & 0x3) << 14;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.usb32_usb2_sys_pclk_sel & 0x3) << 16;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.usb32_ss_sys_pclk_sel & 0x3) << 18;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.sb_axci_pclk_sel & 0x3) << 20;
+	writel(reg_val, MVEBU_SOUTH_CLOCK_TBG_SELECT_REG);
+
+
+#ifdef MVEBU_A3700_ENABLE_SSC
+	set_a3700_ssc();
+#else
+	/* Disable SSC for TBG-A (bit[10]) and TBG-B (bit[26]) */
+	reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL3);
+	reg_val &= ~(BIT10 | BIT26);
+	writel(reg_val, MVEBU_NORTH_BRG_TBG_CTRL3);
+#endif /* MVEBU_A3700_ENABLE_SSC */
+
+	/* Switch all North/South Bridge clock sources from XTAL to clock divider */
+	writel(0x0000BFFF, MVEBU_NORTH_CLOCK_SELECT_REG);
+	writel(0x000007AA, MVEBU_SOUTH_CLOCK_SELECT_REG);
+
+	rval = init_ddr_clock(ddr_clk_mhz);
+
+	debug_exit();
+	return rval;
 }
 
+int init_a3700_clock(void)
+{
+	int ret = 0;
+
+	debug_enter();
+
+	/* TODO: Move clock selection to DT */
+	ret = set_a3700_clocks(400, 600, 2400, 1600);
+	if (ret)
+		error("Failed to configure system clocks\n");
+
+	debug_exit();
+	return ret;
+}
diff --git a/arch/arm/include/asm/arch-armadalp/clock.h b/arch/arm/include/asm/arch-armadalp/clock.h
new file mode 100644
index 0000000..4d13628
--- /dev/null
+++ b/arch/arm/include/asm/arch-armadalp/clock.h
@@ -0,0 +1,494 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+#ifndef _MVEBU_CLOCK_H_
+#define _MVEBU_CLOCK_H_
+
+/* Spread Spectrum Clock */
+#undef MVEBU_A3700_ENABLE_SSC
+
+#ifdef MVEBU_A3700_ENABLE_SSC
+/* In order to use the SSC function, the KVCO must be operated above 2 GHz */
+#define MVEBU_KVCO_MIN		2000
+#else
+#define MVEBU_KVCO_MIN		1200
+#endif /* MVEBU_A3700_ENABLE_SSC */
+
+#define MVEBU_KVCO_MAX		3000
+
+/****************/
+/* REF Clock    */
+/****************/
+#define MVEBU_TEST_PIN_LATCH_N		(MVEBU_TESTPIN_NORTH_REG_BASE + 0x8)
+#define MVEBU_XTAL_MODE_MASK		BIT9
+#define MVEBU_XTAL_MODE_OFFS		9
+#define MVEBU_XTAL_CLOCK_25MHZ		(0x0)
+#define MVEBU_XTAL_CLOCK_40MHZ		(0x1)
+
+/****************/
+/* North Bridge */
+/****************/
+#define MVEBU_NORTH_BRG_PLL_BASE		(MVEBU_NORTH_CLOCK_REGS_BASE + 0x200)
+#define MVEBU_NORTH_BRG_TBG_CFG			(MVEBU_NORTH_BRG_PLL_BASE + 0x0)
+#define MVEBU_NORTH_BRG_TBG_CTRL0		(MVEBU_NORTH_BRG_PLL_BASE + 0x4)
+#define MVEBU_NORTH_BRG_TBG_CTRL1		(MVEBU_NORTH_BRG_PLL_BASE + 0x8)
+#define MVEBU_NORTH_BRG_TBG_CTRL2		(MVEBU_NORTH_BRG_PLL_BASE + 0xC)
+#define MVEBU_NORTH_BRG_TBG_CTRL3		(MVEBU_NORTH_BRG_PLL_BASE + 0x10)
+#define MVEBU_NORTH_BRG_TBG_CTRL4		(MVEBU_NORTH_BRG_PLL_BASE + 0x14)
+#define MVEBU_NORTH_BRG_TBG_CTRL5		(MVEBU_NORTH_BRG_PLL_BASE + 0x18)
+#define MVEBU_NORTH_BRG_TBG_CTRL6		(MVEBU_NORTH_BRG_PLL_BASE + 0x1C)
+#define MVEBU_NORTH_BRG_TBG_CTRL7		(MVEBU_NORTH_BRG_PLL_BASE + 0x20)
+#define MVEBU_NORTH_BRG_TBG_CTRL8		(MVEBU_NORTH_BRG_PLL_BASE + 0x30)
+
+#define MVEBU_NORTH_CLOCK_TBG_SELECT_REG	(MVEBU_NORTH_CLOCK_REGS_BASE + 0x0)
+#define NB_CLK_TBG_SEL_MASK_ALL			(0x3F << 26)
+
+/* north bridge clock divider select registers */
+#define MVEBU_NORTH_CLOCK_DIVIDER_SELECT0_REG	(MVEBU_NORTH_CLOCK_REGS_BASE + 0x4)
+#define NB_CLK_DIV0_MASK_ALL			(BIT31 | (0x3 << 26) | BIT19 | (0x3F << 6))
+
+#define MVEBU_NORTH_CLOCK_DIVIDER_SELECT1_REG	(MVEBU_NORTH_CLOCK_REGS_BASE + 0x8)
+#define NB_CLK_DIV1_MASK_ALL			((0x3 << 30) | (0x7 << 21))
+
+#define MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG	(MVEBU_NORTH_CLOCK_REGS_BASE + 0xC)
+#define NB_CLK_DIV2_MASK_ALL			(BIT31 | (0xF << 3))
+#define CPU_CNT_CLK_DIV_SEL_OFFS		(27)
+
+/* north bridge clock source register */
+#define MVEBU_NORTH_CLOCK_SELECT_REG		(MVEBU_NORTH_CLOCK_REGS_BASE + 0x10)
+#define NB_CLK_SEL_MASK_ALL			((0xFFFF << 16) | BIT14)
+
+/* north bridge clock enable register */
+#define MVEBU_NORTH_CLOCK_ENABLE_REG		(MVEBU_NORTH_CLOCK_REGS_BASE + 0x14)
+#define NB_ALL_CLK_ENABLE			(0x0)
+
+/****************/
+/* South Bridge */
+/****************/
+
+/* south bridge clock enable register */
+#define MVEBU_SOUTH_CLOCK_TBG_SELECT_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x0)
+#define SB_CLK_TBG_SEL_MASK_ALL			((0x3FF << 22) | (0x3 << 12) | 0x3F)
+#define GBE_125_TBG_SEL_OFFS			(10)
+
+#define MVEBU_SOUTH_CLOCK_DIVIDER_SELECT0_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x4)
+#define SB_CLK_DIV0_MASK_ALL			((0x1F << 27) | 0x7)
+#define AXI_CLK_PRSCL1_OFFS			(24)
+#define AXI_CLK_PRSCL2_OFFS			(21)
+#define USB32_SS_SYS_CLK_PRSCL1_OFFS		(18)
+#define USB32_SS_SYS_CLK_PRSCL2_OFFS		(15)
+#define USB32_USB2_SYS_CLK_PRSCL1_OFFS		(12)
+#define USB32_USB2_SYS_CLK_PRSCL2_OFFS		(9)
+
+#define MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x8)
+#define SB_CLK_DIV1_MASK_ALL			((0xFF << 24) | (0x7 << 15) | 0x3F)
+#define GBE_125_CLK_PRSCL_MASK			(0x7)
+#define GBE_125_CLK_PRSCL1_OFF			(9)
+#define GBE_125_CLK_PRSCL2_OFF			(6)
+
+#define MVEBU_SOUTH_CLOCK_DIVIDER_SELECT2_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0xC)
+#define SB_CLK_DIV2_MASK_ALL			((0xFFFFF << 12) | 0x3F)
+
+/* south bridge clock source register */
+#define MVEBU_SOUTH_CLOCK_SELECT_REG		(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x10)
+#define SB_AXI_CLK_SEL_OFFS			(10)
+#define USB32_SS_SYS_CLK_SEL_OFFS		(9)
+#define USB32_USB2_SYS_CLK_SEL_OFFS		(8)
+#define SDIO_CLK_SEL_OFFS			(7)
+#define GBE_CORE_CLK_SEL_OFFS			(5)
+#define GBE_125_CLK_SEL_OFFS			(3)
+#define GBE_50_CLK_SEL_OFFS			(1)
+
+
+/* south bridge clock enable register */
+#define MVEBU_SOUTH_CLOCK_ENABLE_REG		(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x14)
+/* (GBE0 and GBE1 have reversed logic) */
+#define SB_ALL_CLK_ENABLE			(BIT19 | BIT20)
+
+
+enum a3700_clock_src {
+	TBG_A,
+	TBG_B
+};
+
+enum a3700_clock_line {
+	TBG_A_P = 0,
+	TBG_B_P = 1,
+	TBG_A_S = 2,
+	TBG_B_S = 3
+};
+
+/*
+ * North Bridge Clocks
+ */
+/* North Bridge clock line selectors (0x13000) */
+struct a3700_nb_clock_sel {
+	enum a3700_clock_line mmc_pclk_sel;		/* [1:0] */
+	enum a3700_clock_line sata_host_pclk_sel;	/* [3:2] */
+	enum a3700_clock_line sec_at_pclk_sel;		/* [5:4] */
+	enum a3700_clock_line sec_dap_pclk_sel;		/* [7:6] */
+	enum a3700_clock_line tsecm_pclk_sel;		/* [9:8] */
+	enum a3700_clock_line setm_tmx_pclk_sel;	/* [11:10] */
+	enum a3700_clock_line sqf_pclk_sel;		/* [13:12] */
+	enum a3700_clock_line pwm_pclk_sel;		/* [15:14] */
+	enum a3700_clock_line ddr_fclk_pclk_sel;	/* [17:16] */
+	enum a3700_clock_line trace_pclk_sel;		/* [19:18] */
+	enum a3700_clock_line counter_pclk_sel;		/* [21:20] */
+	enum a3700_clock_line a53_cpu_pclk_sel;		/* [23:22] */
+	enum a3700_clock_line eip97_pclk_sel;		/* [25:24] */
+};
+
+/* North Bridge clock divider 0 (0x13004) */
+struct a3700_nb_clock_div_0 {
+	u8 pwm_clk_prscl2;	/* [2:0] */
+	u8 pwm_clk_prscl1;	/* [5:3] */
+	u8 ddr_fclk_clk_prscl2;	/* [14:12] */
+	u8 ddr_fclk_clk_prscl1;	/* [17:15] */
+	u8 ddr_phy_mck_div_sel;	/* [18] */
+	u8 trace_div_sel;	/* [22:20] */
+	u8 counter_clk_prscl;	/* [25:23] */
+	u8 a53_cpu_clk_prscl;	/* [30:28] */
+};
+
+/* North Bridge clock divider 1 (0x13008) */
+struct a3700_nb_clock_div_1 {
+	u8 sec_at_clk_prscl2;	/* [2:0] */
+	u8 sec_at_clk_prscl1;	/* [5:3] */
+	u8 sec_dap_clk_prscl2;	/* [8:6] */
+	u8 sec_dap_clk_prscl1;	/* [11:9] */
+	u8 tsecm_clk_prscl2;	/* [14:12] */
+	u8 tsecm_clk_prscl1;	/* [17:15] */
+	u8 setm_tmx_clk_prscl;	/* [20:18] */
+	u8 sqf_clk_prscl2;	/* [26:24] */
+	u8 sqf_clk_prscl1;	/* [29:27] */
+};
+
+/* North Bridge clock divider 2 (0x1300C) */
+struct a3700_nb_clock_div_2 {
+	u8 wc_ahb_div_sel;	/* [2:0] */
+	u8 sata_h_clk_prscl2;	/* [9:7] */
+	u8 sata_h_clk_prscl1;	/* [12:10] */
+	u8 mmc_clk_prscl2;	/* [15:13] */
+	u8 mmc_clk_prscl1;	/* [18:16] */
+	u8 eip97_clk_prscl2;	/* [21:19] */
+	u8 eip97_clk_prscl1;	/* [24:22] */
+	u8 atb_clk_div_sel;	/* [26:25] */
+	u8 cpu_cnt_clk_div_sel;	/* [28:27] */
+	u8 plkdbg_clk_div_sel;	/* [30:29] */
+};
+
+/* North Bridge clock configuration */
+struct a3700_nb_clock_cfg {
+	struct a3700_nb_clock_sel	clock_sel;
+	struct a3700_nb_clock_div_0	div0;
+	struct a3700_nb_clock_div_1	div1;
+	struct a3700_nb_clock_div_2	div2;
+};
+
+/*
+ * South Bridge Clocks
+ */
+ /* South Bridge clock line selectors (0x18000) */
+struct a3700_sb_clock_sel {
+	enum a3700_clock_line gbe_50_pclk_sel;		/* [7:6] */
+	enum a3700_clock_line gbe_core_pclk_sel;	/* [9:8] */
+	enum a3700_clock_line gbe_125_pclk_sel;		/* [11:10] */
+	enum a3700_clock_line sdio_pclk_sel;		/* [15:14] */
+	enum a3700_clock_line usb32_usb2_sys_pclk_sel;	/* [17:16] */
+	enum a3700_clock_line usb32_ss_sys_pclk_sel;	/* [19:18] */
+	enum a3700_clock_line sb_axci_pclk_sel;		/* [21:20] */
+};
+
+/* South Bridge clock divider 0 (0x18004) */
+struct a3700_sb_clock_div_0 {
+	u8 sdio_clk_prscl2;		/* [5:3] */
+	u8 sdio_clk_prscl1;		/* [8:6] */
+	u8 usb32_usb2_sys_clk_prscl2;	/* [11:9] */
+	u8 usb32_usb2_sys_clk_prscl1;	/* [14:12] */
+	u8 usb32_ss_sys_clk_prscl2;	/* [17:15] */
+	u8 usb32_ss_sys_clk_prscl1;	/* [20:18] */
+	u8 sb_axi_clk_prscl2;		/* [23:21] */
+	u8 sb_axi_clk_prscl1;		/* [24:24] */
+};
+
+/* South Bridge clock divider 1 (0x18008) */
+struct a3700_sb_clock_div_1 {
+	u8 gbe_125_clk_prscl2;		/* [8:6] */
+	u8 gbe_125_clk_prscl1;		/* [11:9] */
+	u8 gbe_bm_core_clk_div2_sel;	/* [12] */
+	u8 gbe1_core_clk_div2_sel;	/* [13] */
+	u8 gbe0_core_clk_div2_sel;	/* [14] */
+	u8 gbe_core_clk_prscl2;		/* [20:18] */
+	u8 gbe_core_clk_prscl1;		/* [23:21] */
+};
+
+/* South Bridge clock divider 2 (0x1800C) */
+struct a3700_sb_clock_div_2 {
+	u8 gbe_50_clk_prscl2;		/* [8:6] */
+	u8 gbe_50_clk_prscl1;		/* [11:9] */
+};
+
+/* South Bridge clock configuration */
+struct a3700_sb_clock_cfg {
+	struct a3700_sb_clock_sel	clock_sel;
+	struct a3700_sb_clock_div_0	div0;
+	struct a3700_sb_clock_div_1	div1;
+	struct a3700_sb_clock_div_2	div2;
+};
+
+struct a3700_tbg_cfg {
+	u32	kvco_mhz;
+	u32	se_vcodiv;
+	u32	diff_vcodiv;
+};
+
+/* System-wide clock configuration */
+struct a3700_clock_cfg {
+	u32				cpu_freq_mhz;
+	u32				ddr_freq_mhz;
+	struct a3700_tbg_cfg		tbg_a;
+	struct a3700_tbg_cfg		tbg_b;
+	struct a3700_nb_clock_cfg	nb_clk_cfg;
+	struct a3700_sb_clock_cfg	sb_clk_cfg;
+};
+
+/* This index points to configuration selected in MVEBU_A3700_CLOCK_CFGS
+   when DT entry is missing or invalid */
+#define MVEBU_A3700_DEF_CLOCK_PRESET_IDX	1
+
+/* Init values for the static clock configurations array */
+/*
+*************************************************************************************************************************************
+Configuration 0 – CPU 600, DDR 600
+
+		SE DIV	DIFF DIV
+KVCO-A	2400	1	1	← 2^n
+KVCO-B	2000	1	1	← 2^n						NB				SB
+=====================================================================================================================================
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-S	1200	3	1	sdio_pclk_sel		400	SB					DIV0[8:6]	DIV0[5:3]
+	2^n →	1	NA	ddr_phy_mck_div_sel	600	NB	DIV0[18]	NA
+		3	1	mmc_pclk_sel		400	NB	DIV2[15:13]	DIV2[18:16]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-P	1200	2	NA	a53_cpu_pclk_sel	600	NB	DIV0[30:28]	NA
+		2	NA	wc_ahb_div_sel		300	NB	DIV2[2:0]	NA
+	2^n →	0	NA	atb_clk_div_sel		600	NB	DIV2[26:5]	NA
+	2^n →	1	NA	plkdbg_clk_div_sel	300	NB	DIV2[30:29]	NA
+		2	NA	setm_tmx_pclk_sel	600	NB	DIV1[20:18]	NA
+		2	NA	trace_pclk_sel		600	NB	DIV0[22:20]	NA
+		3	2	tsecm_pclk_sel		200	NB	DIV1[14:12]	DIV1[17:15]
+		3	2	sqf_pclk_sel		200	NB	DIV1[26:24]	DIV1[29:27]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B_S	1000	2	1	eip97_pclk_sel		500	NB	DIV2[24:22]	DIV2[21:19]
+		5	2	pwm_pclk_sel		100	NB	DIV0[5:3]	DIV0[2:0]
+		5	1	sec_at_pclk_sel		200	NB	DIV1[5:3]	DIV1[2:0]
+		5	2	sec_dap_pclk_sel	100	NB	DIV1[11:9]	DIV1[8:6]
+		5	1	sata_host_pclk_sel	200	NB	DIV2[9:7]	DIV2[12:10]
+		4	2	ddr_fclk_pclk_sel	125	NB	DIV0[17:15]	DIV0[14:12]
+		6	NA	counter_pclk_sel	167	NB	DIV0[25:23]	NA
+	2^n →	1	NA	cpu_cnt_clk_div_sel	83	NB	DIV2[28:27]	NA
+		4	1	gbe_core_pclk_sel	250	SB					DIV1[20:18]	DIV1[23:21]
+		1	NA	gbe_bm_core_clk_div2_sel250	SB					DIV1[12]	NA
+		1	NA	gbe1_core_clk_div2_sel	250	SB					DIV1[13]	NA
+		1	NA	gbe0_core_clk_div2_sel	250	SB					DIV1[14]	NA
+		4	2	gbe_125_pclk_sel	125	SB					DIV1[11:9]	DIV1[8:6]
+		5	1	sb_axci_pclk_sel	200	SB					DIV0[20:18]	DIV0[23:21]
+		4	2	usb32_ss_sys_pclk_sel	125	SB					DIV0[17:15]	DIV0[20:18]
+		5	2	usb32_usb2_sys_pclk_sel	100	SB					DIV0[14:12]	DIV0[11:9]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B-P	1000	4	5	gbe_50_pclk_sel		50	SB					DIV2[11:9]	DIV2[8:6]
+*************************************************************************************************************************************
+*************************************************************************************************************************************
+Configuration 1 – CPU 400, DDR 600
+
+		SE DIV	DIFF DIV
+KVCO-A	2400	1	1	← 2^n
+KVCO-B	1600	1	1	← 2^n						NB				SB
+=====================================================================================================================================
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-S	1200	5	2	sec_at_pclk_sel		120	NB	DIV1[5:3]	DIV1[2:0]
+		5	4	sec_dap_pclk_sel	60	NB	DIV1[11:9]	DIV1[8:6]
+		5	4	pwm_pclk_sel		60	NB	DIV0[5:3]	DIV0[2:0]
+		2	6	ddr_fclk_pclk_sel	100	NB	DIV0[17:15]	DIV0[14:12]
+		1	4	eip97_pclk_sel		300	NB	DIV2[24:22]	DIV2[21:19]
+		2	2	gbe_core_pclk_sel	300	SB					DIV1[20:18]	DIV1[23:21]
+		1	NA	gbe_bm_core_clk_div2_sel300	SB					DIV1[12]	NA
+		1	NA	gbe1_core_clk_div2_sel	300	SB					DIV1[13]	NA
+		1	NA	gbe0_core_clk_div2_sel	300	SB					DIV1[14]	NA
+		5	1	sdio_pclk_sel		240	SB					DIV0[8:6]	DIV0[5:3]
+		4	5	usb32_usb2_sys_pclk_sel	60	SB					DIV0[14:12]	DIV0[11:9]
+		3	4	usb32_ss_sys_pclk_sel	100	SB					DIV0[17:15]	DIV0[20:18]
+	2^n →	1	NA	ddr_phy_mck_div_sel	600	NB	DIV0[18]	NA
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET	FREQ		PRE-1	BR	PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-P	1200	4	5	gbe_50_pclk_sel		60	SB					DIV2[11:9]	DIV2[8:6]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B_S	800	4	1	mmc_pclk_sel		200	NB	DIV2[15:13]	DIV2[18:16]
+		5	1	sata_host_pclk_sel	160	NB	DIV2[9:7]	DIV2[12:10]
+		5	1	tsecm_pclk_sel		160	NB	DIV1[14:12]	DIV1[17:15]
+		2	NA	setm_tmx_pclk_sel	400	NB	DIV1[20:18]	NA
+		5	1	sqf_pclk_sel		160	NB	DIV1[26:24]	DIV1[29:27]
+		2	NA	trace_pclk_sel		400	NB	DIV0[22:20]	NA
+		5	NA	counter_pclk_sel	160	NB	DIV0[25:23]	NA
+	2^n →	1	NA	cpu_cnt_clk_div_sel	80	NB	DIV2[28:27]	NA
+		2	NA	a53_cpu_pclk_sel	400	NB	DIV0[30:28]	NA
+		2	NA	wc_ahb_div_sel		200	NB	DIV2[2:0]	NA
+	2^n →	0	NA	atb_clk_div_sel		400	NB	DIV2[26:5]	NA
+	2^n →	1	NA	plkdbg_clk_div_sel	200	NB	DIV2[30:29]	NA
+		3	2	gbe_125_pclk_sel	133	SB					DIV1[11:9]	DIV1[8:6]
+		2	2	sb_axci_pclk_sel	200	SB					DIV0[20:18]	DIV0[23:21]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B-P	800
+*************************************************************************************************************************************
+*************************************************************************************************************************************
+Configuration 2 – CPU 1000, DDR 800
+
+		SE DIV	DIFF DIV
+KVCO-A	1600	0	1	← 2^n
+KVCO-B	2000	1	2	← 2^n						NB				SB
+=====================================================================================================================================
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-S	1600	4	1	mmc_pclk_sel		400	NB	DIV2[15:13]	DIV2[18:16]
+	2^n →	1	NA	ddr_phy_mck_div_sel	800	NB	DIV0[18]	NA
+		4	1	sdio_pclk_sel		400	SB					DIV0[8:6]	DIV0[5:3]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-P	800	5	NA	counter_pclk_sel	160	NB	DIV0[25:23]	NA
+	2^n →	1	NA	cpu_cnt_clk_div_sel	80	NB	DIV2[28:27]	NA
+		4	1	sqf_pclk_sel		200	NB	DIV1[26:24]	DIV1[29:27]
+		4	1	sata_host_pclk_sel	200	NB	DIV2[9:7]	DIV2[12:10]
+		4	1	tsecm_pclk_sel		200	NB	DIV1[14:12]	DIV1[17:15]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B_S	1000	5	1	sec_at_pclk_sel		200	NB	DIV1[5:3]	DIV1[2:0]
+		2	1	eip97_pclk_sel		500	NB	DIV2[24:22]	DIV2[21:19]
+		1	NA	setm_tmx_pclk_sel	1000	NB	DIV1[20:18]	NA
+		1	NA	trace_pclk_sel		1000	NB	DIV0[22:20]	NA
+		1	NA	a53_cpu_pclk_sel	1000	NB	DIV0[30:28]	NA
+		2	NA	wc_ahb_div_sel		500	NB	DIV2[2:0]	NA
+	2^n →	0	NA	atb_clk_div_sel		1000	NB	DIV2[26:5]	NA
+	2^n →	1	NA	plkdbg_clk_div_sel	500	NB	DIV2[30:29]	NA
+		4	2	ddr_fclk_pclk_sel	125	NB	DIV0[17:15]	DIV0[14:12]
+		5	2	sec_dap_pclk_sel	100	NB	DIV1[11:9]	DIV1[8:6]
+		5	2	pwm_pclk_sel		100	NB	DIV0[5:3]	DIV0[2:0]
+		4	1	gbe_core_pclk_sel	250	SB					DIV1[20:18]	DIV1[23:21]
+		1	NA	gbe_bm_core_clk_div2_sel250	SB					DIV1[12]	NA
+		1	NA	gbe1_core_clk_div2_sel	250	SB					DIV1[13]	NA
+		1	NA	gbe0_core_clk_div2_sel	250	SB					DIV1[14]	NA
+		4	2	gbe_125_pclk_sel	125	SB					DIV1[11:9]	DIV1[8:6]
+		2	1	sb_axci_pclk_sel	500	SB					DIV0[20:18]	DIV0[23:21]
+		4	2	usb32_ss_sys_pclk_sel	125	SB					DIV0[17:15]	DIV0[20:18]
+		5	2	usb32_usb2_sys_pclk_sel	100	SB					DIV0[14:12]	DIV0[11:9]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B-P	500	2	5	gbe_50_pclk_sel		50	SB					DIV2[11:9]	DIV2[8:6]
+*************************************************************************************************************************************
+*/
+/* Init values for the static clock configurations array */
+#define MVEBU_A3700_CLOCK_CFGS	{\
+	 /* Clock tree configuration entry 0 (testing, not yet fully functional) */\
+	{ 600, 600, /* CPU, DDR */\
+		{2400, 1, 1}, /* TBG-A: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		{2000, 1, 1}, /* TBG-B: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		/* NorthBridge */\
+		{{TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S, TBG_A_P, TBG_A_P, TBG_A_P,\
+		  TBG_B_S, TBG_B_S, TBG_A_P, TBG_B_S, TBG_A_P, TBG_B_S},\
+		 {2, 5, 2, 4, 1, 2, 6, 2},		/* DIV0 */\
+		 {1, 5, 2, 5, 2, 3, 2, 2, 3},		/* DIV1 */\
+		 {2, 1, 5, 1, 3, 1, 2, 0, 1, 1} },	/* DIV2 */\
+		/* SouthBridge */\
+		{{TBG_B_P, TBG_B_S, TBG_B_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S},\
+		 {1, 3, 2, 5, 2, 4, 1, 5},	/* DIV0 */\
+		 {2, 4, 1, 1, 1, 4, 1},		/* DIV1 */\
+		 {5, 4} }			/* DIV2 */\
+	},\
+	/* Clock tree configuration entry 1 (default working setup) */\
+	{ 400, 600, /* CPU, DDR */\
+		{2400, 1, 1}, /* TBG-A: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		{1600, 1, 1}, /* TBG-B: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		/* NorthBridge */\
+		{{TBG_B_S, TBG_B_S, TBG_A_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S,\
+		 TBG_A_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S, TBG_A_S},\
+		{4, 5, 6, 2, 1, 2, 5, 2},		/* DIV0 */\
+		{2, 5, 4, 5, 1, 5, 2, 1, 5},		/* DIV1 */\
+		{2, 1, 5, 1, 4, 1, 4, 0, 1, 1} },	/* DIV2 */\
+		/* SouthBridge */\
+		{{TBG_A_P, TBG_A_S, TBG_B_S, TBG_A_S, TBG_A_S, TBG_A_S, TBG_B_S},\
+		{1, 5, 5, 4, 3, 4, 2, 2},	/* DIV0 */\
+		{2, 3, 1, 1, 1, 2, 4},		/* DIV1 */\
+		{5, 4} }			/* DIV2 */\
+	},\
+	/* Clock tree configuration entry 2 */\
+	{ 1000, 800, /* CPU, DDR */\
+		{1600, 0, 1}, /* TBG-A: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		{2000, 1, 2}, /* TBG-B: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		/* NorthBridge */\
+		{{TBG_A_S, TBG_A_P, TBG_B_S, TBG_B_S, TBG_A_P, TBG_B_S, TBG_A_P,\
+		  TBG_B_S, TBG_B_S, TBG_B_S, TBG_A_P, TBG_B_S, TBG_B_S},\
+		{2, 5, 2, 4, 1, 1, 5, 1},		/* DIV0 */\
+		{1, 5, 2, 5, 1, 4, 1, 1, 4},		/* DIV1 */\
+		{2, 1, 4, 1, 4, 2, 1, 0, 1, 1} },	/* DIV2 */\
+		/* SouthBridge */\
+		{{TBG_B_P, TBG_B_S, TBG_B_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S},\
+		{1, 4, 2, 5, 2, 4, 1, 2},	/* DIV0 */\
+		{2, 4, 1, 1, 1, 4, 1},		/* DIV1 */\
+		{5, 2} }			/* DIV2 */\
+	},\
+}
+
+/*****************************************************************************
+* get_a3700_ref_clk
+*
+* return: reference clock in MHz (25 or 40)
+******************************************************************************/
+u32 get_a3700_ref_clk(void);
+
+/******************************************************************************
+* Name: set_a3700_clocks
+*
+* Description: Configure entire clock tree according to CPU and DDR frequency
+*
+* Input:	cpu_clk_mhz: required CPU clock
+*		ddr_clk_mhz: required DDR clock
+*		tbg_a_kvco_mhz: required TBG-A KVCO frequency or 0 for any available
+*		tbg_b_kvco_mhz: required TBG-B KVCO frequency or 0 for any available
+* Output:	None
+* Return:	Non-zero if the requested settings are not supported
+******************************************************************************/
+u32 set_a3700_clocks(u32 cpu_clk_mhz, u32 ddr_clk_mhz, u32 tbg_a_kvco_mhz, u32 tbg_b_kvco_mhz);
+
+int init_a3700_clock(void);
+
+#endif /* _MVEBU_CLOCK_H_ */
diff --git a/arch/arm/include/asm/arch-armadalp/regs-base.h b/arch/arm/include/asm/arch-armadalp/regs-base.h
index 1ad0a45..681e1d6 100644
--- a/arch/arm/include/asm/arch-armadalp/regs-base.h
+++ b/arch/arm/include/asm/arch-armadalp/regs-base.h
@@ -54,8 +54,10 @@
 #define MVEBU_A3700_NB_TEST_PIN_OUTPUT_EN (MVEBU_REGS_BASE + 0x13804)
 #define MVEBU_A3700_NB_TEST_PIN_OUTPUT_SPI_EN_OFF (28)
 
-/* clock registers */
+/* Clocks */
 #define MVEBU_NORTH_CLOCK_REGS_BASE	(MVEBU_REGS_BASE + 0x13000)
 #define MVEBU_SOUTH_CLOCK_REGS_BASE	(MVEBU_REGS_BASE + 0x18000)
+#define MVEBU_TESTPIN_NORTH_REG_BASE	(MVEBU_NORTH_CLOCK_REGS_BASE + 0x800)
+
 
 #endif	/* _REGS_BASE_H_ */
diff --git a/drivers/phy/comphy_a3700.c b/drivers/phy/comphy_a3700.c
index 11bf3f2..bc78d1f 100644
--- a/drivers/phy/comphy_a3700.c
+++ b/drivers/phy/comphy_a3700.c
@@ -22,6 +22,7 @@
 #include <asm/io.h>
 #include <asm/arch-mvebu/fdt.h>
 #include <asm/arch-mvebu/mvebu.h>
+#include <asm/arch-armadalp/clock.h>
 #include "comphy_a3700.h"
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -114,16 +115,6 @@ static u16 sgmii_phy_init[512] = {
 	};
 
 /***************************************************************************************************
-  * comphy_get_ref_clk
-  *
-  * return: reference clock in MHz (25 or 40)
- ***************************************************************************************************/
-static u32 comphy_get_ref_clk(void)
-{
-	return DEFAULT_REFCLK_MHZ;
-}
-
-/***************************************************************************************************
   * comphy_poll_reg
   *
   * return: 1 on success, 0 on timeout
@@ -147,6 +138,7 @@ static u32 comphy_poll_reg(void *addr, u32 val, u32 mask, u32 timeout, u8 op_typ
 	debug("Time out waiting (%p = %#010x)\n", addr, rval);
 	return 0;
 }
+
 /***************************************************************************************************
   * comphy_pcie_power_up
   *
@@ -197,7 +189,7 @@ static int comphy_pcie_power_up(enum phy_speed speed)
 	/*
 	 * 8. Check crystal jumper setting and program the Power and PLL Control accordingly
 	 */
-	if (comphy_get_ref_clk() == 40)
+	if (get_a3700_ref_clk() == 40)
 		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(PCIE), 0xFC63, 0xFFFF); /* 40 MHz */
 	else
 		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(PCIE), 0xFC62, 0xFFFF); /* 25 MHz */
@@ -259,7 +251,7 @@ static int comphy_sata_power_up(void)
 	 * 2. Select reference clock and PHY mode (SATA)
 	 */
 	reg_set((void __iomem *)rh_vsreg_addr, vphy_power_reg0, 0xFFFFFFFF);
-	if (comphy_get_ref_clk() == 40)
+	if (get_a3700_ref_clk() == 40)
 		reg_set((void __iomem *)rh_vsreg_data, 0x3, 0x00FF); /* 40 MHz */
 	else
 		reg_set((void __iomem *)rh_vsreg_data, 0x1, 0x00FF); /* 25 MHz */
@@ -325,7 +317,7 @@ static int comphy_usb3_power_up(enum phy_speed speed)
 	/*
 	 * 3. Check crystal jumper setting and program the Power and PLL Control accordingly
 	 */
-	if (comphy_get_ref_clk() == 40)
+	if (get_a3700_ref_clk() == 40)
 		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(USB3), 0xFCA3, 0xFFFF); /* 40 MHz */
 	else
 		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(USB3), 0xFCA2, 0xFFFF); /* 25 MHz */
@@ -586,7 +578,7 @@ static int comphy_sgmii_power_up(u32 lane, enum phy_speed speed)
 	phy_write16(lane, PHY_MISC_REG0_ADDR, 0, rb_ref_clk_sel);
 
 	/* 11. Set correct reference clock frequency in COMPHY register REF_FREF_SEL. */
-	if (comphy_get_ref_clk() == 40)
+	if (get_a3700_ref_clk() == 40)
 		phy_write16(lane, PHY_PWR_PLL_CTRL_ADDR, (0x4 << rf_ref_freq_sel_shift), rf_ref_freq_sel_mask);
 	else /* 25MHz */
 		phy_write16(lane, PHY_PWR_PLL_CTRL_ADDR, (0x1 << rf_ref_freq_sel_shift), rf_ref_freq_sel_mask);
@@ -616,7 +608,7 @@ static int comphy_sgmii_power_up(u32 lane, enum phy_speed speed)
 	   For REF clock 25 MHz the default values stored in PHY registers are OK.
 	*/
 	debug("Running C-DPI phy init %s mode\n", speed == __3_125gbps ? "2G5" : "1G");
-	if (comphy_get_ref_clk() == 40)
+	if (get_a3700_ref_clk() == 40)
 		comphy_sgmii_phy_init(lane, speed);
 
 	/* 16. [Simulation Only] should not be used for real chip.
-- 
1.9.1

