From 21ae44eefea0c8c9b8f1ea7dbd4084498025bc9f Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Tue, 8 Dec 2015 20:29:57 +0200
Subject: [PATCH 0592/1240] mdio: mvebu: added support for MDIO driver

- Added support for MDIO driver for Marvell PHYs
- Added SMI and XSMI read/write functions

Change-Id: I63eb9d442dc9a8cb9ad9a9d266ca4170ad875a94
Signed-off-by: Hanna Hawa <hannah@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/25705
Reviewed-by: Shadi Ammouri <shadi@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
---
 drivers/net/Kconfig      |   9 ++
 drivers/net/Makefile     |   1 +
 drivers/net/mvebu_mdio.c | 312 +++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 322 insertions(+)
 create mode 100644 drivers/net/mvebu_mdio.c

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 2e15409..23f8f5e 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -1,5 +1,14 @@
 menu "Network drivers"
 
+config MVEBU_MDIO
+	bool "MVEBU mdio driver"
+	default n
+	help
+	  Choose this option to add support
+	  for Marvell MDIO driver which add
+	  SMI/XSMI read/write functions to read
+	  from Marvell PHYs
+
 config ENC28J60
 	bool "ENC28J60 driver"
 	default n
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index fb0cf8c..48dc8ac 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -66,3 +66,4 @@ obj-$(CONFIG_XILINX_LL_TEMAC) += xilinx_ll_temac.o xilinx_ll_temac_mdio.o \
 		xilinx_ll_temac_fifo.o xilinx_ll_temac_sdma.o
 obj-$(CONFIG_ZYNQ_GEM) += zynq_gem.o
 obj-$(CONFIG_FSL_MC_ENET) += fsl_mc/
+obj-$(CONFIG_MVEBU_MDIO) += mvebu_mdio.o
diff --git a/drivers/net/mvebu_mdio.c b/drivers/net/mvebu_mdio.c
new file mode 100644
index 0000000..239d24c
--- /dev/null
+++ b/drivers/net/mvebu_mdio.c
@@ -0,0 +1,312 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+#include <common.h>
+#include <miiphy.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+
+#define MVEBU_SMI_TIMEOUT			10000
+
+#define MVEBU_SMI_OFFSET			0x2004
+/* SMI register fields */
+#define	MVEBU_SMI_DATA_OFFS			0	/* Data */
+#define	MVEBU_SMI_DATA_MASK			(0xffff << MVEBU_SMI_DATA_OFFS)
+#define	MVEBU_SMI_DEV_ADDR_OFFS			16	/* PHY device address */
+#define	MVEBU_SMI_REG_ADDR_OFFS			21	/* PHY device reg addr*/
+#define	MVEBU_SMI_OPCODE_OFFS			26	/* Write/Read opcode */
+#define	MVEBU_SMI_OPCODE_READ			(1 << MVEBU_SMI_OPCODE_OFFS)
+#define	MVEBU_SMI_READ_VALID			(1 << 27)	/* Read Valid */
+#define	MVEBU_SMI_BUSY				(1 << 28)	/* Busy */
+
+#define	MVEBU_PHY_REG_MASK			0x1f
+#define	MVEBU_PHY_ADDR_MASK			0x1f
+
+#define MVEBU_XSMI_OFFSET			0x30000
+/* XSMI management register fields */
+#define MVEBU_XSMI_DATA_OFFS			0       /* Data */
+#define MVEBU_XSMI_DATA_MASK			(0xffff << MVEBU_XSMI_DATA_OFFS)
+
+#define MVEBU_XSMI_PHY_ADDR_OFFS		16      /* PHY device address */
+#define MVEBU_XSMI_PHY_ADDR_MASK		(0x1f << MVEBU_XSMI_PHY_ADDR_OFFS)
+
+#define MVEBU_XSMI_DEV_ADDR_OFFS		21      /* PHY device register address */
+#define MVEBU_XSMI_DEV_ADDR_MASK		(0x1f << MVEBU_XSMI_DEV_ADDR_OFFS)
+
+#define MVEBU_XSMI_OPCODE_OFFS			26      /* opcode options*/
+#define MVEBU_XSMI_OPCODE_MASK			(7 << MVEBU_XSMI_OPCODE_OFFS)
+#define MVEBU_XSMI_OPCODE_WRITE			(1 << MVEBU_XSMI_OPCODE_OFFS)
+#define MVEBU_XSMI_OPCODE_INC_READ		(2 << MVEBU_XSMI_OPCODE_OFFS)
+#define MVEBU_XSMI_OPCODE_READ			(3 << MVEBU_XSMI_OPCODE_OFFS)
+#define MVEBU_XSMI_OPCODE_ADDR_WRITE		(5 << MVEBU_XSMI_OPCODE_OFFS)
+#define MVEBU_XSMI_OPCODE_ADDR_INC_READ		(6 << MVEBU_XSMI_OPCODE_OFFS)
+#define MVEBU_XSMI_OPCODE_ADDR_READ		(7 << MVEBU_XSMI_OPCODE_OFFS)
+
+#define MVEBU_XSMI_READ_VALID			(1 << 29)
+#define MVEBU_XSMI_BUSY				(1 << 30)
+
+/* XSMI address register */
+#define MVEBU_XSMI_REG_ADDR			0x8     /* Offset of the register address */
+#define MVEBU_XSMI_REG_ADDR_OFFS		0
+#define MVEBU_XSMI_REG_ADDR_MASK		(0xffff << MVEBU_XSMI_REG_ADDR_OFFS)
+
+/* XSMI configuration register */
+#define MVEBU_XSMI_CFG_ADDR			0xC
+#define MVEBU_XSMI_CFG_DIV_OFFS			0
+#define MVEBU_XSMI_CFG_DIV_MASK			(0x3 << MVEBU_XSMI_CFG_DIV_OFFS)
+
+/* SMI functions */
+static int mvebu_smi_check_param(int phy_adr, int reg_ofs)
+{
+	if (phy_adr > MVEBU_PHY_ADDR_MASK) {
+		error("Invalid PHY address %d\n", phy_adr);
+		return -EFAULT;
+	}
+
+	if (reg_ofs > MVEBU_PHY_REG_MASK) {
+		error("Invalid register offset %d\n", reg_ofs);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static int mvebu_smi_wait_ready(void *base)
+{
+	u32 timeout = MVEBU_SMI_TIMEOUT;
+	u32 smi_reg;
+
+	/* wait till the SMI is not busy */
+	do {
+		/* read smi register */
+		smi_reg = readl(base + MVEBU_SMI_OFFSET);
+		if (timeout-- == 0) {
+			error("SMI busy timeout\n");
+			return -EFAULT;
+		}
+	} while (smi_reg & MVEBU_SMI_BUSY);
+
+	return 0;
+}
+
+static int mvebu_smi_read(struct mii_dev *bus, int phy_adr, int reg_ofs)
+{
+	void __iomem *base = bus->priv;
+	u32 smi_reg;
+	u32 timeout;
+
+	/* wait till the SMI is not busy */
+	if (mvebu_smi_wait_ready(base) < 0)
+		return -EFAULT;
+
+	/* fill the phy address and regiser offset and read opcode */
+	smi_reg = (phy_adr << MVEBU_SMI_DEV_ADDR_OFFS)
+		| (reg_ofs << MVEBU_SMI_REG_ADDR_OFFS)
+		| MVEBU_SMI_OPCODE_READ;
+
+	/* write the smi register */
+	writel(smi_reg, base + MVEBU_SMI_OFFSET);
+
+	/* wait till read value is ready */
+	timeout = MVEBU_SMI_TIMEOUT;
+	do {
+		/* read smi register */
+		smi_reg = readl(base + MVEBU_SMI_OFFSET);
+		if (timeout-- == 0) {
+			error("SMI read ready time-out\n");
+			return -EFAULT;
+		}
+	} while (!(smi_reg & MVEBU_SMI_READ_VALID));
+
+	return readl(base + MVEBU_SMI_OFFSET) & MVEBU_SMI_DATA_MASK;
+}
+
+static int mvebu_smi_write(struct mii_dev *bus, int phy_adr, int reg_ofs, u16 data)
+{
+	void __iomem *base = bus->priv;
+	u32 smi_reg;
+
+	/* wait till the SMI is not busy */
+	if (mvebu_smi_wait_ready(base) < 0)
+		return -EFAULT;
+
+	/* fill the phy addr and reg offset and write opcode and data */
+	smi_reg = (data << MVEBU_SMI_DATA_OFFS);
+	smi_reg |= (phy_adr << MVEBU_SMI_DEV_ADDR_OFFS)
+			| (reg_ofs << MVEBU_SMI_REG_ADDR_OFFS);
+	smi_reg &= ~MVEBU_SMI_OPCODE_READ;
+
+	/* write the smi register */
+	writel(smi_reg, base + MVEBU_SMI_OFFSET);
+
+	/* make sure that the write transaction  is over */
+	if (mvebu_smi_wait_ready(base) < 0)
+		return -EFAULT;
+
+	return 0;
+}
+
+/* xSMI functions */
+static int mvebu_xsmi_wait_ready(void *base)
+{
+	u32 timeout = MVEBU_SMI_TIMEOUT;
+	u32 xsmi_reg;
+
+	/* wait till the xSMI is not busy */
+	do {
+		/* read smi register */
+		xsmi_reg = readl(base + MVEBU_XSMI_OFFSET);
+		if (timeout-- == 0) {
+			error("SMI busy time-out\n");
+			return -EFAULT;
+		}
+	} while (xsmi_reg & MVEBU_XSMI_BUSY);
+
+	return 0;
+}
+
+static int mvebu_xsmi_check_param(int phy_adr, int dev_adr, int reg_ofs)
+{
+	if (phy_adr > (MVEBU_XSMI_PHY_ADDR_MASK >> MVEBU_XSMI_PHY_ADDR_OFFS)) {
+		error("Invalid PHY address %d\n", phy_adr);
+		return -EFAULT;
+	}
+	if (dev_adr > (MVEBU_XSMI_DEV_ADDR_MASK >> MVEBU_XSMI_DEV_ADDR_OFFS)) {
+		error("Invalid Device address %d\n", dev_adr);
+		return -EFAULT;
+	}
+	if (reg_ofs > (MVEBU_XSMI_REG_ADDR_MASK >> MVEBU_XSMI_REG_ADDR_OFFS)) {
+		error("Invalid Reg offset %d\n", reg_ofs);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static int mvebu_xsmi_read(struct mii_dev *bus, int phy_adr, int dev_adr, int reg_adr)
+{
+	void __iomem *base = bus->priv;
+	u32 xsmi_reg;
+	u32 timeout;
+
+	/* wait till the SMI is not busy */
+	if (mvebu_xsmi_wait_ready(base) < 0)
+		return -EFAULT;
+
+	/* fill the register offset */
+	xsmi_reg = (reg_adr << MVEBU_XSMI_REG_ADDR_OFFS);
+	writel(xsmi_reg, base + MVEBU_XSMI_REG_ADDR);
+
+	/* fill the phy address and device address and read opcode */
+	xsmi_reg = (phy_adr << MVEBU_XSMI_PHY_ADDR_OFFS)
+		| (dev_adr << MVEBU_XSMI_DEV_ADDR_OFFS)
+		| MVEBU_XSMI_OPCODE_ADDR_READ;
+
+	/* write the smi register */
+	writel(xsmi_reg, base + MVEBU_XSMI_OFFSET);
+
+	/*wait till read value is ready */
+	timeout = MVEBU_SMI_TIMEOUT;
+	do {
+		/* read smi register */
+		xsmi_reg = readl(base + MVEBU_XSMI_OFFSET);
+		if (timeout-- == 0) {
+			error("SMI read ready time-out\n");
+			return -EFAULT;
+		}
+	} while (!(xsmi_reg & MVEBU_XSMI_READ_VALID));
+
+	return readl(base + MVEBU_XSMI_OFFSET) & MVEBU_XSMI_DATA_MASK;
+
+}
+
+static int mvebu_xsmi_write(struct mii_dev *bus, int phy_adr, int dev_adr, int reg_adr, u16 data)
+{
+	void __iomem *base = bus->priv;
+	u32 xsmi_reg;
+
+	/* wait till the xSMI is not busy */
+	if (mvebu_xsmi_wait_ready(base) < 0)
+		return -EFAULT;
+
+	/* fill the register offset */
+	xsmi_reg = (reg_adr << MVEBU_XSMI_REG_ADDR_OFFS);
+	writel(xsmi_reg, base + MVEBU_XSMI_REG_ADDR);
+
+	/* fill the phy address and device address and write opcode */
+	xsmi_reg = (data << MVEBU_XSMI_DATA_OFFS);
+	xsmi_reg |= (phy_adr << MVEBU_XSMI_PHY_ADDR_OFFS) | (dev_adr << MVEBU_XSMI_DEV_ADDR_OFFS);
+	xsmi_reg &= ~MVEBU_XSMI_OPCODE_ADDR_WRITE;
+
+	/* write the xsmi register */
+	writel(xsmi_reg, base + MVEBU_XSMI_OFFSET);
+
+	/* wait till the SMI is not busy */
+	if (mvebu_xsmi_wait_ready(base) < 0)
+		return -EFAULT;
+
+	return 0;
+}
+
+int mvebu_mdio_read(struct mii_dev *bus, int phy_adr, int dev_adr, int reg_ofs)
+{
+	if (dev_adr == -1) {
+		/* check parameters */
+		if (mvebu_smi_check_param(phy_adr, reg_ofs) < 0)
+			return -EFAULT;
+		return mvebu_smi_read(bus, phy_adr, reg_ofs);
+	} else {
+		/* check parameters */
+		if (mvebu_xsmi_check_param(phy_adr, dev_adr, reg_ofs) < 0)
+			return -EFAULT;
+		return mvebu_xsmi_read(bus, phy_adr, dev_adr, reg_ofs);
+	}
+}
+
+int mvebu_mdio_write(struct mii_dev *bus, int phy_adr, int dev_adr, int reg_ofs, u16 val)
+{
+	if (dev_adr == -1) {
+		/* check parameters */
+		if (mvebu_smi_check_param(phy_adr, reg_ofs) < 0)
+			return -EFAULT;
+		return mvebu_smi_write(bus, phy_adr, reg_ofs, val);
+	} else {
+		/* check parameters */
+		if (mvebu_xsmi_check_param(phy_adr, dev_adr, reg_ofs) < 0)
+			return -EFAULT;
+		return mvebu_xsmi_write(bus, phy_adr, dev_adr, reg_ofs, val);
+	}
+}
+
+int mvebu_mdio_initialize(bd_t *bis, void *base)
+{
+	struct mii_dev *bus = mdio_alloc();
+
+	if (!bus) {
+		error("Failed to allocate MVEBU MDIO bus");
+		return -1;
+	}
+
+	bus->read = mvebu_mdio_read;
+	bus->write = mvebu_mdio_write;
+	bus->reset = NULL;
+
+	/* use given name or generate its own unique name */
+	snprintf(bus->name, MDIO_NAME_LEN, "mvebu_mdio", base);
+	bus->priv = base;
+
+	return mdio_register(bus);
+}
-- 
1.9.1

