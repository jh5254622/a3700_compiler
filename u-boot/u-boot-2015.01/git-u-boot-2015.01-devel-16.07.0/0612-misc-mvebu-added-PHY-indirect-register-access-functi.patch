From 16259382f289355da477f788770f70f48b0ebc0b Mon Sep 17 00:00:00 2001
From: "hayim@marvell.com" <hayim@marvell.com>
Date: Thu, 17 Dec 2015 18:02:21 +0200
Subject: [PATCH 0612/1240] misc: mvebu: added PHY indirect register access
 functionality

currently, only IHB access is implemented

Change-Id: If1629ce77b5ac45eb3fa6a213f738138e04d81ac
Signed-off-by: hayim@marvell.com <hayim@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/26093
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
---
 arch/arm/cpu/mvebu-common/soc-init.c               |   4 +
 .../include/asm/arch-mvebu/mvebu_phy_indirect.h    |  36 ++++
 drivers/misc/Kconfig                               |   9 +
 drivers/misc/Makefile                              |   1 +
 drivers/misc/mvebu_phy_indirect.c                  | 220 +++++++++++++++++++++
 5 files changed, 270 insertions(+)
 create mode 100644 arch/arm/include/asm/arch-mvebu/mvebu_phy_indirect.h
 create mode 100644 drivers/misc/mvebu_phy_indirect.c

diff --git a/arch/arm/cpu/mvebu-common/soc-init.c b/arch/arm/cpu/mvebu-common/soc-init.c
index 825520e..58e5a90 100644
--- a/arch/arm/cpu/mvebu-common/soc-init.c
+++ b/arch/arm/cpu/mvebu-common/soc-init.c
@@ -25,6 +25,7 @@
 #include <asm/arch-mvebu/soc.h>
 #include <asm/arch-mvebu/tables.h>
 #include <asm/arch-mvebu/thermal.h>
+#include <asm/arch-mvebu/mvebu_phy_indirect.h>
 #include <ahci.h>
 #include <scsi.h>
 
@@ -96,6 +97,9 @@ int mvebu_soc_init()
 #ifdef CONFIG_MVEBU_IOB
 	init_iob();
 #endif
+#ifdef CONFIG_MVEBU_PHY_INDIRECT
+	mvebu_phy_indirect_init();
+#endif
 
 	mvebu_thermal_sensor_probe();
 
diff --git a/arch/arm/include/asm/arch-mvebu/mvebu_phy_indirect.h b/arch/arm/include/asm/arch-mvebu/mvebu_phy_indirect.h
new file mode 100644
index 0000000..aaad5fc
--- /dev/null
+++ b/arch/arm/include/asm/arch-mvebu/mvebu_phy_indirect.h
@@ -0,0 +1,36 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+#ifndef __MVEBU_PHY_INDIRECT_H__
+#define __MVEBU_PHY_INDIRECT_H__
+
+enum phy_indirect_unit {
+	INDIRECT_IHB,
+	INDIRECT_MAX
+};
+
+/*
+ * Functions prototypes
+ */
+
+int mvebu_phy_indirect_init(void);
+int mvebu_phy_indirect_read(enum phy_indirect_unit unit, int reg_ofs, u32 *val);
+int mvebu_phy_indirect_write(enum phy_indirect_unit unit, int reg_ofs, u32 val);
+
+
+#endif /* __MVEBU_MMC_H__ */
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 9362f3c..b8cf604 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -31,4 +31,13 @@ config MVEBU_MBUS_SKIP_DRAM_WIN
 	  be at the beginning, and could not be
 	  configured by anyway (keep the default value).
 
+config MVEBU_PHY_INDIRECT
+	bool "Access to PHY indirect registers"
+	depends on TARGET_ARMADA_8K
+	default y
+	help
+	  Choose this option to add support
+	  for PHY indirect access.
+	  This driver initialize the IHB window.
+
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 39a6997..cb5e1c3 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -29,3 +29,4 @@ obj-$(CONFIG_STATUS_LED) += status_led.o
 obj-$(CONFIG_TWL4030_LED) += twl4030_led.o
 obj-$(CONFIG_FSL_IFC) += fsl_ifc.o
 obj-$(CONFIG_MVEBU_MBUS) += mvebu_mbus.o
+obj-$(CONFIG_MVEBU_PHY_INDIRECT) += mvebu_phy_indirect.o
diff --git a/drivers/misc/mvebu_phy_indirect.c b/drivers/misc/mvebu_phy_indirect.c
new file mode 100644
index 0000000..987b5b2
--- /dev/null
+++ b/drivers/misc/mvebu_phy_indirect.c
@@ -0,0 +1,220 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/mvebu_phy_indirect.h>
+
+
+/* IHB registers */
+#define MVEBU_IHB_PHY_BASE					0xf6000000
+#define MVEBU_IHB_PHY_DATA_REG_OFF			0x0
+#define MVEBU_IHB_PHY_CMD_REG_OFF			0x4
+
+/* IHB Address */
+#define MVEBU_IHB_PHY_ADDR_LSB_OFF			0
+#define MVEBU_IHB_PHY_ADDR_LSB_MASK			0x3F
+#define MVEBU_IHB_PHY_ADDR_MSB_OFF			6
+#define MVEBU_IHB_PHY_ADDR_MSB_MASK			(0x3 << MVEBU_IHB_PHY_ADDR_MSB_OFF)
+
+#define MVEBU_IHB_PHY_ADDR_LSB_GET(reg_ofs)	((reg_ofs) & MVEBU_IHB_PHY_ADDR_LSB_MASK)
+#define MVEBU_IHB_PHY_ADDR_MSB_GET(reg_ofs)	(((reg_ofs) & MVEBU_IHB_PHY_ADDR_MSB_MASK) >> \
+											MVEBU_IHB_PHY_ADDR_MSB_OFF)
+
+/* IHB CMD register fields */
+#define	MVEBU_IHB_CMD_OP_OFFS				0
+#define	MVEBU_IHB_CMD_OP_MASK				0x1
+#define	MVEBU_IHB_CMD_PACKET_LOCAL_OFFS		5
+#define	MVEBU_IHB_CMD_DONE_OFFS				6
+#define	MVEBU_IHB_CMD_DONE_MASK				(0x3 << MVEBU_IHB_CMD_DONE_OFFS)
+#define	MVEBU_IHB_CMD_ADDR_LSB_OFFS			16	/* IHB LSB address bits */
+#define	MVEBU_IHB_CMD_ADDR_LSB_MASK			(0x3F << MVEBU_IHB_CMD_ADDR_LSB_OFFS)
+#define	MVEBU_IHB_CMD_REGION_OFFS			22	/* IHB access space */
+#define	MVEBU_IHB_CMD_REGION_MASK			(0x3 << MVEBU_IHB_CMD_REGION_OFFS)
+
+#define MVEBU_IHB_CMD_GET(cmd, region, reg_ofs) \
+				(((cmd << MVEBU_IHB_CMD_OP_OFFS) & MVEBU_IHB_CMD_OP_MASK) | \
+				(1 << MVEBU_IHB_CMD_PACKET_LOCAL_OFFS) | \
+				((region << MVEBU_IHB_CMD_REGION_OFFS) & MVEBU_IHB_CMD_REGION_MASK) | \
+				(MVEBU_IHB_PHY_ADDR_LSB_GET(reg_ofs) << MVEBU_IHB_CMD_ADDR_LSB_OFFS))
+
+/* IHB PHY CTRL register fields */
+#define MVEBU_IHB_PHY_CTRL_REG_OFF			0x7
+#define MVEBU_IHB_PHY_CTRL_ADDR_MSB_OFFS	27
+#define MVEBU_IHB_PHY_CTRL_ADDR_MSB_MASK	(0x3 << 27)
+
+/* IHB RFU PHY register fields */
+#define MVEBU_IHB_RFU_REG_OFF				0x6F010C
+#define	MVEBU_IHB_RFU_RESET_OFFS			0
+#define	MVEBU_IHB_RFU_RESET_MASK			(1 << MVEBU_IHB_RFU_RESET_OFFS)
+#define	MVEBU_IHB_RFU_TCELL_BYPASS_OFFS		10
+#define	MVEBU_IHB_RFU_BASE_OFFS				16
+#define	MVEBU_IHB_RFU_BASE_MASK				(0xFF << MVEBU_IHB_RFU_BASE_OFFS)
+
+#define	MVEBU_IHB_BASE_HIGH_BYTE_OFF		24
+
+
+enum ihb_access_type {
+	IHB_WRITE = 0,
+	IHB_READ  = 1
+};
+
+enum ihb_region {
+	IHB_CTRL_REGION     = 0,
+	IHB_PHY_REG_REGION  = 3,
+};
+
+
+static int mvebu_ihb_poll_read_done(int reg_ofs)
+{
+	u32 ihb_cmd_reg = 0;
+	u32 timeout = 100;
+
+	do {
+		ihb_cmd_reg = readl(MVEBU_IHB_PHY_BASE | MVEBU_IHB_PHY_CMD_REG_OFF);
+	} while (((ihb_cmd_reg & MVEBU_IHB_CMD_DONE_MASK) != MVEBU_IHB_CMD_DONE_MASK) &&
+			 (timeout-- > 0));
+
+	if (timeout == 0) {
+		error("Read timeout\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+/*  IHB Indirect Access decription:
+ *      the access is done using CMD and DATA register.
+ *      the address and access type are set in the CMD register.
+ *
+ *          [0] = 0 -> write
+ *                1 -> read
+ *      [23:22] = 0x0 -> access IHB Controller space
+ *                0x3 -> indicate IHB PHY REG address space,
+ *      [21:16] = LSB of the Offset
+ *
+ *      (MSB are set to IHB_PHY_CTRL register (0x7) bit [28:27]
+*/
+
+static int mvebu_ihb_command_set(enum ihb_access_type access_type, int reg_ofs, u32 data)
+{
+	u32 ihb_cmd_reg = 0;
+	u32 ihb_phy_ctrl_reg = 0;
+
+	/* Step 1 - set address MSB in IHB_PHY_CTRL (using RMW) */
+	/* read IHB_PHY_CTRL */
+	ihb_cmd_reg = MVEBU_IHB_CMD_GET(IHB_READ, IHB_CTRL_REGION, MVEBU_IHB_PHY_CTRL_REG_OFF);
+	writel(ihb_cmd_reg, MVEBU_IHB_PHY_BASE | MVEBU_IHB_PHY_CMD_REG_OFF);
+	/* poll for read completion */
+	if (mvebu_ihb_poll_read_done(reg_ofs))
+		return 1;
+
+	ihb_phy_ctrl_reg = readl(MVEBU_IHB_PHY_BASE | MVEBU_IHB_PHY_DATA_REG_OFF);
+
+	/* update msb in MVEBU_IHB_PHY_CTRL */
+	ihb_phy_ctrl_reg &= ~MVEBU_IHB_PHY_CTRL_ADDR_MSB_MASK; /* clear msb data */
+	ihb_phy_ctrl_reg |= ((MVEBU_IHB_PHY_ADDR_MSB_GET(reg_ofs) << MVEBU_IHB_PHY_CTRL_ADDR_MSB_OFFS) &
+						 MVEBU_IHB_PHY_CTRL_ADDR_MSB_MASK);/* set msb data */
+
+    /* write IHB_PHY_CTRL */
+	writel(ihb_phy_ctrl_reg, MVEBU_IHB_PHY_BASE | MVEBU_IHB_PHY_DATA_REG_OFF);	/* set data */
+	ihb_cmd_reg = (ihb_cmd_reg & ~MVEBU_IHB_CMD_OP_MASK) | IHB_WRITE;			/* set write command */
+	writel(ihb_cmd_reg, MVEBU_IHB_PHY_BASE | MVEBU_IHB_PHY_CMD_REG_OFF);		/* set commnd */
+
+	/* Step 2 - set IHB command with LSB */
+	if (access_type == IHB_WRITE) {
+		/* set data in ihb data reg */
+		writel(data, MVEBU_IHB_PHY_BASE | MVEBU_IHB_PHY_DATA_REG_OFF);
+	}
+
+	ihb_cmd_reg = MVEBU_IHB_CMD_GET(access_type, IHB_PHY_REG_REGION, reg_ofs);
+	writel(ihb_cmd_reg, MVEBU_IHB_PHY_BASE | MVEBU_IHB_PHY_CMD_REG_OFF);		/* set commnd */
+
+	return 0;
+}
+
+static int mvebu_ihb_read(int reg_ofs, u32 *val)
+{
+	/* set read command */
+	if (mvebu_ihb_command_set(IHB_READ, reg_ofs, 0 /* dummy */)) {
+		error("IHB read: set command failed\n");
+		return 1;
+	}
+
+	/* poll for read completion */
+	if (mvebu_ihb_poll_read_done(reg_ofs))
+		return 1;
+
+	*val = readl(MVEBU_IHB_PHY_BASE | MVEBU_IHB_PHY_DATA_REG_OFF);
+
+	return 0;
+}
+
+static int mvebu_ihb_write(int reg_ofs, u32 data)
+{
+	/* set write command */
+	if (mvebu_ihb_command_set(IHB_WRITE, reg_ofs, data)) {
+		error("IHB write: set command failed\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+int mvebu_phy_indirect_read(enum phy_indirect_unit phy_unit, int reg_ofs, u32 *val)
+{
+	switch (phy_unit) {
+	case INDIRECT_IHB:
+		return mvebu_ihb_read(reg_ofs, val);
+	default:
+		error("unit %d is not supported\n", phy_unit);
+		return 1;
+	}
+}
+
+int mvebu_phy_indirect_write(enum phy_indirect_unit phy_unit, int reg_ofs, u32 val)
+{
+	switch (phy_unit) {
+	case INDIRECT_IHB:
+		return mvebu_ihb_write(reg_ofs, val);
+	default:
+		error("unit %d is not supported\n", phy_unit);
+		return 1;
+	}
+}
+
+int mvebu_phy_indirect_init(void)
+{
+	u8 *regs_base = (u8 *)MVEBU_REGS_BASE;
+	u32 reg_data;
+	u32 ihb_base_high_byte = MVEBU_IHB_PHY_BASE >> MVEBU_IHB_BASE_HIGH_BYTE_OFF;
+
+	reg_data = readl(regs_base + MVEBU_IHB_RFU_REG_OFF);
+
+	/* set configuration data */
+	reg_data &= ~MVEBU_IHB_RFU_RESET_MASK; /* un-reset IHB PHY */
+	reg_data |= (1 << MVEBU_IHB_RFU_TCELL_BYPASS_OFFS); /* enable TCELL bypass since
+											this bridge is not functional */
+	reg_data = (ihb_base_high_byte << MVEBU_IHB_RFU_BASE_OFFS) |
+				(reg_data & ~MVEBU_IHB_RFU_BASE_MASK); /* set IHB base address */
+
+	/* Configure IHB MAC base address RFU base and Un-reset IHB PHY */
+	writel(reg_data, regs_base + MVEBU_IHB_RFU_REG_OFF);
+
+	return 0;
+}
-- 
1.9.1

