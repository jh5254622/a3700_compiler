From 753ea4169e2ec41d2a75c33858ab4cbb755b890d Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Wed, 6 Jan 2016 17:35:36 +0200
Subject: [PATCH 0644/1240] fix: mvebu: fix unaligned memory access using
 U-Boot memory commands

- Unaligned memory access using U-Boot command will reset the Armv8 system
- This patch fix the address before access memory for the below commands:
  md, mm, nm, mw, cmp, cp, loop, ir, and mtest

Change-Id: I0dee9beae733080432a2d12c607189292db711f1
Signed-off-by: Hanna Hawa <hannah@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/26599
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Shadi Ammouri <shadi@marvell.com>
---
 common/cmd_mem.c | 37 +++++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/common/cmd_mem.c b/common/cmd_mem.c
index ca4264b..0660fc5 100644
--- a/common/cmd_mem.c
+++ b/common/cmd_mem.c
@@ -41,6 +41,24 @@ static uint	mm_last_addr, mm_last_size;
 
 static	ulong	base_address = 0;
 
+/* align_address -  align address to word/long
+* INPUT:
+*     addr - address to align
+*     size - align address to this size
+*/
+static ulong align_address(ulong addr, int size)
+{
+	/* Unaligned memory access Workaround:
+	 * if size = long/word, & address not aligned to long/word (respectively)
+	 * align address to meet requested size */
+	if ((size > 1) && (addr % size > 0)) {
+		error("Requested unaligned memory address (0x%x)\n", (unsigned int)addr);
+		addr &= ~(size - 1);
+		printf("Using aligned address (0x%x)\n", (unsigned int)addr);
+	}
+	return addr;
+}
+
 /* Memory Display
  *
  * Syntax:
@@ -85,6 +103,7 @@ static int do_mem_md(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 			length = simple_strtoul(argv[2], NULL, 16);
 	}
 
+	addr = align_address(addr, size);
 #if defined(CONFIG_HAS_DATAFLASH)
 	/* Print the lines.
 	 *
@@ -181,6 +200,8 @@ static int do_mem_mw(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	addr = simple_strtoul(argv[1], NULL, 16);
 	addr += base_address;
 
+	addr = align_address(addr, size);
+
 	/* Get the value to write.
 	*/
 #ifdef CONFIG_SYS_SUPPORT_64BIT_DATA
@@ -301,6 +322,8 @@ static int do_mem_cmp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	addr2 = simple_strtoul(argv[2], NULL, 16);
 	addr2 += base_address;
 
+	addr1 = align_address(addr1, size);
+	addr2 = align_address(addr2, size);
 	count = simple_strtoul(argv[3], NULL, 16);
 
 #ifdef CONFIG_HAS_DATAFLASH
@@ -387,6 +410,9 @@ static int do_mem_cp(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	dest = simple_strtoul(argv[2], NULL, 16);
 	dest += base_address;
 
+	addr = align_address(addr, size);
+	dest = align_address(dest, size);
+
 	count = simple_strtoul(argv[3], NULL, 16);
 
 	if (count == 0) {
@@ -533,6 +559,8 @@ static int do_mem_loop(cmd_tbl_t *cmdtp, int flag, int argc,
 	*/
 	length = simple_strtoul(argv[2], NULL, 16);
 
+	addr = align_address(addr, size);
+
 	bytes = size * length;
 	buf = map_sysmem(addr, bytes);
 
@@ -634,6 +662,8 @@ static int do_mem_loopw(cmd_tbl_t *cmdtp, int flag, int argc,
 	*/
 	length = simple_strtoul(argv[2], NULL, 16);
 
+	addr = align_address(addr, size);
+
 	/* data to write */
 #ifdef CONFIG_SYS_SUPPORT_64BIT_DATA
 	data = simple_strtoull(argv[3], NULL, 16);
@@ -1020,6 +1050,9 @@ static int do_mem_mtest(cmd_tbl_t *cmdtp, int flag, int argc,
 	else
 		end = CONFIG_SYS_MEMTEST_END;
 
+	start = align_address((ulong)start, 4);
+	end = align_address((ulong)end, 4);
+
 	if (argc > 3)
 		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
 	else
@@ -1124,6 +1157,8 @@ mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
 		addr += base_address;
 	}
 
+	addr = align_address(addr, size);
+
 #ifdef CONFIG_HAS_DATAFLASH
 	if (addr_dataflash(addr)){
 		puts ("Can't modify DataFlash in place. Use cp instead.\n\r");
@@ -1422,6 +1457,8 @@ int ir_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		return 0;
 	}
 
+	offset = align_address(offset, 4);
+
 	reg = readl(regs_base + offset);
 	tmp_val = reg;
 	printf("Internal register 0x%x value : 0x%x\n", offset, reg);
-- 
1.9.1

