From e7ca0f54334abf23c8fe40dfa9b14c9fc7fb7fbb Mon Sep 17 00:00:00 2001
From: Konstantin Porotchkin <kostap@marvell.com>
Date: Tue, 19 Jan 2016 11:43:39 +0200
Subject: [PATCH 0720/1240] ddr: a3700: Move static DDR config into MK6 driver

- Move the static DDR configuration from the clock sources
  to the dedicated MC6 driver code
- Change the driver code for supporting a3700-specific
  pre-MAC init configurations
- Support dual DDR frequency (600/800)
- Add misc-regs.h header for holding SoC-specific
  definitions that are not related to any device driver yet

Change-Id: Id8bb8a60ab0910f50c7316b53ab0e85d10dc43fb
Signed-off-by: Konstantin Porotchkin <kostap@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/26879
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Reviewed-by: Haim Boot <hayim@marvell.com>
---
 arch/arm/cpu/armv8/armadalp/mvebu_clock.c      | 166 -----------------------
 arch/arm/include/asm/arch-armadalp/misc-regs.h |  35 +++++
 arch/arm/include/asm/arch-armadalp/regs-base.h |   6 +
 drivers/ddr/ddr_mckinley6.h                    |   2 +
 drivers/ddr/ddr_mckinley6_arlp.c               | 181 +++++++++++++++++++++----
 5 files changed, 199 insertions(+), 191 deletions(-)
 create mode 100644 arch/arm/include/asm/arch-armadalp/misc-regs.h

diff --git a/arch/arm/cpu/armv8/armadalp/mvebu_clock.c b/arch/arm/cpu/armv8/armadalp/mvebu_clock.c
index c66bd25..9a6bc9a 100644
--- a/arch/arm/cpu/armv8/armadalp/mvebu_clock.c
+++ b/arch/arm/cpu/armv8/armadalp/mvebu_clock.c
@@ -27,169 +27,6 @@
 DECLARE_GLOBAL_DATA_PTR;
 static struct a3700_clock_cfg a3700_clock_configs[] = MVEBU_A3700_CLOCK_CFGS;
 
-/* TODO: Move to dedicated DDR driver */
-static u32 init_ddr_clock(u32 ddr_clock_mhz)
-{
-	u32	regval;
-
-	debug_enter();
-
-	writel(0x00404500, MVEBU_REGS_BASE + 0x00014008);
-	writel(0x00010000, MVEBU_REGS_BASE + 0x00002000);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x00002004);
-	writel(0x0f0f0fef, MVEBU_REGS_BASE + 0x00000340);
-	writel(0x100000aa, MVEBU_REGS_BASE + 0x00000344);
-	writel(0x00200000, MVEBU_REGS_BASE + 0x00000310);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x00000304);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x00000308);
-
-	writel(0x000E0001, MVEBU_REGS_BASE + 0x00000200);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x00000204);
-	writel(0x13020532, MVEBU_REGS_BASE + 0x00000220);
-	writel(0x00030200, MVEBU_REGS_BASE + 0x00000044);
-	writel(0x00006000, MVEBU_REGS_BASE + 0x000002c0);
-	writel(0x00100020, MVEBU_REGS_BASE + 0x000002c4);
-	writel(0x0000143f, MVEBU_REGS_BASE + 0x00000058);
-	writel(0x00000001, MVEBU_REGS_BASE + 0x00000048);
-	writel(0x00010200, MVEBU_REGS_BASE + 0x00000180);
-	writel(0x000001ff, MVEBU_REGS_BASE + 0x00000050);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x0000004c);
-	writel(0x00000480, MVEBU_REGS_BASE + 0x00000054);
-
-	if (ddr_clock_mhz == 800) {
-		/* ddr_clock_mhz == 800 */
-
-		writel(0x0000080B, MVEBU_REGS_BASE + 0x00000300);
-
-		/* DRAM Initialization Timing Control Register
-		   note: the following 3 registers are related to CPU clock */
-		writel(0x0007A120, MVEBU_REGS_BASE + 0x00000380);
-		writel(0x00030D40, MVEBU_REGS_BASE + 0x00000384);
-		writel(0x0960006B, MVEBU_REGS_BASE + 0x00000388);
-
-		writel(0x00000200, MVEBU_REGS_BASE + 0x0000038c);
-		writel(0x00400100, MVEBU_REGS_BASE + 0x00000390);
-		writel(0x00F003CF, MVEBU_REGS_BASE + 0x00000394);
-		writel(0x00F80200, MVEBU_REGS_BASE + 0x00000398);
-		writel(0x00000808, MVEBU_REGS_BASE + 0x0000039c);
-		writel(0x00040614, MVEBU_REGS_BASE + 0x000003a0);
-		writel(0x00000001, MVEBU_REGS_BASE + 0x000003a4);
-		writel(0x00000c04, MVEBU_REGS_BASE + 0x000003a8);
-		writel(0x202A0C1F, MVEBU_REGS_BASE + 0x000003ac);
-		writel(0x0C0C060C, MVEBU_REGS_BASE + 0x000003b0);
-		writel(0x04000600, MVEBU_REGS_BASE + 0x000003b4);
-		writel(0x00000800, MVEBU_REGS_BASE + 0x000003b8);
-
-		/* ddr_clock_mhz == 800 */
-	} else if (ddr_clock_mhz == 600) {
-		/* ddr_clock_mhz == 600 */
-
-		writel(0x00000708, MVEBU_REGS_BASE + 0x00000300);
-
-		/* DRAM Initialization Timing Control Register
-		   note: the following 3 registers are related to CPU clock */
-		writel(0x000001F5, MVEBU_REGS_BASE + 0x00000380);
-		writel(0x000003E9, MVEBU_REGS_BASE + 0x00000384);
-		writel(0x09600043, MVEBU_REGS_BASE + 0x00000388);
-
-		writel(0x00000200, MVEBU_REGS_BASE + 0x0000038c);
-		writel(0x00400100, MVEBU_REGS_BASE + 0x00000390);
-		writel(0x006B03CF, MVEBU_REGS_BASE + 0x00000394);
-		writel(0x00720200, MVEBU_REGS_BASE + 0x00000398);
-		writel(0x00120707, MVEBU_REGS_BASE + 0x0000039c);
-		writel(0x00040511, MVEBU_REGS_BASE + 0x000003a0);
-		writel(0x00000001, MVEBU_REGS_BASE + 0x000003a4);
-		writel(0x00000C04, MVEBU_REGS_BASE + 0x000003a8);
-		writel(0x15210919, MVEBU_REGS_BASE + 0x000003ac);
-		writel(0x090b0609, MVEBU_REGS_BASE + 0x000003b0);
-		writel(0x04000600, MVEBU_REGS_BASE + 0x000003b4);
-		writel(0x00000600, MVEBU_REGS_BASE + 0x000003b8);
-		/* ddr_clock_mhz == 600 */
-	} else {
-		error("Unsupported DDR clock - %d MHz\n", ddr_clock_mhz);
-		return 1;
-	}
-
-
-	writel(0x02020404, MVEBU_REGS_BASE + 0x000003bc);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x000003c0);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x000003c4);
-	writel(0x00081239, MVEBU_REGS_BASE + 0x000003dc);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x000002c8);
-	writel(0x00000006, MVEBU_REGS_BASE + 0x00000064);
-	writel(0x10077779, MVEBU_REGS_BASE + 0x00001004);
-	writel(0x1ff00770, MVEBU_REGS_BASE + 0x00001008);
-	writel(0x3f03fc77, MVEBU_REGS_BASE + 0x0000100c);
-	writel(0x00100118, MVEBU_REGS_BASE + 0x00001010);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x00001028);
-	writel(0x03800000, MVEBU_REGS_BASE + 0x00001030);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x00001034);
-	writel(0x00000400, MVEBU_REGS_BASE + 0x00001040);
-	writel(0x80000001, MVEBU_REGS_BASE + 0x000010c0);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x000010d0);
-	writel(0x00011ff0, MVEBU_REGS_BASE + 0x000010e0);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x00001090);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x00001094);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x00001098);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x0000109c);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x000010a0);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x000010a4);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x000010a8);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x000010ac);
-	writel(0x00000000, MVEBU_REGS_BASE + 0x000010b0);
-
-	/* dq_ext_dly: 3:0 */
-	writel(0x00044041, MVEBU_REGS_BASE + 0x00001000);
-	writel(0x00080200, MVEBU_REGS_BASE + 0x00001014);
-	writel(0x00000002, MVEBU_REGS_BASE + 0x00001038);
-	writel(0x00000010, MVEBU_REGS_BASE + 0x0000103c);
-
-	/*phy_rl_cycle_dly 11:8 */
-	writel(0x0000020a, MVEBU_REGS_BASE + 0x00001180);
-	writel(0x0000020a, MVEBU_REGS_BASE + 0x00001184);
-	writel(0x0000020a, MVEBU_REGS_BASE + 0x00001188);
-	writel(0x0000020a, MVEBU_REGS_BASE + 0x0000118c);
-	writel(0x0000020a, MVEBU_REGS_BASE + 0x00001190);
-	writel(0x0000020a, MVEBU_REGS_BASE + 0x00001194);
-	writel(0x0000020a, MVEBU_REGS_BASE + 0x00001198);
-	writel(0x0000020a, MVEBU_REGS_BASE + 0x0000119c);
-	writel(0x0000020a, MVEBU_REGS_BASE + 0x000011a0);
-
-	if (ddr_clock_mhz == 800) {
-		/* ddr_clock_mhz == 800 */
-		writel(0x20200000, MVEBU_REGS_BASE + 0x00001050);
-		writel(0x20200000, MVEBU_REGS_BASE + 0x00001054);
-		writel(0x20200000, MVEBU_REGS_BASE + 0x00001074);
-		/* ddr_clock_mhz == 800 */
-	} else if (ddr_clock_mhz == 600) {
-		/* ddr_clock_mhz == 600 */
-		writel(0x08080000, MVEBU_REGS_BASE + 0x00001050);
-		writel(0x08080000, MVEBU_REGS_BASE + 0x00001054);
-		/* ddr_clock_mhz == 600 */
-	}
-
-	writel(0x08080000, MVEBU_REGS_BASE + 0x00001058);
-	writel(0x08080000, MVEBU_REGS_BASE + 0x0000105c);
-	writel(0x08080000, MVEBU_REGS_BASE + 0x00001060);
-	writel(0x08080000, MVEBU_REGS_BASE + 0x00001064);
-	writel(0x08080000, MVEBU_REGS_BASE + 0x00001068);
-	writel(0x08080000, MVEBU_REGS_BASE + 0x0000106c);
-	writel(0x08080000, MVEBU_REGS_BASE + 0x00001070);
-
-	writel(0x20000000, MVEBU_REGS_BASE + 0x00001020);
-	writel(0x40000000, MVEBU_REGS_BASE + 0x00001020);
-	writel(0x80000000, MVEBU_REGS_BASE + 0x00001020);
-
-	writel(0x11000001, MVEBU_REGS_BASE + 0x00000020);
-
-	/* wait for ddr init done */
-	do {
-		regval = readl(MVEBU_REGS_BASE + 0x00000008) & BIT0;
-	} while (!regval);
-
-	debug_exit();
-	return 0;
-}
 
 /***************************************************************************************************
   * get_ref_clk
@@ -628,8 +465,6 @@ u32 set_clocks(u32 cpu_clk_mhz, u32 ddr_clk_mhz, u32 tbg_a_kvco_mhz, u32 tbg_b_k
 	writel(0x00009FFF, MVEBU_NORTH_CLOCK_SELECT_REG);
 	writel(0x000007AA, MVEBU_SOUTH_CLOCK_SELECT_REG);
 
-	rval = init_ddr_clock(ddr_clk_mhz);
-
 	debug_exit();
 	return rval;
 }
@@ -734,4 +569,3 @@ u32 get_ddr_clk(void)
 
 	return tbg>>1;
 }
-
diff --git a/arch/arm/include/asm/arch-armadalp/misc-regs.h b/arch/arm/include/asm/arch-armadalp/misc-regs.h
new file mode 100644
index 0000000..924796f
--- /dev/null
+++ b/arch/arm/include/asm/arch-armadalp/misc-regs.h
@@ -0,0 +1,35 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+#ifndef _MISC_REGS_H_
+#define _MISC_REGS_H_
+#include <asm/arch-armadalp/regs-base.h>
+
+#define MVEBU_NB_PM_PWRDWN_OPT_REG     (MVEBU_NORTH_PM_REGS_BASE + 0x8)
+#define L2_SRAM_LKG_PD_EN              (BIT8)
+#define CPU_ROM_PD_EN                  (BIT10)
+#define AVS_DISABLE_MODE               (BIT14)
+#define DDRPHY_PAD_PWRDWN_EN           (BIT22)
+
+#define MVEBU_AXI_DCTRL_CTRL_RST_REG   (MVEBU_AXI_DCTRL_REGS_BASE)
+#define DDRPHY_MODE_SELECT             (BIT16)         /* 0: 2 to 1, 1: 4 to 1 */
+
+#define MVEBU_AXI_DCTRL_MCM_SEL_REG    (MVEBU_AXI_DCTRL_REGS_BASE + 0x4)
+
+
+#endif /* _MISC_REGS_H_ */
diff --git a/arch/arm/include/asm/arch-armadalp/regs-base.h b/arch/arm/include/asm/arch-armadalp/regs-base.h
index e063f99..81ba05d 100644
--- a/arch/arm/include/asm/arch-armadalp/regs-base.h
+++ b/arch/arm/include/asm/arch-armadalp/regs-base.h
@@ -55,5 +55,11 @@
 #define MVEBU_SOUTH_CLOCK_REGS_BASE	(MVEBU_REGS_BASE + 0x18000)
 #define MVEBU_TESTPIN_NORTH_REG_BASE	(MVEBU_NORTH_CLOCK_REGS_BASE + 0x800)
 
+/* PM */
+#define MVEBU_NORTH_PM_REGS_BASE	(MVEBU_REGS_BASE + 0x14000)
+#define MVEBU_SOUTH_PM_REGS_BASE	(MVEBU_REGS_BASE + 0x19000)
+
+/* AXI DCTRL */
+#define MVEBU_AXI_DCTRL_REGS_BASE	(MVEBU_REGS_BASE + 0x2000)
 
 #endif	/* _REGS_BASE_H_ */
diff --git a/drivers/ddr/ddr_mckinley6.h b/drivers/ddr/ddr_mckinley6.h
index f3f602d..18921e3 100644
--- a/drivers/ddr/ddr_mckinley6.h
+++ b/drivers/ddr/ddr_mckinley6.h
@@ -39,6 +39,8 @@
 #define MMAP_AREA_LEN_MASK		(0x1F << 16)
 #define MMAP_AREA_LEN(x)		((x) << 16)
 
+#define DRAM_INIT_TIMEOUT		1000
+
 /* DLL Tune definitions */
 #define DLL_PHSEL_START			0x00
 #define DLL_PHSEL_END			0x3F
diff --git a/drivers/ddr/ddr_mckinley6_arlp.c b/drivers/ddr/ddr_mckinley6_arlp.c
index 4766e6e..87034eb 100644
--- a/drivers/ddr/ddr_mckinley6_arlp.c
+++ b/drivers/ddr/ddr_mckinley6_arlp.c
@@ -22,25 +22,111 @@
 #include <asm/arch-mvebu/mvebu.h>
 #include <asm/arch-mvebu/ddr.h>
 #include <asm/arch-mvebu/system_info.h>
+#include <asm/arch-armadalp/misc-regs.h>
 #include "ddr_mckinley6.h"
 
-
 enum mvebu_mck_freq_support {
-	FREQ_650_HZ = 0,
-	MAX_HZ_SUPPORTED,
+	FREQ_600_MHZ = 0,
+	FREQ_800_MHZ = 1,
+	MAX_MHZ_SUPPORTED,
 };
 
 struct mvebu_mckinley_config {
 	u32 reg_offset;
-	u32 values[MAX_HZ_SUPPORTED];
+	u32 values[MAX_MHZ_SUPPORTED];
 };
 
 struct mvebu_mckinley_config mckinley_mac_config[] = {
-	{ -1, { -1} }
+	{ 0x340, {0x0f0f0fef, 0x0f0f0fef} },
+	{ 0x344, {0x100000aa, 0x100000aa} },
+	{ 0x310, {0x00200000, 0x00200000} },
+	{ 0x304, {0x00000000, 0x00000000} },
+	{ 0x308, {0x00000000, 0x00000000} },
+	{ 0x200, {0x000E0001, 0x000E0001} },
+	{ 0x204, {0x00000000, 0x00000000} },
+	{ 0x220, {0x13020532, 0x13020532} },
+	{ 0x044, {0x00030200, 0x00030200} },
+	{ 0x2C0, {0x00006000, 0x00006000} },
+	{ 0x2C4, {0x00100020, 0x00100020} },
+	{ 0x058, {0x0000143f, 0x0000143f} },
+	{ 0x048, {0x00000001, 0x00000001} },
+	{ 0x180, {0x00010200, 0x00010200} },
+	{ 0x050, {0x000001ff, 0x000001ff} },
+	{ 0x04C, {0x00000000, 0x00000000} },
+	{ 0x054, {0x00000480, 0x00000480} },
+	{ 0x300, {0x00000708, 0x0000080B} },
+	{ 0x380, {0x000001F5, 0x0007A120} },
+	{ 0x384, {0x000003E9, 0x00030D40} },
+	{ 0x388, {0x09600043, 0x0960006B} },
+	{ 0x38C, {0x00000200, 0x00000200} },
+	{ 0x390, {0x00400100, 0x00400100} },
+	{ 0x394, {0x006B03CF, 0x00F003CF} },
+	{ 0x398, {0x00720200, 0x00F80200} },
+	{ 0x39C, {0x00120707, 0x00000808} },
+	{ 0x3A0, {0x00040511, 0x00040614} },
+	{ 0x3A4, {0x00000001, 0x00000001} },
+	{ 0x3A8, {0x00000C04, 0x00000C04} },
+	{ 0x3AC, {0x15210919, 0x202A0C1F} },
+	{ 0x3B0, {0x090b0609, 0x0C0C060C} },
+	{ 0x3B4, {0x04000600, 0x04000600} },
+	{ 0x3B8, {0x00000600, 0x00000800} },
+	{ 0x3BC, {0x02020404, 0x02020404} },
+	{ 0x3C0, {0x00000000, 0x00000000} },
+	{ 0x3C4, {0x00000000, 0x00000000} },
+	{ 0x3DC, {0x00081239, 0x00081239} },
+	{ 0x2C8, {0x00000000, 0x00000000} },
+	{ 0x064, {0x00000006, 0x00000006} },
+	{ -1, {-1, -1} }
 };
 
 struct mvebu_mckinley_config mckinley_phy_config[] = {
-	{-1, {-1} },
+	{ 0x004, {0x10077779, 0x10077779} },
+	{ 0x008, {0x1ff00770, 0x1ff00770} },
+	{ 0x00C, {0x3f03fc77, 0x3f03fc77} },
+	{ 0x010, {0x00100118, 0x00100118} },
+	{ 0x028, {0x00000000, 0x00000000} },
+	{ 0x030, {0x03800000, 0x03800000} },
+	{ 0x034, {0x00000000, 0x00000000} },
+	{ 0x040, {0x00000400, 0x00000400} },
+	{ 0x0C0, {0x80000001, 0x80000001} },
+	{ 0x0D0, {0x00000000, 0x00000000} },
+	{ 0x0E0, {0x00011ff0, 0x00011ff0} },
+	{ 0x090, {0x00000000, 0x00000000} },
+	{ 0x094, {0x00000000, 0x00000000} },
+	{ 0x098, {0x00000000, 0x00000000} },
+	{ 0x09C, {0x00000000, 0x00000000} },
+	{ 0x0A0, {0x00000000, 0x00000000} },
+	{ 0x0A4, {0x00000000, 0x00000000} },
+	{ 0x0A8, {0x00000000, 0x00000000} },
+	{ 0x0AC, {0x00000000, 0x00000000} },
+	{ 0x0B0, {0x00000000, 0x00000000} },
+	{ 0x000, {0x00044041, 0x00044041} },
+	{ 0x014, {0x00080200, 0x00080200} },
+	{ 0x038, {0x00000002, 0x00000002} },
+	{ 0x03C, {0x00000010, 0x00000010} },
+	{ 0x180, {0x0000020a, 0x0000020a} },
+	{ 0x184, {0x0000020a, 0x0000020a} },
+	{ 0x188, {0x0000020a, 0x0000020a} },
+	{ 0x18C, {0x0000020a, 0x0000020a} },
+	{ 0x190, {0x0000020a, 0x0000020a} },
+	{ 0x194, {0x0000020a, 0x0000020a} },
+	{ 0x198, {0x0000020a, 0x0000020a} },
+	{ 0x19C, {0x0000020a, 0x0000020a} },
+	{ 0x1A0, {0x0000020a, 0x0000020a} },
+	{ 0x050, {0x08080000, 0x20200000} },
+	{ 0x054, {0x08080000, 0x20200000} },
+	{ 0x074, {0x20200000, 0x20200000} },
+	{ 0x058, {0x08080000, 0x08080000} },
+	{ 0x05C, {0x08080000, 0x08080000} },
+	{ 0x060, {0x08080000, 0x08080000} },
+	{ 0x064, {0x08080000, 0x08080000} },
+	{ 0x068, {0x08080000, 0x08080000} },
+	{ 0x06C, {0x08080000, 0x08080000} },
+	{ 0x070, {0x08080000, 0x08080000} },
+	{ 0x020, {0x20000000, 0x20000000} },
+	{ 0x020, {0x40000000, 0x40000000} },
+	{ 0x020, {0x80000000, 0x80000000} },
+	{-1, {-1, -1} },
 };
 
 void mvebu_dram_mac_init(struct mvebu_dram_config *dram_config)
@@ -49,22 +135,41 @@ void mvebu_dram_mac_init(struct mvebu_dram_config *dram_config)
 	struct mvebu_mckinley_config *mac_config = &mckinley_mac_config[0];
 	u32 freq_indx, reg, idx, size;
 
-	/* This function has to be re-implemented for ArLP. Currently it is invalid */
-	return;
-
 	debug_enter();
-	debug("Set bypass to clock gate: 0xF06f0098 - 0x0040004e\n");
-	writel(0x0040004e, 0xF06f0098);
-	debug("Enable vreg power-up: 0xF06F0108 - 0xFFFF0001\n");
-	writel(0xFFFF0001, 0xF06F0108);
-	debug("Enable channel 0: 0xF0841100 - 0x80000000\n");
-	writel(0x80000000, 0xF0841100);
-
-	/* for now set the frequency to 650 (index 0) */
-	freq_indx = 0;
+
+	debug("Set Power-down options: %#lX <<- %#X\n", MVEBU_NB_PM_PWRDWN_OPT_REG,
+	      L2_SRAM_LKG_PD_EN | CPU_ROM_PD_EN | AVS_DISABLE_MODE  | DDRPHY_PAD_PWRDWN_EN);
+	writel(L2_SRAM_LKG_PD_EN | CPU_ROM_PD_EN |
+	       AVS_DISABLE_MODE  | DDRPHY_PAD_PWRDWN_EN, MVEBU_NB_PM_PWRDWN_OPT_REG);
+
+	debug("Set DDR PHY mode: %#lX <<- %#X\n", MVEBU_AXI_DCTRL_CTRL_RST_REG, DDRPHY_MODE_SELECT);
+	writel(DDRPHY_MODE_SELECT, MVEBU_AXI_DCTRL_CTRL_RST_REG);
+
+	debug("Reset monitor signal select: %#lX - 0x0000000\n", MVEBU_AXI_DCTRL_MCM_SEL_REG);
+	writel(0x00000000, MVEBU_AXI_DCTRL_MCM_SEL_REG);
+
+	switch (dram_config->freq_mhz) {
+	case 600:
+		freq_indx = FREQ_600_MHZ;
+		break;
+	case 800:
+		freq_indx = FREQ_800_MHZ;
+		break;
+	default:
+		error("DDR MAC: Invalid DDR frequency %d. Falling into default value\n",
+		      dram_config->freq_mhz);
+		dram_config->freq_mhz = 600;
+		freq_indx = FREQ_600_MHZ;
+	}
+
+	debug("DDR MAC @ %d MHz\n", dram_config->freq_mhz);
+
+	/* Walk trough MAC static configurations array */
 	for (; mac_config->reg_offset != -1 ; mac_config++)
 		mck6_writel(mac_config->values[freq_indx], base_addr + mac_config->reg_offset);
 
+	debug("DDR MAC initialization done\n");
+
 	/* Override the above configurations, with user parameters. */
 	if (dram_config->bus_width != 0) {
 		/* DRAM width */
@@ -141,16 +246,30 @@ void mvebu_dram_phy_init(struct mvebu_dram_config *dram_config)
 	void __iomem *base_addr = dram_config->phy_base;
 	struct mvebu_mckinley_config *phy_config = &mckinley_phy_config[0];
 	u32 freq_indx, reg, cs_mask;
-
-	/* This function has to be re-implemented for ArLP. Currently it is invalid */
-	return;
+	s32 timeout;
 
 	debug_enter();
-	/* for now set the frequency to 650 (index 0) */
-	freq_indx = 0;
+
+	switch (dram_config->freq_mhz) {
+	case 600:
+		freq_indx = FREQ_600_MHZ;
+		break;
+	case 800:
+		freq_indx = FREQ_800_MHZ;
+		break;
+	default:
+		error("DDR PHY: Invalid DDR frequency %d. Falling into default 600MHz\n",
+		      dram_config->freq_mhz);
+		freq_indx = FREQ_600_MHZ;
+	}
+
+	debug("DDR PHY @ %d MHz\n", dram_config->freq_mhz);
+
+	/* Walk trough PHY static configurations array */
 	for (; phy_config->reg_offset != -1 ; phy_config++)
 		mck6_writel(phy_config->values[freq_indx], base_addr + phy_config->reg_offset);
 
+	debug("DDR PHY setup is done. Triggering DDR init.\n");
 	/* Trigger DDR init for Channel 0, all Chip-Selects */
 	reg = SDRAM_INIT_REQ_MASK;
 	reg |= CMD_CH_ENABLE(0);
@@ -158,9 +277,21 @@ void mvebu_dram_phy_init(struct mvebu_dram_config *dram_config)
 	if (dram_config->cs_count)
 		cs_mask = (1 << dram_config->cs_count) - 1;
 	reg |= CMD_CS_MASK(cs_mask);
-	mck6_writel(reg, base_addr + MCK6_USER_COMMAND_0_REG);
+	mck6_writel(reg, dram_config->mac_base + MCK6_USER_COMMAND_0_REG);
+
+	/* wait for ddr init done */
+	for (timeout = DRAM_INIT_TIMEOUT, reg = 0; (timeout >= 0) && (reg != INIT_DONE0_CH0); timeout--) {
+		reg = readl(dram_config->mac_base + MCK6_DRAM_STATUS_REG) & INIT_DONE0_CH0;
+		udelay(10);
+	}
+
+	if (timeout < 0)
+		error("DDR init timeout!\n");
+
+	debug("DDR init is done.\n");
+
 #ifdef CONFIG_MVEBU_SYS_INFO
-	set_dram_info(base_addr);
+	set_dram_info(dram_config->mac_base);
 #endif
 	debug_exit();
 }
-- 
1.9.1

