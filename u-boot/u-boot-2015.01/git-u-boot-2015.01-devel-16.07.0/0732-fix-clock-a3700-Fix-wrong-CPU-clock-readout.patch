From 4b26abeddb4cab75af5f118e69839c332a2d8b0c Mon Sep 17 00:00:00 2001
From: Konstantin Porotchkin <kostap@marvell.com>
Date: Mon, 25 Jan 2016 15:21:19 +0200
Subject: [PATCH 0732/1240] fix: clock: a3700: Fix wrong CPU clock readout

- Fix functions calculating CPU and DDR clock out of
  values in TBG registers.
- When reading the clock connection line it is important
  to distinguish between single-ended and differential
  clock lines (TBG_A_S vs TBG_A_P and TBG_B_S vs TBG_B_P)
  since these clock lines have separate dividers.
- Only DDR MCLK always connected to TBG_A_S, the CPU clock
  can be sources from any of the above 4 clock lines.

Change-Id: I1601f794bd7632c3d0a95a543edd47e659ae53b8
Signed-off-by: Konstantin Porotchkin <kostap@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/27003
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
---
 arch/arm/cpu/armv8/armadalp/mvebu_clock.c | 31 +++++++++++++++++++++----------
 1 file changed, 21 insertions(+), 10 deletions(-)

diff --git a/arch/arm/cpu/armv8/armadalp/mvebu_clock.c b/arch/arm/cpu/armv8/armadalp/mvebu_clock.c
index 9a6bc9a..316e517 100644
--- a/arch/arm/cpu/armv8/armadalp/mvebu_clock.c
+++ b/arch/arm/cpu/armv8/armadalp/mvebu_clock.c
@@ -503,7 +503,7 @@ int init_clock(void)
 	return ret;
 }
 
-static u32 get_tbg_clk(enum a3700_clock_src tbg_typ)
+static u32 get_tbg_clk(enum a3700_clock_line tbg_typ)
 {
 	u32 tbg_M, tbg_N, vco_div;
 	u32 ref, reg_val;
@@ -513,17 +513,28 @@ static u32 get_tbg_clk(enum a3700_clock_src tbg_typ)
 
 	/* get M, N */
 	reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL7);
-	tbg_M = (tbg_typ == TBG_A) ? (reg_val & 0x1FFUL) : ((reg_val >> 16) & 0x1FFUL);
+	tbg_M = ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_A_P)) ?
+		(reg_val & 0x1FFUL) : ((reg_val >> 16) & 0x1FFUL);
 	tbg_M = (tbg_M == 0) ? 1 : tbg_M;
 
 	reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
-	tbg_N = (tbg_typ == TBG_A) ? ((reg_val >> 2) & 0x1FFUL) : ((reg_val >> 18) & 0x1FFUL);
-
-	/* get VCODIV */
-	reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
-	reg_val = (tbg_typ == TBG_A) ? (reg_val & 0x1FFUL) : ((reg_val >> 16) & 0x1FFUL);
+	tbg_N = ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_A_P)) ?
+		((reg_val >> 2) & 0x1FFUL) : ((reg_val >> 18) & 0x1FFUL);
+
+	if ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_B_S)) {
+		/* get SE VCODIV */
+		reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
+		reg_val = (tbg_typ == TBG_A_S) ?
+			  (reg_val & 0x1FFUL) : ((reg_val >> 16) & 0x1FFUL);
+	} else {
+		/* get DIFF VCODIV */
+		reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL8);
+		reg_val = (tbg_typ == TBG_A_P) ?
+			  ((reg_val >> 1) & 0x1FFUL) : ((reg_val >> 17) & 0x1FFUL);
+	}
 	if (reg_val > 7)
 		return 0; /*invalid*/
+
 	vco_div = 0x1 << reg_val;
 
 	return ((tbg_N * ref) << 2)/(tbg_M * vco_div);
@@ -532,14 +543,14 @@ static u32 get_tbg_clk(enum a3700_clock_src tbg_typ)
 u32 get_cpu_clk(void)
 {
 	u32 tbg, cpu_prscl;
-	enum a3700_clock_src tbg_typ;
+	enum a3700_clock_line tbg_typ;
 
 	/* 1. check cpu clock select */
 	if (!((readl(MVEBU_NORTH_CLOCK_SELECT_REG) >> 15) & 0x1))
 		return 0; /* CPU clock is using XTAL output*/
 
 	/* 2. get TBG select */
-	tbg_typ = (readl(MVEBU_NORTH_CLOCK_TBG_SELECT_REG) >> 22) & 0x1;
+	tbg_typ = (readl(MVEBU_NORTH_CLOCK_TBG_SELECT_REG) >> 22) & 0x3;
 
 	/* 3. get TBG clock */
 	tbg = get_tbg_clk(tbg_typ);
@@ -563,7 +574,7 @@ u32 get_ddr_clk(void)
 		return 0; /* DDR clock is using XTAL output*/
 
 	/* 2. get TBG_A clock */
-	tbg = get_tbg_clk(TBG_A);
+	tbg = get_tbg_clk(TBG_A_S);
 	if (tbg == 0)
 		return 0;
 
-- 
1.9.1

