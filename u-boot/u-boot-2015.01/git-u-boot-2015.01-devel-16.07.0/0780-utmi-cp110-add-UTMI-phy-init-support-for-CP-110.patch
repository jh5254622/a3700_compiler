From c6459644a3b4b6519a03fef5a2eaac9efded7559 Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Thu, 28 Jan 2016 10:52:46 +0200
Subject: [PATCH 0780/1240] utmi: cp110: add UTMI phy init support for CP-110

- Add support for UTMI PHY initialization for CP-110
- Add FDT node for UTMI & enable it for CP110

Change-Id: I8d4035f59a74e39cddab39070bcdfd7028c823e5
Signed-off-by: Hanna Hawa <hannah@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/27060
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
---
 arch/arm/dts/cp110.dtsi                         |  16 ++
 arch/arm/include/asm/arch-mvebu/comphy.h        |   3 +-
 arch/arm/include/asm/arch-mvebu/utmi_phy.h      |  81 +++++++++++
 doc/device-tree-bindings/phy/mvebu_utmi_phy.txt |  30 ++++
 drivers/phy/comphy_cp110.c                      | 186 ++++++++++++++++++++++++
 include/dt-bindings/comphy/comphy_data.h        |   5 +
 include/fdtdec.h                                |   1 +
 lib/fdtdec.c                                    |   3 +-
 8 files changed, 323 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/include/asm/arch-mvebu/utmi_phy.h
 create mode 100644 doc/device-tree-bindings/phy/mvebu_utmi_phy.txt

diff --git a/arch/arm/dts/cp110.dtsi b/arch/arm/dts/cp110.dtsi
index e0a47a5..01cb877 100644
--- a/arch/arm/dts/cp110.dtsi
+++ b/arch/arm/dts/cp110.dtsi
@@ -71,6 +71,22 @@ mmc@780000 {
 	reg = <0x780000 0x300>;
 	status = "disabled";
 };
+utmi0@580000 {
+	compatible = "marvell,mvebu-utmi-2.6.0";
+	reg-utmi-unit = <0x580000 0x1000>;
+	reg-usb-cfg = <0x440420 0x4>;
+	reg-utmi-cfg = <0x440440 0x4>;
+	utmi-port = <UTMI_PHY_TO_USB_HOST0>;
+	status = "okay";
+};
+utmi1@581000 {
+	compatible = "marvell,mvebu-utmi-2.6.0";
+	reg-utmi-unit = <0x581000 0x1000>;
+	reg-usb-cfg = <0x440420 0x4>;
+	reg-utmi-cfg = <0x440444 0x4>;
+	utmi-port = <UTMI_PHY_TO_USB_HOST1>;
+	status = "okay";
+};
 usb3@500000 { /* USB3_H0 */
 	compatible = "marvell,mvebu-usb3";
 	reg = <0x500000 0x450>;
diff --git a/arch/arm/include/asm/arch-mvebu/comphy.h b/arch/arm/include/asm/arch-mvebu/comphy.h
index 5864e28..c3a58b4 100644
--- a/arch/arm/include/asm/arch-mvebu/comphy.h
+++ b/arch/arm/include/asm/arch-mvebu/comphy.h
@@ -42,7 +42,8 @@
 #define COMMON_SELECTOR_PHY_OFFSET		0x140
 #define COMMON_SELECTOR_PIPE_OFFSET		0x144
 
-#define MAX_LANE_OPTIONS 10
+#define MAX_LANE_OPTIONS			10
+#define MAX_UTMI_PHY_COUNT			2
 
 struct comphy_mux_options {
 	u32 type;
diff --git a/arch/arm/include/asm/arch-mvebu/utmi_phy.h b/arch/arm/include/asm/arch-mvebu/utmi_phy.h
new file mode 100644
index 0000000..2dc98f2
--- /dev/null
+++ b/arch/arm/include/asm/arch-mvebu/utmi_phy.h
@@ -0,0 +1,81 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+#ifndef _UTMI_PHY_H_
+#define _UTMI_PHY_H_
+
+#define UTMI_USB_CFG_DEVICE_EN_OFFSET		0
+#define UTMI_USB_CFG_DEVICE_EN_MASK		(0x1 << UTMI_USB_CFG_DEVICE_EN_OFFSET)
+#define UTMI_USB_CFG_DEVICE_MUX_OFFSET		1
+#define UTMI_USB_CFG_DEVICE_MUX_MASK		(0x1 << UTMI_USB_CFG_DEVICE_MUX_OFFSET)
+#define UTMI_USB_CFG_PLL_OFFSET			25
+#define UTMI_USB_CFG_PLL_MASK			(0x1 << UTMI_USB_CFG_PLL_OFFSET)
+
+#define UTMI_PHY_CFG_PU_OFFSET			5
+#define UTMI_PHY_CFG_PU_MASK			(0x1 << UTMI_PHY_CFG_PU_OFFSET)
+
+#define UTMI_PLL_CTRL_REG			0x0
+#define UTMI_PLL_CTRL_REFDIV_OFFSET		0
+#define UTMI_PLL_CTRL_REFDIV_MASK		(0x7f << UTMI_PLL_CTRL_REFDIV_OFFSET)
+#define UTMI_PLL_CTRL_FBDIV_OFFSET		16
+#define UTMI_PLL_CTRL_FBDIV_MASK		(0x1FF << UTMI_PLL_CTRL_FBDIV_OFFSET)
+#define UTMI_PLL_CTRL_SEL_LPFR_OFFSET		28
+#define UTMI_PLL_CTRL_SEL_LPFR_MASK		(0x3 << UTMI_PLL_CTRL_SEL_LPFR_OFFSET)
+#define UTMI_PLL_CTRL_PLL_RDY_OFFSET		31
+#define UTMI_PLL_CTRL_PLL_RDY_MASK		(0x1 << UTMI_PLL_CTRL_PLL_RDY_OFFSET)
+
+#define UTMI_CALIB_CTRL_REG			0x8
+#define UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET	8
+#define UTMI_CALIB_CTRL_IMPCAL_VTH_MASK		(0x7 << UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET)
+#define UTMI_CALIB_CTRL_IMPCAL_DONE_OFFSET	23
+#define UTMI_CALIB_CTRL_IMPCAL_DONE_MASK	(0x1 << UTMI_CALIB_CTRL_IMPCAL_DONE_OFFSET)
+#define UTMI_CALIB_CTRL_PLLCAL_DONE_OFFSET	31
+#define UTMI_CALIB_CTRL_PLLCAL_DONE_MASK	(0x1 << UTMI_CALIB_CTRL_PLLCAL_DONE_OFFSET)
+
+#define UTMI_TX_CH_CTRL_REG			0xC
+#define UTMI_TX_CH_CTRL_DRV_EN_LS_OFFSET	12
+#define UTMI_TX_CH_CTRL_DRV_EN_LS_MASK		(0xf << UTMI_TX_CH_CTRL_DRV_EN_LS_OFFSET)
+#define UTMI_TX_CH_CTRL_IMP_SEL_LS_OFFSET	16
+#define UTMI_TX_CH_CTRL_IMP_SEL_LS_MASK		(0xf << UTMI_TX_CH_CTRL_IMP_SEL_LS_OFFSET)
+
+#define UTMI_RX_CH_CTRL0_REG			0x14
+#define UTMI_RX_CH_CTRL0_SQ_DET_OFFSET		15
+#define UTMI_RX_CH_CTRL0_SQ_DET_MASK		(0x1 << UTMI_RX_CH_CTRL0_SQ_DET_OFFSET)
+#define UTMI_RX_CH_CTRL0_SQ_ANA_DTC_OFFSET	28
+#define UTMI_RX_CH_CTRL0_SQ_ANA_DTC_MASK	(0x1 << UTMI_RX_CH_CTRL0_SQ_ANA_DTC_OFFSET)
+
+#define UTMI_RX_CH_CTRL1_REG			0x18
+#define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_OFFSET	0
+#define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_MASK	(0x3 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_OFFSET)
+#define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_OFFSET	3
+#define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_MASK	(0x1 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_OFFSET)
+
+#define UTMI_CTRL_STATUS0_REG			0x24
+#define UTMI_CTRL_STATUS0_SUSPENDM_OFFSET	22
+#define UTMI_CTRL_STATUS0_SUSPENDM_MASK		(0x1 << UTMI_CTRL_STATUS0_SUSPENDM_OFFSET)
+#define UTMI_CTRL_STATUS0_TEST_SEL_OFFSET	25
+#define UTMI_CTRL_STATUS0_TEST_SEL_MASK		(0x1 << UTMI_CTRL_STATUS0_TEST_SEL_OFFSET)
+
+#define UTMI_CHGDTC_CTRL_REG			0x38
+#define UTMI_CHGDTC_CTRL_VDAT_OFFSET		8
+#define UTMI_CHGDTC_CTRL_VDAT_MASK		(0x3 << UTMI_CHGDTC_CTRL_VDAT_OFFSET)
+#define UTMI_CHGDTC_CTRL_VSRC_OFFSET		10
+#define UTMI_CHGDTC_CTRL_VSRC_MASK		(0x3 << UTMI_CHGDTC_CTRL_VSRC_OFFSET)
+
+#endif /* _UTMI_PHY_H_ */
+
diff --git a/doc/device-tree-bindings/phy/mvebu_utmi_phy.txt b/doc/device-tree-bindings/phy/mvebu_utmi_phy.txt
new file mode 100644
index 0000000..ab9c906
--- /dev/null
+++ b/doc/device-tree-bindings/phy/mvebu_utmi_phy.txt
@@ -0,0 +1,30 @@
+Marvell UTMI PHY bindings
+=====================================
+
+The UTMI PHY node include description about the UTMI phy unit.
+The driver initialize the UTMI PHY, according to the FDT blob configurations.
+
+Mandatory properties:
+	- compatible:
+		"marvell,mvebu-utmi-2.6.0" for UTMI unit version 2.6.0 (version in design team)
+	- reg-utmi-unit: base address of the UTMI unit
+	- reg-usb-cfg: address of USB Configuration register
+	- reg-utmi-cfg: address of external UTMI configuration
+	- utmi-port: the type of the connected USB port
+	posible options under: include/dt-bindings/comphy/comphy_data.h
+
+Note:
+For Armada-8k - there is 2 UTMI units in the SoC, the limitation of the UTMI PHY:
+	UTMI 0 can be connected to USB HOST 0 or USB DEVICE
+	UTMI 1 can be connected to USB HOST 1 or USB DEVICE
+
+Example:
+utmi0@580000 {
+	compatible = "marvell,mvebu-utmi-2.6.0";
+	reg-utmi-unit = <0x580000 0x1000>;
+	reg-usb-cfg = <0x440420 0x4>;
+	reg-utmi-cfg = <0x440440 0x4>;
+	utmi-port = <UTMI_PHY_TO_USB_HOST0>;
+	status = "okay";
+};
+
diff --git a/drivers/phy/comphy_cp110.c b/drivers/phy/comphy_cp110.c
index a9f22da..c39fba3 100644
--- a/drivers/phy/comphy_cp110.c
+++ b/drivers/phy/comphy_cp110.c
@@ -22,9 +22,12 @@
 #include <asm/arch-mvebu/sata.h>
 #include <asm/arch-mvebu/comphy.h>
 #include <asm/arch-mvebu/comphy_hpipe.h>
+#include <asm/arch-mvebu/utmi_phy.h>
 #include <asm/arch-mvebu/mvebu.h>
 #include <asm/arch-mvebu/fdt.h>
 
+DECLARE_GLOBAL_DATA_PTR;
+
 #define SD_ADDR(base, lane)			(base + 0x1000 * lane)
 #define HPIPE_ADDR(base, lane)			(SD_ADDR(base, lane) + 0x800)
 #define COMPHY_ADDR(base, lane)			(base + 0x28 * lane)
@@ -463,6 +466,185 @@ static int comphy_sata_power_up(u32 lane, void __iomem *hpipe_base, void __iomem
 	return ret;
 }
 
+static u32 comphy_utmi_phy_init(u32 utmi_index, void __iomem *utmi_base_addr,
+				void __iomem *usb_cfg_addr, void __iomem *utmi_cfg_addr, u32 utmi_phy_port)
+{
+	u32 mask, data, ret = 1;
+
+	debug_enter();
+
+	debug("stage: Power down transceiver (power down Phy), Power down PLL, and SuspendDM\n");
+	/* Power down UTMI PHY */
+	reg_set(utmi_cfg_addr, 0x0 << UTMI_PHY_CFG_PU_OFFSET, UTMI_PHY_CFG_PU_MASK);
+	/* Config USB3 Device UTMI enable */
+	mask = UTMI_USB_CFG_DEVICE_EN_MASK;
+	/* Prior to PHY init, configure mux for Device
+	(Device can be connected to UTMI0 or to UTMI1) */
+	if (utmi_phy_port == UTMI_PHY_TO_USB_DEVICE0) {
+		data = 0x1 << UTMI_USB_CFG_DEVICE_EN_OFFSET;
+		/* Config USB3 Device UTMI MUX */
+		mask |= UTMI_USB_CFG_DEVICE_MUX_MASK;
+		data |= utmi_index << UTMI_USB_CFG_DEVICE_MUX_OFFSET;
+	} else {
+		data = 0x0 << UTMI_USB_CFG_DEVICE_EN_OFFSET;
+	}
+	/* Power down PLL */
+	mask |= UTMI_USB_CFG_PLL_MASK;
+	data |= 0x0 << UTMI_USB_CFG_PLL_OFFSET;
+	reg_set(usb_cfg_addr, data, mask);
+	/* Set Test suspendm mode */
+	mask = UTMI_CTRL_STATUS0_SUSPENDM_MASK;
+	data = 0x1 << UTMI_CTRL_STATUS0_SUSPENDM_OFFSET;
+	/* Enable Test UTMI select */
+	mask |= UTMI_CTRL_STATUS0_TEST_SEL_MASK;
+	data |= 0x1 << UTMI_CTRL_STATUS0_TEST_SEL_OFFSET;
+	reg_set(utmi_base_addr + UTMI_CTRL_STATUS0_REG, data, mask);
+
+	/* Wait for UTMI power down */
+	mdelay(1);
+
+	debug("stage: Configure UTMI PHY registers\n");
+	/* Reference Clock Divider Select */
+	mask = UTMI_PLL_CTRL_REFDIV_MASK;
+	data = 0x5 << UTMI_PLL_CTRL_REFDIV_OFFSET;
+	/* Feedback Clock Divider Select - 90 for 25Mhz*/
+	mask |= UTMI_PLL_CTRL_FBDIV_MASK;
+	data |= 60 << UTMI_PLL_CTRL_FBDIV_OFFSET;
+	/* Select LPFR - 0x0 for 25Mhz/5=5Mhz*/
+	mask |= UTMI_PLL_CTRL_SEL_LPFR_MASK;
+	data |= 0x0 << UTMI_PLL_CTRL_SEL_LPFR_OFFSET;
+	reg_set(utmi_base_addr + UTMI_PLL_CTRL_REG, data, mask);
+
+	/* Impedance Calibration Threshold Setting */
+	reg_set(utmi_base_addr + UTMI_CALIB_CTRL_REG,
+		0x6 << UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET, UTMI_CALIB_CTRL_IMPCAL_VTH_MASK);
+
+	/* Set LS TX driver strength coarse control */
+	mask = UTMI_TX_CH_CTRL_DRV_EN_LS_MASK;
+	data = 0x3 << UTMI_TX_CH_CTRL_DRV_EN_LS_OFFSET;
+	/* Set LS TX driver fine adjustment */
+	mask |= UTMI_TX_CH_CTRL_IMP_SEL_LS_MASK;
+	data |= 0x3 << UTMI_TX_CH_CTRL_IMP_SEL_LS_OFFSET;
+	reg_set(utmi_base_addr + UTMI_TX_CH_CTRL_REG, data, mask);
+
+	/* Enable SQ */
+	mask = UTMI_RX_CH_CTRL0_SQ_DET_MASK;
+	data = 0x0 << UTMI_RX_CH_CTRL0_SQ_DET_OFFSET;
+	/* Enable analog squelch detect */
+	mask |= UTMI_RX_CH_CTRL0_SQ_ANA_DTC_MASK;
+	data |= 0x1 << UTMI_RX_CH_CTRL0_SQ_ANA_DTC_OFFSET;
+	reg_set(utmi_base_addr + UTMI_RX_CH_CTRL0_REG, data, mask);
+
+	/* Set External squelch calibration number */
+	mask = UTMI_RX_CH_CTRL1_SQ_AMP_CAL_MASK;
+	data = 0x1 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_OFFSET;
+	/* Enable the External squelch calibration */
+	mask |= UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_MASK;
+	data |= 0x1 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_OFFSET;
+	reg_set(utmi_base_addr + UTMI_RX_CH_CTRL1_REG, data, mask);
+
+	/* Set Control VDAT Reference Voltage - 0.325V */
+	mask = UTMI_CHGDTC_CTRL_VDAT_MASK;
+	data = 0x1 << UTMI_CHGDTC_CTRL_VDAT_OFFSET;
+	/* Set Control VSRC Reference Voltage - 0.6V */
+	mask |= UTMI_CHGDTC_CTRL_VSRC_MASK;
+	data |= 0x1 << UTMI_CHGDTC_CTRL_VSRC_OFFSET;
+	reg_set(utmi_base_addr + UTMI_CHGDTC_CTRL_REG, data, mask);
+
+	debug("stage: Power up transceiver(Power up Phy), Power up PLL, and exit SuspendDM\n");
+	/* Power UP UTMI PHY */
+	reg_set(utmi_cfg_addr, 0x1 << UTMI_PHY_CFG_PU_OFFSET, UTMI_PHY_CFG_PU_MASK);
+	/* Power up PLL */
+	reg_set(usb_cfg_addr, 0x1 << UTMI_USB_CFG_PLL_OFFSET, UTMI_USB_CFG_PLL_MASK);
+	/* Disable Test UTMI select */
+	reg_set(utmi_base_addr + UTMI_CTRL_STATUS0_REG,
+		0x1 << UTMI_CTRL_STATUS0_TEST_SEL_OFFSET, UTMI_CTRL_STATUS0_TEST_SEL_MASK);
+
+	debug("stage: Wait for PLL and impedance calibration done, and PLL ready done\n");
+	mdelay(5);
+
+	debug("stage: Check PLL\n");
+	data = readl(utmi_base_addr + UTMI_CALIB_CTRL_REG);
+	if ((data & UTMI_CALIB_CTRL_IMPCAL_DONE_MASK) == 0) {
+		error("Impedance calibration is not done\n");
+		ret = 0;
+	}
+	if ((data & UTMI_CALIB_CTRL_PLLCAL_DONE_MASK) == 0) {
+		error("PLL calibration is not done\n");
+		ret = 0;
+	}
+	data = readl(utmi_base_addr + UTMI_PLL_CTRL_REG);
+	if ((data & UTMI_PLL_CTRL_PLL_RDY_MASK) == 0) {
+		error("PLL is not ready\n");
+		ret = 0;
+	}
+
+	debug_exit();
+	return ret;
+}
+
+/* comphy_dedicated_phys_init initialize the dedicated PHYs - not muxed SerDes lanes
+** e.g. UTMI PHY */
+static void comphy_dedicated_phys_init(void)
+{
+	void __iomem *utmi_base_addr, *usb_cfg_addr, *utmi_cfg_addr;
+	int node_list[MAX_UTMI_PHY_COUNT], node;
+	int i, count, utmi_phy_port;
+
+	debug_enter();
+	debug("Initialize USB UTMI PHYs\n");
+	/* Find the UTMI phy node in device tree and go over them */
+	count = fdtdec_find_aliases_for_id(gd->fdt_blob, "utmi",
+			COMPAT_MVEBU_UTMI_PHY, node_list, MAX_UTMI_PHY_COUNT);
+
+	/* check if UTMI phy nodes exists */
+	if (count == 0) {
+		debug("could not find UTMI phy node in FDT, initialization skipped!\n");
+	} else {
+		/* Go over UTMI phy node and get the base address & call UTMI phy */
+		for (i = 0 ; i < count ; i++) {
+			node = node_list[i];
+			if (node <= 0)
+				continue;
+			/* get base address of UTMI phy */
+			utmi_base_addr = fdt_get_regs_offs(gd->fdt_blob, node, "reg-utmi-unit");
+			if (utmi_base_addr == NULL) {
+				error("UTMI PHY base address is invalid\n");
+				continue;
+			}
+			/* get usb config address */
+			usb_cfg_addr = fdt_get_regs_offs(gd->fdt_blob, node, "reg-usb-cfg");
+			if (usb_cfg_addr == NULL) {
+				error("UTMI PHY base address is invalid\n");
+				continue;
+			}
+			/* get UTMI config address */
+			utmi_cfg_addr = fdt_get_regs_offs(gd->fdt_blob, node, "reg-utmi-cfg");
+			if (utmi_cfg_addr == NULL) {
+				error("UTMI PHY base address is invalid\n");
+				continue;
+			}
+			/* get the port number (to check if the utmi connected to host/device) */
+			utmi_phy_port = fdtdec_get_int(gd->fdt_blob, node, "utmi-port", UTMI_PHY_INVALID);
+			if (utmi_phy_port == UTMI_PHY_INVALID) {
+				error("UTMI PHY port type is invalid\n");
+				continue;
+			}
+			if (!comphy_utmi_phy_init(i, utmi_base_addr, usb_cfg_addr, utmi_cfg_addr, utmi_phy_port)) {
+				error("Failed to initialize UTMI PHY %d\n", i);
+				continue;
+			}
+			printf("UTMI PHY %d initizliazed to ", i);
+			if (utmi_phy_port == UTMI_PHY_TO_USB_DEVICE0)
+				printf("USB Device\n");
+			else
+				printf("USB Host%d\n", utmi_phy_port);
+		}
+	}
+
+	debug_exit();
+}
+
 static void comphy_mux_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy_map *serdes_map)
 {
 	void __iomem *comphy_base_addr;
@@ -507,6 +689,7 @@ int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy
 	comphy_base_addr = ptr_chip_cfg->comphy_base_addr;
 	hpipe_base_addr = ptr_chip_cfg->hpipe3_base_addr;
 
+	/* Config Comphy mux configuration */
 	comphy_mux_cp110_init(ptr_chip_cfg, serdes_map);
 
 	/* Check if the first 4 lanes configured as By-4 */
@@ -548,6 +731,9 @@ int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg, struct comphy
 			error("PLL is not locked - Failed to initialize lane %d\n", lane);
 	}
 
+	/* Initialize dedicated PHYs (not muxed SerDes lanes) */
+	comphy_dedicated_phys_init();
+
 	debug_exit();
 	return 0;
 }
diff --git a/include/dt-bindings/comphy/comphy_data.h b/include/dt-bindings/comphy/comphy_data.h
index ca62f41..64696cf 100644
--- a/include/dt-bindings/comphy/comphy_data.h
+++ b/include/dt-bindings/comphy/comphy_data.h
@@ -58,5 +58,10 @@
 #define PHY_TYPE_MAX			24
 #define PHY_TYPE_INVALID		0xff
 
+#define UTMI_PHY_TO_USB_HOST0		0
+#define UTMI_PHY_TO_USB_HOST1		1
+#define UTMI_PHY_TO_USB_DEVICE0		2
+#define UTMI_PHY_INVALID		0xff
+
 #endif /* _COMPHY_DATA_H_ */
 
diff --git a/include/fdtdec.h b/include/fdtdec.h
index b9f54b5..4b59fa8 100644
--- a/include/fdtdec.h
+++ b/include/fdtdec.h
@@ -157,6 +157,7 @@ enum fdt_compat_id {
 	COMPAT_MVEBU_A3700_FREQ,
 	COMPAT_MVEBU_MDIO,
 	COMPAT_MVEBU_PXA3XX_NAND,
+	COMPAT_MVEBU_UTMI_PHY,
 
 	COMPAT_COUNT,
 };
diff --git a/lib/fdtdec.c b/lib/fdtdec.c
index 4887219..cb5a5ec 100644
--- a/lib/fdtdec.c
+++ b/lib/fdtdec.c
@@ -118,7 +118,8 @@ static const char * const compat_names[COMPAT_COUNT] = {
 	COMPAT(MVEBU_XENON_MMC, "marvell,xenon-sdhci"),
 	COMPAT(COMPAT_MVEBU_A3700_FREQ, "marvell,a3700-freq"),
 	COMPAT(MVEBU_MDIO, "marvell,mvebu-mdio"),
-	COMPAT(MVEBU_PXA3XX_NAND, "marvell,mvebu-pxa3xx-nand")
+	COMPAT(MVEBU_PXA3XX_NAND, "marvell,mvebu-pxa3xx-nand"),
+	COMPAT(MVEBU_UTMI_PHY, "marvell,mvebu-utmi-2.6.0"),
 
 };
 
-- 
1.9.1

