From 60c18a57ebc5ab356ac89d3280bd95ca542e6eae Mon Sep 17 00:00:00 2001
From: Wilson Ding <dingwei@marvell.com>
Date: Tue, 16 Feb 2016 17:15:55 +0800
Subject: [PATCH 0861/1240] fix: a3700: rename the soc/board/config files and
 folders to Armada3700

- Use the official name "armada3700" instead of "armadalp".
- This change will effects on the build command:
  > make mvebu_armada3700_defconfig
  > make mvebu_armada3700_palladium_defconfig
  > make

Change-Id: I3ac7a4c8441651fb48e0ce355a21347bdd114b80
Signed-off-by: Wilson Ding <dingwei@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/27550
Reviewed-by: Kostya Porotchkin <kostap@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Tested-by: Hanna Hawa <hannah@marvell.com>
---
 arch/arm/cpu/armv8/Makefile                       |   2 +-
 arch/arm/cpu/armv8/armada3700/Kconfig             |  73 +++
 arch/arm/cpu/armv8/armada3700/Makefile            |  26 +
 arch/arm/cpu/armv8/armada3700/clock.c             |  54 ++
 arch/arm/cpu/armv8/armada3700/mvebu_clock.c       | 607 ++++++++++++++++++++++
 arch/arm/cpu/armv8/armada3700/mvebu_gpio.c        | 146 ++++++
 arch/arm/cpu/armv8/armada3700/mvebu_io_addr_dec.c | 177 +++++++
 arch/arm/cpu/armv8/armada3700/mvebu_misc_init.c   |  41 ++
 arch/arm/cpu/armv8/armada3700/psci.S              | 187 +++++++
 arch/arm/cpu/armv8/armada3700/soc-init.c          | 256 +++++++++
 arch/arm/cpu/armv8/armada3700/spl.c               | 115 ++++
 arch/arm/cpu/armv8/armadalp/Kconfig               |  73 ---
 arch/arm/cpu/armv8/armadalp/Makefile              |  26 -
 arch/arm/cpu/armv8/armadalp/clock.c               |  54 --
 arch/arm/cpu/armv8/armadalp/mvebu_clock.c         | 607 ----------------------
 arch/arm/cpu/armv8/armadalp/mvebu_gpio.c          | 146 ------
 arch/arm/cpu/armv8/armadalp/mvebu_io_addr_dec.c   | 177 -------
 arch/arm/cpu/armv8/armadalp/mvebu_misc_init.c     |  41 --
 arch/arm/cpu/armv8/armadalp/psci.S                | 187 -------
 arch/arm/cpu/armv8/armadalp/soc-init.c            | 256 ---------
 arch/arm/cpu/armv8/armadalp/spl.c                 | 115 ----
 arch/arm/cpu/mvebu-common/Kconfig                 |   2 +-
 arch/arm/include/asm/arch-armada3700/board-info.h |  52 ++
 arch/arm/include/asm/arch-armada3700/clock.h      | 580 +++++++++++++++++++++
 arch/arm/include/asm/arch-armada3700/gpio.h       |  45 ++
 arch/arm/include/asm/arch-armada3700/mbus_reg.h   |  49 ++
 arch/arm/include/asm/arch-armada3700/memory-map.h |  36 ++
 arch/arm/include/asm/arch-armada3700/misc-regs.h  |  35 ++
 arch/arm/include/asm/arch-armada3700/pcie-core.h  | 408 +++++++++++++++
 arch/arm/include/asm/arch-armada3700/regs-base.h  |  72 +++
 arch/arm/include/asm/arch-armada3700/soc-info.h   |  64 +++
 arch/arm/include/asm/arch-armadalp/board-info.h   |  52 --
 arch/arm/include/asm/arch-armadalp/clock.h        | 580 ---------------------
 arch/arm/include/asm/arch-armadalp/gpio.h         |  45 --
 arch/arm/include/asm/arch-armadalp/mbus_reg.h     |  49 --
 arch/arm/include/asm/arch-armadalp/memory-map.h   |  36 --
 arch/arm/include/asm/arch-armadalp/misc-regs.h    |  35 --
 arch/arm/include/asm/arch-armadalp/pcie-core.h    | 408 ---------------
 arch/arm/include/asm/arch-armadalp/regs-base.h    |  72 ---
 arch/arm/include/asm/arch-armadalp/soc-info.h     |  64 ---
 board/mvebu/armada3700/Makefile                   |  20 +
 board/mvebu/armada3700/armada3700.c               |  28 +
 board/mvebu/armada3700/devel-board.c              |  34 ++
 board/mvebu/armadalp/Makefile                     |  20 -
 board/mvebu/armadalp/armadalp.c                   |  28 -
 board/mvebu/armadalp/devel-board.c                |  34 --
 configs/mvebu_armada3700_defconfig                |  46 ++
 configs/mvebu_armada3700_palladium_defconfig      |  35 ++
 configs/mvebu_armadalp_defconfig                  |  46 --
 configs/mvebu_armadalp_palladium_defconfig        |  35 --
 doc/mvebu/build.txt                               |   2 +-
 include/configs/armada3700.h                      | 144 +++++
 include/configs/armadalp.h                        | 144 -----
 53 files changed, 3333 insertions(+), 3333 deletions(-)
 create mode 100644 arch/arm/cpu/armv8/armada3700/Kconfig
 create mode 100644 arch/arm/cpu/armv8/armada3700/Makefile
 create mode 100644 arch/arm/cpu/armv8/armada3700/clock.c
 create mode 100644 arch/arm/cpu/armv8/armada3700/mvebu_clock.c
 create mode 100644 arch/arm/cpu/armv8/armada3700/mvebu_gpio.c
 create mode 100644 arch/arm/cpu/armv8/armada3700/mvebu_io_addr_dec.c
 create mode 100644 arch/arm/cpu/armv8/armada3700/mvebu_misc_init.c
 create mode 100644 arch/arm/cpu/armv8/armada3700/psci.S
 create mode 100644 arch/arm/cpu/armv8/armada3700/soc-init.c
 create mode 100644 arch/arm/cpu/armv8/armada3700/spl.c
 delete mode 100644 arch/arm/cpu/armv8/armadalp/Kconfig
 delete mode 100644 arch/arm/cpu/armv8/armadalp/Makefile
 delete mode 100644 arch/arm/cpu/armv8/armadalp/clock.c
 delete mode 100644 arch/arm/cpu/armv8/armadalp/mvebu_clock.c
 delete mode 100644 arch/arm/cpu/armv8/armadalp/mvebu_gpio.c
 delete mode 100644 arch/arm/cpu/armv8/armadalp/mvebu_io_addr_dec.c
 delete mode 100644 arch/arm/cpu/armv8/armadalp/mvebu_misc_init.c
 delete mode 100644 arch/arm/cpu/armv8/armadalp/psci.S
 delete mode 100644 arch/arm/cpu/armv8/armadalp/soc-init.c
 delete mode 100644 arch/arm/cpu/armv8/armadalp/spl.c
 create mode 100644 arch/arm/include/asm/arch-armada3700/board-info.h
 create mode 100644 arch/arm/include/asm/arch-armada3700/clock.h
 create mode 100644 arch/arm/include/asm/arch-armada3700/gpio.h
 create mode 100644 arch/arm/include/asm/arch-armada3700/mbus_reg.h
 create mode 100644 arch/arm/include/asm/arch-armada3700/memory-map.h
 create mode 100644 arch/arm/include/asm/arch-armada3700/misc-regs.h
 create mode 100644 arch/arm/include/asm/arch-armada3700/pcie-core.h
 create mode 100644 arch/arm/include/asm/arch-armada3700/regs-base.h
 create mode 100644 arch/arm/include/asm/arch-armada3700/soc-info.h
 delete mode 100644 arch/arm/include/asm/arch-armadalp/board-info.h
 delete mode 100644 arch/arm/include/asm/arch-armadalp/clock.h
 delete mode 100644 arch/arm/include/asm/arch-armadalp/gpio.h
 delete mode 100644 arch/arm/include/asm/arch-armadalp/mbus_reg.h
 delete mode 100644 arch/arm/include/asm/arch-armadalp/memory-map.h
 delete mode 100644 arch/arm/include/asm/arch-armadalp/misc-regs.h
 delete mode 100644 arch/arm/include/asm/arch-armadalp/pcie-core.h
 delete mode 100644 arch/arm/include/asm/arch-armadalp/regs-base.h
 delete mode 100644 arch/arm/include/asm/arch-armadalp/soc-info.h
 create mode 100644 board/mvebu/armada3700/Makefile
 create mode 100644 board/mvebu/armada3700/armada3700.c
 create mode 100644 board/mvebu/armada3700/devel-board.c
 delete mode 100644 board/mvebu/armadalp/Makefile
 delete mode 100644 board/mvebu/armadalp/armadalp.c
 delete mode 100644 board/mvebu/armadalp/devel-board.c
 create mode 100644 configs/mvebu_armada3700_defconfig
 create mode 100644 configs/mvebu_armada3700_palladium_defconfig
 delete mode 100644 configs/mvebu_armadalp_defconfig
 delete mode 100644 configs/mvebu_armadalp_palladium_defconfig
 create mode 100644 include/configs/armada3700.h
 delete mode 100644 include/configs/armadalp.h

diff --git a/arch/arm/cpu/armv8/Makefile b/arch/arm/cpu/armv8/Makefile
index e356a8d..0f44e8d 100644
--- a/arch/arm/cpu/armv8/Makefile
+++ b/arch/arm/cpu/armv8/Makefile
@@ -19,4 +19,4 @@ obj-y	+= cpu-dt.o
 obj-$(CONFIG_ARMV8_PSCI)	+= psci.o
 obj-$(CONFIG_FSL_LSCH3) += fsl-lsch3/
 obj-$(if $(filter armada8k,$(SOC)),y) += armada8k/
-obj-$(if $(filter armadalp,$(SOC)),y) += armadalp/
+obj-$(if $(filter armada3700,$(SOC)),y) += armada3700/
diff --git a/arch/arm/cpu/armv8/armada3700/Kconfig b/arch/arm/cpu/armv8/armada3700/Kconfig
new file mode 100644
index 0000000..20a976d
--- /dev/null
+++ b/arch/arm/cpu/armv8/armada3700/Kconfig
@@ -0,0 +1,73 @@
+if TARGET_ARMADA_LP
+
+config SYS_CPU
+	string
+	default "armv8"
+
+config SYS_BOARD
+	string
+	default "armada3700"
+
+config SYS_VENDOR
+	string
+	default "mvebu"
+
+config SYS_SOC
+	string
+	default "armada3700"
+
+config SYS_CONFIG_NAME
+	string
+	default "armada3700"
+
+config ARMV8_PSCI
+	bool
+	default y
+
+config PALLADIUM
+	bool "Support palladium emulation"
+	default n
+	help
+	  Choose this option to enable
+	  Palladium support.
+	  There are certain differences
+	  between palladium and real SoC,
+	  like Clock and PHY, this should
+	  not be enabled for real SoC.
+
+config MVEBU_SPL_A3700_GPIO
+	bool "GPIO configuration for A3700 in SPL"
+	depends on TARGET_ARMADA_LP
+	default y
+	help
+	  Choose this option to enable GPIO
+	  configuration for A3700 in SPL.
+	  This will be removed later, and be
+	  implemented by MPP/PIN-CTRL driver.
+
+config MVEBU_A3700_IO_ADDR_DEC
+	bool "Armada-3700 Address decoding support"
+	depends on !MVEBU_SPL_DDR_OVER_PCI_SUPPORT
+	default n
+	help
+	  Choose this option to add support
+	  for Marvell Armada-3700 address decoding driver
+
+config MVEBU_A3700_MISC_INIT
+	bool "Armada-3700 miscellaneous initialization procedures support"
+	default n
+	help
+	  Choose this option to add support
+	  for Marvell Armada-3700 miscellaneous init procedures
+
+config MVEBU_A3700_CLOCK
+	bool "Armada-3700  clock support"
+	default n
+	help
+	  Choose this option to support
+	  Marvell Armada-3700 clock driver.
+	  For the first stage all clocks will be enabled
+	  by default.
+
+endif
+
diff --git a/arch/arm/cpu/armv8/armada3700/Makefile b/arch/arm/cpu/armv8/armada3700/Makefile
new file mode 100644
index 0000000..be2f6db
--- /dev/null
+++ b/arch/arm/cpu/armv8/armada3700/Makefile
@@ -0,0 +1,26 @@
+#
+# ***************************************************************************
+# Copyright (C) 2015 Marvell International Ltd.
+# ***************************************************************************
+# This program is free software: you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation, either version 2 of the License, or any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+# ***************************************************************************
+#
+
+obj-y += soc-init.o
+obj-$(CONFIG_SPL_BUILD) += spl.o
+obj-y += clock.o
+obj-$(CONFIG_ARMV8_PSCI)	+= psci.o
+obj-$(CONFIG_MVEBU_A3700_IO_ADDR_DEC) += mvebu_io_addr_dec.o
+obj-$(CONFIG_MVEBU_SPL_A3700_GPIO) += mvebu_gpio.o
+obj-$(CONFIG_MVEBU_A3700_MISC_INIT) += mvebu_misc_init.o
+obj-$(CONFIG_MVEBU_A3700_CLOCK) += mvebu_clock.o
diff --git a/arch/arm/cpu/armv8/armada3700/clock.c b/arch/arm/cpu/armv8/armada3700/clock.c
new file mode 100644
index 0000000..dace4f9
--- /dev/null
+++ b/arch/arm/cpu/armv8/armada3700/clock.c
@@ -0,0 +1,54 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+#include <common.h>
+#include <asm/arch-mvebu/clock.h>
+#include <asm/arch/clock.h>
+
+u32 soc_tclk_get(void)
+{
+	return 200000000;
+}
+
+u32 soc_cpu_clk_get(void)
+{
+	return get_cpu_clk() * 1000000;
+}
+
+u32 soc_ddr_clk_get(void)
+{
+	return get_ddr_clk() * 1000000;
+}
+
+u32 soc_l2_clk_get(void)
+{
+	return 800000000;
+}
+
+u32 soc_timer_clk_get(void)
+{
+	return 800000000;
+}
+
+void soc_print_clock_info(void)
+{
+	printf("       CPU    @ %d [MHz]\n", soc_cpu_clk_get() / 1000000);
+	printf("       L2     @ %d [MHz]\n", soc_l2_clk_get() / 1000000);
+	printf("       TClock @ %d [MHz]\n", soc_tclk_get() / 1000000);
+	printf("       DDR    @ %d [MHz]\n", soc_ddr_clk_get() / 1000000);
+}
diff --git a/arch/arm/cpu/armv8/armada3700/mvebu_clock.c b/arch/arm/cpu/armv8/armada3700/mvebu_clock.c
new file mode 100644
index 0000000..db0ca74
--- /dev/null
+++ b/arch/arm/cpu/armv8/armada3700/mvebu_clock.c
@@ -0,0 +1,607 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+/*#define DEBUG*/
+#include <common.h>
+#include <fdtdec.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/fdt.h>
+#include <asm/arch-mvebu/mvebu.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/soc-info.h>	/* XTAL and Boot mode */
+#include <asm/io.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+static struct a3700_clock_cfg a3700_clock_configs[] = MVEBU_A3700_CLOCK_CFGS;
+
+
+/***************************************************************************************************
+  * get_ref_clk
+  *
+  * return: reference clock in MHz (25 or 40)
+ ***************************************************************************************************/
+u32 get_ref_clk(void)
+{
+	u32 regval;
+
+	regval = (readl(MVEBU_TEST_PIN_LATCH_N) & MVEBU_XTAL_MODE_MASK) >> MVEBU_XTAL_MODE_OFFS;
+
+	if (regval == MVEBU_XTAL_CLOCK_25MHZ)
+		return 25;
+	else
+		return 40;
+}
+
+/******************************************************************************
+* Name: get_tbg_vco_sel
+*
+* Description:	calculate the vco parameters for TBG based on the target clock.
+*
+* Input:	kvco_mhz - KVCO clock freq in MHz
+*
+* Output:	vco_intpi - Phase Interpolator Bias Current
+*		vco_range - VCO frequency range (0x8 - 0xF)
+*
+* Return: 0 - OK
+******************************************************************************/
+static int get_tbg_vco_sel(u32 kvco_mhz,
+			   u32 *vco_intpi,
+			   u32 *vco_range)
+{
+	u8  index;
+	u16 vco_top_ranges_mhz[8] = {1350, 1500, 1750, 2000, 2200, 2400, 2600, 3000};
+
+	debug_enter();
+
+	if ((kvco_mhz <= MVEBU_KVCO_MIN) && (kvco_mhz >= MVEBU_KVCO_MAX)) {
+		error("Invalid KVCO CLK requested - %d MHz\n", kvco_mhz);
+		return 1;
+	}
+
+	/* Select the range the KVCO fits to.
+	   Valid values are 0x8 through 0xF.
+	   See TBG_A_KVCO and TBG_B_KVCO fields for details
+	 */
+	for (index = 0; index < 8; index++) {
+		if (kvco_mhz <= vco_top_ranges_mhz[index]) {
+			*vco_range = index + 8;
+			break;
+		}
+	}
+
+	/* INTPI - Phase Interpolator Bias Current
+	  8 <= KVCO is 2.5 ~ 3.0 GHz,
+	  6 <= KVCO is 2.0 ~ 2.5 GHz,
+	  5 <= KVCO is 1.5 ~ 2.0 GHz
+	 */
+	if (kvco_mhz > 2500)
+		*vco_intpi = 8;
+	else if (kvco_mhz < 2000)
+		*vco_intpi = 5;
+	else
+		*vco_intpi = 6;
+
+	debug_exit();
+	return 0;
+}
+
+/******************************************************************************
+* Name: set_tbg_clock
+*
+* Description:	Change the TBG(A/B) clock
+*		All affected North/South bridge clock sources should be
+*		switched to XTAL mode prior to calling this function!
+*
+* Input:	kvco_mhz:     AKVCO clock for TBG-X in MHz
+*		se_vco_div:   single-ended clock VCO divider (TBG_X_S)
+*		diff_vco_div: differential clock VCO post divider (TBG_X_P)
+*		tbg_typ:      TBG type (A/B)
+* Output:	None
+* Return:	0 if OK
+******************************************************************************/
+static u32 set_tbg_clock(u32 kvco_mhz,
+			       u32 se_vco_div,
+			       u32 diff_vco_div,
+			       enum a3700_clock_src tbg_typ)
+{
+	u32 vco_range = 0, vco_intpi = 0;
+	u32 tbg_M, tbg_N;
+	u32 icp;
+	u32 regval;
+	int ret;
+
+	debug_enter();
+
+	/* Try to keep Fref/M as close as possible to 10 MHz */
+	if (get_ref_clk() == 40) {
+		/* 40MHz */
+		debug("REF clock is 40MHz\n");
+		tbg_M = 4;	/* 10MHz */
+		icp = 5;	/* 8 */
+	} else	{
+		/* 25MHz */
+		debug("REF clock is 25MHz\n");
+		tbg_M = 3;	/* 8.33MHz */
+		icp = 6;	/* 9 */
+	}
+
+	ret = get_tbg_vco_sel(kvco_mhz, &vco_intpi, &vco_range);
+	if (ret != 0) {
+		error("Failed to obtain VCO divider selection\n");
+		return ret;
+	}
+
+	/* TBG frequency is calculated according to formula:
+		Ftbg = Fkvco / se_vco_div
+	   where
+		Fkvco = N * Fref * 4 / M
+
+	   N - TBG_A_FBDIV or TBG_B_FBDIV
+	   M - TBG_A_REFDIV or TBG_B_REFDIV
+	   se_vco_div - TBG_A_VCODIV_SEL_SE or TBG_B_VCODIV_SEL_SE
+	   Fref - reference clock 25MHz or 40 MHz
+	  */
+	tbg_N = (kvco_mhz * tbg_M / get_ref_clk()) >> 2;
+	debug("TBG-%s: SE vco_div %#x, DIFF vco_div %#x,vco_range %#x tbg_N %#x KVCO = %d MHz\n",
+	      tbg_typ == TBG_A ? "A" : "B", se_vco_div, diff_vco_div, vco_range, tbg_N, kvco_mhz);
+
+	/* 1. Switch all North/South Bridge clock sources to XTAL
+	      Should be already done by the function caller */
+
+	/* 2. Set TBG-A (bit[0]) or TBG-B (bit[16]) to reset state  */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
+	regval |= (tbg_typ == TBG_A) ? BIT0 : BIT16;
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
+
+	/* The A3700 FS requires to power down TGB before
+	   changing PLL parameters. However it turns out that
+	   this step is not essential. Putting TBG into reset
+	   state is enough.
+	   3. Power down TBG-A (bit[1]) or TBG-B (bit[17])
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
+	regval |= (tbg_typ == TBG_A) ? BIT1 : BIT17;
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
+	*/
+
+	/* 4. Set TBG-A (bit[10:2]) or TBG-B (bit[26:18]) FBDIV (N) value */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
+	regval &= (tbg_typ == TBG_A) ? ~(0xFFUL << 2) : ~(0xFFUL << 18);
+	regval |= (tbg_typ == TBG_A) ? (tbg_N << 2) : (tbg_N << 18);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
+
+	/* 5. Set TBG-A (bit[8:0]) or TBG-B (bit[24:16]) REFDIV (M) value */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL7);
+	regval &= (tbg_typ == TBG_A) ? ~(0x1FFUL << 0) : ~(0x1FFUL << 16);
+	regval |= (tbg_typ == TBG_A) ? (tbg_M << 0) : (tbg_M << 16);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL7);
+
+	/* 6a. Set TBG-A (bit[8:0]) or TBG-B (bit[24:16]) SE VCODIV value  */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
+	regval &= (tbg_typ == TBG_A) ? ~(0x1FFUL << 0) : ~(0x1FFUL << 16);
+	regval |= (tbg_typ == TBG_A) ? (se_vco_div << 0) : (se_vco_div << 16);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL1);
+
+	/* 6b. Set TBG-A (bit[9:1]) or TBG-B (bit[25:17]) DIFF VCODIV value  */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL8);
+	regval &= (tbg_typ == TBG_A) ? ~(0x1FFUL << 1) : ~(0x1FFUL << 17);
+	regval |= (tbg_typ == TBG_A) ? (diff_vco_div << 1) : (diff_vco_div << 17);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL8);
+
+	/* 7. Set TBG-A (bit[11]) or TBG-B (bit[27]) PLL Bandwidth to normal (0x0) */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
+	regval &= (tbg_typ == TBG_A) ? ~(0x1UL << 11) : ~(0x1UL << 27);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL1);
+
+	/* 8. Set TBG-A (bit[11:8]) or TBG-B (bit[27:24]) ICP Charge Pump Current value */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL2);
+	regval &= (tbg_typ == TBG_A) ? ~(0xFUL << 8) : ~(0xFUL << 24);
+	regval |= (tbg_typ == TBG_A) ? (icp << 8) : (icp << 24);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL2);
+
+	/* 9. Set TBG-A (bit[3:0]) or TBG-B (bit[19:16]) KVCO range value  */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL3);
+	regval &= (tbg_typ == TBG_A) ? ~(0xFUL << 0) : ~(0xFUL << 16);
+	regval |= (tbg_typ == TBG_A) ? (vco_range << 0) : (vco_range << 16);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL3);
+
+	/* 10. Set TBG-A (bit[3:0]) or TBG-B (bit[19:16]) INTPI value  */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL2);
+	regval &= (tbg_typ == TBG_A) ? ~(0xFUL << 0) : ~(0xFUL << 16);
+	regval |= (tbg_typ == TBG_A) ? (vco_intpi << 0) : (vco_intpi << 16);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL2);
+
+	/* The A3700 FS requires to power down TGB before
+	   changing PLL parameters. However it turns out that
+	   this step is not essential. Putting TBG into reset
+	   state is enough.
+	   11. Power up TBG-A (bit[1]) or TBG-B (bit[17])
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
+	regval &= (tbg_typ == TBG_A) ? ~(BIT1) : ~(BIT17);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
+	*/
+
+	/* 12. Release TBG-A (bit[0]) or TBG-B (bit[16]) from reset */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
+	regval &= (tbg_typ == TBG_A) ? ~(BIT0) : ~(BIT16);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
+
+	/* 13. Set TBG-A (bit[9]) or TBG-B (bit[25]) Bypass to disable - get CLKOUT from PLL */
+	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
+	regval &= (tbg_typ == TBG_A) ? ~(BIT9) : ~(BIT25);
+	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL1);
+
+	/* 14. Wait for TBG-A (bit[15] and TBG-B (bit[31]) PLL lock */
+	do {
+		regval = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
+		regval &= BIT15 | BIT31;
+	} while (regval != (BIT15 | BIT31));
+
+	/* 15. Switch all North/South Bridge clock sources to clock divider
+	       Will be done by function caller when required */
+
+	/* Wait for stable clock output, suggested 40us */
+	udelay(40);
+
+	debug_exit();
+	return 0;
+}
+
+#ifdef MVEBU_A3700_ENABLE_SSC
+/******************************************************************************
+* Name: set_ssc_mode
+*
+* Description: Setup Spread Spectrum Clcok for TBG-A/B
+*
+* Input:	None
+* Output:	None
+* Return:	Non-zero on error
+******************************************************************************/
+static u32 set_ssc_mode(void)
+{
+	debug_enter();
+	return 0;
+	debug_exit();
+}
+#endif /* MVEBU_A3700_ENABLE_SSC */
+
+/******************************************************************************
+* Name: set_clocks
+*
+* Description: Configure entire clock tree according to CPU and DDR frequency
+*
+* Input:	cpu_clk_mhz: required CPU clock
+*		ddr_clk_mhz: required DDR clock
+*		tbg_a_kvco_mhz: required TBG-A KVCO frequency or 0 for any available
+*		tbg_b_kvco_mhz: required TBG-B KVCO frequency or 0 for any available
+* Output:	None
+* Return:	Non-zero if the requested settings are not supported
+******************************************************************************/
+u32 set_clocks(u32 cpu_clk_mhz, u32 ddr_clk_mhz, u32 tbg_a_kvco_mhz, u32 tbg_b_kvco_mhz)
+{
+	u32 clock_cfgs_cnt = sizeof(a3700_clock_configs)/sizeof(a3700_clock_configs[0]);
+	u32 cfg;
+	struct a3700_clock_cfg *clk_cfg = 0;
+	u32 rval, reg_val;
+
+	debug_enter();
+
+	/* Search for the supported clock tree configuration */
+	for (cfg = 0; cfg < clock_cfgs_cnt; cfg++) {
+		if ((a3700_clock_configs[cfg].cpu_freq_mhz == cpu_clk_mhz) &&
+		    (a3700_clock_configs[cfg].ddr_freq_mhz == ddr_clk_mhz) &&
+		    ((tbg_a_kvco_mhz == 0) || (a3700_clock_configs[cfg].tbg_a.kvco_mhz == tbg_a_kvco_mhz)) &&
+		    ((tbg_b_kvco_mhz == 0) || (a3700_clock_configs[cfg].tbg_b.kvco_mhz == tbg_b_kvco_mhz))) {
+			clk_cfg = &a3700_clock_configs[cfg];
+			debug("Found valid FREQ preset(#%d): CPU=%dMHz, DDR=%dMHz\n", cfg,
+			      a3700_clock_configs[cfg].cpu_freq_mhz, a3700_clock_configs[cfg].ddr_freq_mhz);
+			break;
+		}
+	}
+
+	if (clk_cfg == 0) {
+		error("Unable to find valid FREQ preset for CPU=%dMHz, DDR=%dMHz, TBG-A=%dMHz, TBG-B=%dMHz\n",
+		      cpu_clk_mhz, ddr_clk_mhz, tbg_a_kvco_mhz, tbg_b_kvco_mhz);
+		return 1;
+	}
+
+	/* Switch all North/South Bridge clock sources to XTAL
+	   prior to make any change to the clock configuration */
+	writel(0x00000000, MVEBU_NORTH_CLOCK_SELECT_REG);
+	writel(0x00000000, MVEBU_SOUTH_CLOCK_SELECT_REG);
+
+	rval = set_tbg_clock(clk_cfg->tbg_a.kvco_mhz,
+			     clk_cfg->tbg_a.se_vcodiv,
+			     clk_cfg->tbg_a.diff_vcodiv,
+			     TBG_A);
+	if (rval) {
+		error("Failed to set TBG-A clock to %dMHz\n", clk_cfg->tbg_a.kvco_mhz);
+		return rval;
+	}
+
+	rval = set_tbg_clock(clk_cfg->tbg_b.kvco_mhz,
+			     clk_cfg->tbg_b.se_vcodiv,
+			     clk_cfg->tbg_b.diff_vcodiv,
+			     TBG_B);
+	if (rval) {
+		error("Failed to set TBG-B clock to %dMHz\n", clk_cfg->tbg_b.kvco_mhz);
+		return rval;
+	}
+
+	/* North Bridge clock tree configuration */
+	/* Enable all clocks */
+	writel(NB_ALL_CLK_ENABLE, MVEBU_NORTH_CLOCK_ENABLE_REG);
+
+	/* Setup dividers */
+	reg_val = readl(MVEBU_NORTH_CLOCK_DIVIDER_SELECT0_REG);
+	reg_val &= NB_CLK_DIV0_MASK_ALL;
+	reg_val |= clk_cfg->nb_clk_cfg.div0.pwm_clk_prscl2 & 0x7;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.pwm_clk_prscl1 & 0x7) << 3;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.ddr_fclk_clk_prscl2 & 0x7) << 12;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.ddr_fclk_clk_prscl1 & 0x7) << 15;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.ddr_phy_mck_div_sel & 0x1) << 18;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.trace_div_sel & 0x7) << 20;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.counter_clk_prscl & 0x7) << 23;
+	reg_val |= (clk_cfg->nb_clk_cfg.div0.a53_cpu_clk_prscl & 0x7) << 28;
+	writel(reg_val, MVEBU_NORTH_CLOCK_DIVIDER_SELECT0_REG);
+
+	reg_val = readl(MVEBU_NORTH_CLOCK_DIVIDER_SELECT1_REG);
+	reg_val &= NB_CLK_DIV1_MASK_ALL;
+	reg_val |= clk_cfg->nb_clk_cfg.div1.sec_at_clk_prscl2 & 0x7;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.sec_at_clk_prscl1 & 0x7) << 3;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.sec_dap_clk_prscl2 & 0x7) << 6;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.sec_dap_clk_prscl1 & 0x7) << 9;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.tsecm_clk_prscl2 & 0x7) << 12;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.tsecm_clk_prscl1 & 0x7) << 15;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.setm_tmx_clk_prscl & 0x7) << 18;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.sqf_clk_prscl2 & 0x7) << 24;
+	reg_val |= (clk_cfg->nb_clk_cfg.div1.sqf_clk_prscl1 & 0x7) << 27;
+	writel(reg_val, MVEBU_NORTH_CLOCK_DIVIDER_SELECT1_REG);
+
+	reg_val = readl(MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG);
+	reg_val &= NB_CLK_DIV2_MASK_ALL;
+	reg_val |= clk_cfg->nb_clk_cfg.div2.wc_ahb_div_sel & 0x7;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.sata_h_clk_prscl2 & 0x7) << 7;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.sata_h_clk_prscl1 & 0x7) << 10;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.mmc_clk_prscl2 & 0x7) << 13;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.mmc_clk_prscl1 & 0x7) << 16;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.eip97_clk_prscl2 & 0x7) << 19;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.eip97_clk_prscl1 & 0x7) << 22;
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.atb_clk_div_sel & 0x3) << 25;
+	/* Always use "divide by 1 (0)" for counter clock and ignore table value
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.cpu_cnt_clk_div_sel & 0x3) << 27;
+	*/
+	reg_val |= (clk_cfg->nb_clk_cfg.div2.plkdbg_clk_div_sel & 0x3) << 29;
+	writel(reg_val, MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG);
+
+	/* Setup connection to clock lines */
+	reg_val = readl(MVEBU_NORTH_CLOCK_TBG_SELECT_REG);
+	reg_val &= NB_CLK_TBG_SEL_MASK_ALL;
+	reg_val |= clk_cfg->nb_clk_cfg.clock_sel.mmc_pclk_sel & 0x3;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.sata_host_pclk_sel & 0x3) << 2;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.sec_at_pclk_sel & 0x3) << 4;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.sec_dap_pclk_sel & 0x3) << 6;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.tsecm_pclk_sel & 0x3) << 8;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.setm_tmx_pclk_sel & 0x3) << 10;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.sqf_pclk_sel & 0x3) << 12;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.pwm_pclk_sel & 0x3) << 14;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.ddr_fclk_pclk_sel & 0x3) << 16;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.trace_pclk_sel & 0x3) << 18;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.counter_pclk_sel & 0x3) << 20;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.a53_cpu_pclk_sel & 0x3) << 22;
+	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.eip97_pclk_sel & 0x3) << 24;
+	writel(reg_val, MVEBU_NORTH_CLOCK_TBG_SELECT_REG);
+
+	/* South Bridge clock tree configuration */
+	/* Enable all clocks */
+	writel(SB_ALL_CLK_ENABLE, MVEBU_SOUTH_CLOCK_ENABLE_REG);
+
+	/* Setup dividers */
+	reg_val = readl(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT0_REG);
+	reg_val &= SB_CLK_DIV0_MASK_ALL;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.sdio_clk_prscl2 & 0x7) << 3;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.sdio_clk_prscl1 & 0x7) << 6;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.usb32_usb2_sys_clk_prscl2 & 0x7) << 9;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.usb32_usb2_sys_clk_prscl1 & 0x7) << 12;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.usb32_ss_sys_clk_prscl2 & 0x7) << 15;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.usb32_ss_sys_clk_prscl1 & 0x7) << 18;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.sb_axi_clk_prscl2 & 0x7) << 21;
+	reg_val |= (clk_cfg->sb_clk_cfg.div0.sb_axi_clk_prscl1 & 0x7) << 24;
+	writel(reg_val, MVEBU_SOUTH_CLOCK_DIVIDER_SELECT0_REG);
+
+	reg_val = readl(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG);
+	reg_val &= SB_CLK_DIV1_MASK_ALL;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_125_clk_prscl2 & 0x7) << 6;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_125_clk_prscl1 & 0x7) << 9;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_bm_core_clk_div2_sel & 0x1) << 12;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe1_core_clk_div2_sel & 0x1) << 13;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe0_core_clk_div2_sel & 0x1) << 14;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_core_clk_prscl2 & 0x7) << 18;
+	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_core_clk_prscl1 & 0x7) << 21;
+	writel(reg_val, MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG);
+
+	reg_val = readl(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT2_REG);
+	reg_val &= SB_CLK_DIV2_MASK_ALL;
+	reg_val |= (clk_cfg->sb_clk_cfg.div2.gbe_50_clk_prscl2 & 0x7) << 6;
+	reg_val |= (clk_cfg->sb_clk_cfg.div2.gbe_50_clk_prscl1 & 0x7) << 9;
+	writel(reg_val, MVEBU_SOUTH_CLOCK_DIVIDER_SELECT2_REG);
+
+	/* Setup connection to clock lines */
+	reg_val = readl(MVEBU_SOUTH_CLOCK_TBG_SELECT_REG);
+	reg_val &= SB_CLK_TBG_SEL_MASK_ALL;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.gbe_50_pclk_sel & 0x3) << 6;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.gbe_core_pclk_sel & 0x3) << 8;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.gbe_125_pclk_sel & 0x3) << 10;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.sdio_pclk_sel & 0x3) << 14;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.usb32_usb2_sys_pclk_sel & 0x3) << 16;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.usb32_ss_sys_pclk_sel & 0x3) << 18;
+	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.sb_axi_pclk_sel & 0x3) << 20;
+	writel(reg_val, MVEBU_SOUTH_CLOCK_TBG_SELECT_REG);
+
+
+#ifdef MVEBU_A3700_ENABLE_SSC
+	set_ssc_mode();
+#else
+	/* Disable SSC for TBG-A (bit[10]) and TBG-B (bit[26]) */
+	reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL3);
+	reg_val &= ~(BIT10 | BIT26);
+	writel(reg_val, MVEBU_NORTH_BRG_TBG_CTRL3);
+#endif /* MVEBU_A3700_ENABLE_SSC */
+
+	/* Switch all North/South Bridge clock sources from XTAL to clock divider
+	   excepting counter clock, which remains to be connected to XTAL */
+	writel(0x00009FFF, MVEBU_NORTH_CLOCK_SELECT_REG);
+	writel(0x000007AA, MVEBU_SOUTH_CLOCK_SELECT_REG);
+
+	debug_exit();
+	return rval;
+}
+
+int init_clock(void)
+{
+	int node, count, idx, ret;
+	const void *blob = gd->fdt_blob;
+	int tbl_sz = sizeof(a3700_clock_configs)/sizeof(a3700_clock_configs[0]);
+	u32 vdd_val;
+
+	debug_enter();
+
+	count = fdtdec_find_aliases_for_id(blob, "freq", COMPAT_MVEBU_A3700_FREQ, &node, 1);
+	if (count == 0) {
+		error("The frequency preset is not defined in DT, using default\n");
+		idx = MVEBU_A3700_DEF_CLOCK_PRESET_IDX;
+	} else {
+		idx = fdtdec_get_int(blob, node, "preset", MVEBU_A3700_DEF_CLOCK_PRESET_IDX);
+		if ((idx >= tbl_sz) || (idx < 0)) {
+			error("Unsupported frequency preset in DT (%d), using default\n", idx);
+			idx = MVEBU_A3700_DEF_CLOCK_PRESET_IDX;
+		}
+	}
+
+	printf("Setting clocks to CPU=%dMHz and DDR=%dMHz\n",
+		a3700_clock_configs[idx].cpu_freq_mhz, a3700_clock_configs[idx].ddr_freq_mhz);
+
+	ret =  set_clocks(a3700_clock_configs[idx].cpu_freq_mhz,
+			  a3700_clock_configs[idx].ddr_freq_mhz,
+			  a3700_clock_configs[idx].tbg_a.kvco_mhz,
+			  a3700_clock_configs[idx].tbg_b.kvco_mhz);
+	if (ret)
+		error("Failed to configure system clocks\n");
+
+	/* Enable AVS for high CPU clocks */
+	if (a3700_clock_configs[idx].cpu_freq_mhz >= 800)
+		vdd_val = AVS_VDD_VAL(AVS_VDD_800_MHZ_MV);
+	else if (a3700_clock_configs[idx].cpu_freq_mhz == 600)
+		vdd_val = AVS_VDD_VAL(AVS_VDD_600_MHZ_MV);
+	else
+		vdd_val = 0;
+
+	if (vdd_val != 0) {
+		u32 avs_reg = AVS_SOFT_RESET | AVS_SPEED_TARGET_MASK | AVS_SEL_VSENCE0 |
+				(vdd_val << AVS_LOW_VDD_LIMIT_OFFS) |
+				(vdd_val << AVS_HIGH_VDD_LIMIT_OFFS);
+
+		writel(avs_reg, MVEBU_AVS_CTRL_0);
+		avs_reg &= ~AVS_SOFT_RESET;
+		writel(avs_reg, MVEBU_AVS_CTRL_0);
+		avs_reg |= AVS_ENABLE;
+		writel(avs_reg, MVEBU_AVS_CTRL_0);
+		printf("AVS enabled (%d mV)\n",
+			a3700_clock_configs[idx].cpu_freq_mhz == 600 ?
+			AVS_VDD_600_MHZ_MV : AVS_VDD_800_MHZ_MV);
+	}
+
+	debug_exit();
+	return ret;
+}
+
+static u32 get_tbg_clk(enum a3700_clock_line tbg_typ)
+{
+	u32 tbg_M, tbg_N, vco_div;
+	u32 ref, reg_val;
+
+	/* get ref clock */
+	ref = get_ref_clk();
+
+	/* get M, N */
+	reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL7);
+	tbg_M = ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_A_P)) ?
+		(reg_val & 0x1FFUL) : ((reg_val >> 16) & 0x1FFUL);
+	tbg_M = (tbg_M == 0) ? 1 : tbg_M;
+
+	reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
+	tbg_N = ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_A_P)) ?
+		((reg_val >> 2) & 0x1FFUL) : ((reg_val >> 18) & 0x1FFUL);
+
+	if ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_B_S)) {
+		/* get SE VCODIV */
+		reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
+		reg_val = (tbg_typ == TBG_A_S) ?
+			  (reg_val & 0x1FFUL) : ((reg_val >> 16) & 0x1FFUL);
+	} else {
+		/* get DIFF VCODIV */
+		reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL8);
+		reg_val = (tbg_typ == TBG_A_P) ?
+			  ((reg_val >> 1) & 0x1FFUL) : ((reg_val >> 17) & 0x1FFUL);
+	}
+	if (reg_val > 7)
+		return 0; /*invalid*/
+
+	vco_div = 0x1 << reg_val;
+
+	return ((tbg_N * ref) << 2)/(tbg_M * vco_div);
+}
+
+u32 get_cpu_clk(void)
+{
+	u32 tbg, cpu_prscl;
+	enum a3700_clock_line tbg_typ;
+
+	/* 1. check cpu clock select */
+	if (!((readl(MVEBU_NORTH_CLOCK_SELECT_REG) >> 15) & 0x1))
+		return 0; /* CPU clock is using XTAL output*/
+
+	/* 2. get TBG select */
+	tbg_typ = (readl(MVEBU_NORTH_CLOCK_TBG_SELECT_REG) >> 22) & 0x3;
+
+	/* 3. get TBG clock */
+	tbg = get_tbg_clk(tbg_typ);
+	if (tbg == 0)
+		return 0;
+
+	/* 4. get CPU clk divider */
+	cpu_prscl = (readl(MVEBU_NORTH_CLOCK_DIVIDER_SELECT0_REG) >> 28) & 0x7;
+	if (cpu_prscl == 7)
+		return 0; /* divider value error */
+
+	return tbg/cpu_prscl;
+}
+
+u32 get_ddr_clk(void)
+{
+	u32 tbg;
+
+	/* 1. check DDR clock select */
+	if (!((readl(MVEBU_NORTH_CLOCK_SELECT_REG) >> 10) & 0x1))
+		return 0; /* DDR clock is using XTAL output*/
+
+	/* 2. get TBG_A clock */
+	tbg = get_tbg_clk(TBG_A_S);
+	if (tbg == 0)
+		return 0;
+
+	return tbg>>1;
+}
diff --git a/arch/arm/cpu/armv8/armada3700/mvebu_gpio.c b/arch/arm/cpu/armv8/armada3700/mvebu_gpio.c
new file mode 100644
index 0000000..4811cc0
--- /dev/null
+++ b/arch/arm/cpu/armv8/armada3700/mvebu_gpio.c
@@ -0,0 +1,146 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/gpio.h>
+
+/*
+ * reset PCIe device
+ */
+void mvebu_reset_pcie_dev(void)
+{
+	u32 reg_val;
+
+	/* Set PCIe reset to 0 */
+	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_VAL_REG);
+	reg_val &= ~(1 << MVEBU_GPIO_PCIE_RESET_OFF);
+	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_VAL_REG);
+
+	/* Set to GPIO output mode */
+	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_EN_REG);
+	reg_val |= (1 << MVEBU_GPIO_PCIE_RESET_OFF);
+	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_EN_REG);
+
+	/* Set PCIe to GPIO mode */
+	reg_val = readl(MVEBU_GPIO_SB_SEL_REG);
+	reg_val |= (1 << MVEBU_GPIO_PCIE_EN_OFF);
+	writel(reg_val, MVEBU_GPIO_SB_SEL_REG);
+
+	/* typical delay for NIC to finish reset from NIC specification */
+	udelay(100);
+
+	/* Release PCIe reset */
+	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_VAL_REG);
+	reg_val |= (1 << MVEBU_GPIO_PCIE_RESET_OFF);
+	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_VAL_REG);
+}
+
+/*
+ * initialize SB SDIO device
+ */
+void mvebu_init_sdio(void)
+{
+	u32 reg_val;
+
+	/* Set SDIO to 0 which is 3.3v */
+	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_VAL_REG);
+	reg_val &= ~(1 << MVEBU_GPIO_SDIO_VOLTAGE_OFF);
+	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_VAL_REG);
+
+	/* Set to GPIO output mode */
+	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_EN_REG);
+	reg_val |= (1 << MVEBU_GPIO_SDIO_VOLTAGE_OFF);
+	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_EN_REG);
+
+	/* Set test pin to SDIO mode */
+	reg_val = readl(MVEBU_GPIO_SB_SEL_REG);
+	reg_val &= ~(1 << MVEBU_GPIO_SB_SDIO_EN_OFF);
+	writel(reg_val, MVEBU_GPIO_SB_SEL_REG);
+}
+
+/*
+ * set SB SDIO device
+ */
+void mvebu_set_sdio(int voltage)
+{
+	u32 reg_val;
+
+	/* Set SDIO to 0 which is 3.3v */
+	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_VAL_REG);
+	if (MVEBU_GPIO_SDIO_VOLTAGE_1_8V == voltage)
+		reg_val |= (1 << MVEBU_GPIO_SDIO_VOLTAGE_OFF);
+	else
+		reg_val &= ~(1 << MVEBU_GPIO_SDIO_VOLTAGE_OFF);
+	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_VAL_REG);
+}
+
+/*
+ * mvebu_init_gpio
+ *
+ * This function sets GPIO configuration for Armada3700
+ * by hardcoded value.
+ * And this routine (patch) will be removed (revert),
+ * and implemented by MPP/PIN-CTRL driver later.
+ *
+ */
+void mvebu_init_gpio(void)
+{
+	u32 reg_val;
+
+	/*
+	 * NETA GPIO
+	 * on Palladium, RGMII is used
+	 */
+	reg_val = readl(MVEBU_GPIO_SB_SEL_REG);
+	reg_val = reg_val & (~(1 << MVEBU_GPIO_RGMII_GPIO_EN_OFF));
+	writel(reg_val, MVEBU_GPIO_SB_SEL_REG);
+
+	/*
+	 * I2C, SPI GPIO
+	 */
+	reg_val = readl(MVEBU_GPIO_NB_SEL_REG);
+	/* enable GPIO for I2C */
+	reg_val = reg_val & (~(1 << MVEBU_GPIO_TW1_GPIO_EN_OFF));
+	/* enable GPIO for SPI
+	 * In A3700 Register Spec, it says that In North bridge GPIO configuration,
+	 * bit 18 is for SPI quad mode, but this is not accurate description.
+	 * In fact, bit 18 controls HOLD and WP pins for SPI, which is needed for all
+	 * SPI mode, single, dual, and quad.
+	 */
+	reg_val = reg_val & (~(1 << MVEBU_GPIO_SPI_GPIO_EN_OFF));
+	writel(reg_val, MVEBU_GPIO_NB_SEL_REG);
+
+	/* set hiden GPIO setting for SPI
+	 * in north_bridge_test_pin_out_en register 13804,
+	 * bit 28 is the one which enables CS, CLK pin to be
+	 * output, need to set it to 1.
+	 * normally, it is needed only in UART boot mode,
+	 * but after trying all other modes, it is OK to set it.
+	 * later, we could read the SAR register, and do not
+	 * set it in other boot mode.
+	 */
+	reg_val = readl(MVEBU_GPIO_NB_OUTPUT_EN_HIGH_REG);
+	reg_val = reg_val | (1 << MVEBU_GPIO_NB_OUTPUT_SPI_EN_OFF);
+	writel(reg_val, MVEBU_GPIO_NB_OUTPUT_EN_HIGH_REG);
+
+	/* set SB SDIO to 3.3v by default */
+	mvebu_init_sdio();
+
+	return;
+}
diff --git a/arch/arm/cpu/armv8/armada3700/mvebu_io_addr_dec.c b/arch/arm/cpu/armv8/armada3700/mvebu_io_addr_dec.c
new file mode 100644
index 0000000..ce2b38e
--- /dev/null
+++ b/arch/arm/cpu/armv8/armada3700/mvebu_io_addr_dec.c
@@ -0,0 +1,177 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <asm/arch-mvebu/mvebu.h>
+#include <asm/arch-mvebu/mbus.h>
+#include <asm/io.h>
+#include <fdtdec.h>
+#include <asm/arch-mvebu/fdt.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct dec_win_config {
+	void __iomem *dec_win_base;
+	u32 max_win;
+	u32 max_remap;
+	u32 remap_size;
+	u32 win_offset;
+};
+
+struct io_dec_fdt_info {
+	u32 base;
+	u32 size;
+	u32 flags;
+};
+
+/* There are up to 14 IO unit which need address deocode in Armada-3700 */
+#define IO_UNIT_NUM_MAX		(14)
+struct io_dec_fdt_info __attribute__((section(".data")))io_dec_fdt_arr[IO_UNIT_NUM_MAX];
+
+#define MVEBU_DEC_WIN_CTRL_REG(base, win, off)	(MVEBU_REGS_BASE + base + (win * off))
+#define MVEBU_DEC_WIN_BASE_REG(base, win, off)	(MVEBU_REGS_BASE + base + (win * off) + 0x4)
+#define MVEBU_DEC_WIN_REMAP_REG(base, win, off)	(MVEBU_REGS_BASE + base + (win * off) + 0x8)
+
+#define MVEBU_DEC_WIN_CTRL_SIZE_OFF	(16)
+#define MVEBU_DEC_WIN_CTRL_ATTR_OFF	(8)
+#define MVEBU_DEC_WIN_CTRL_TARGET_OFF	(4)
+#define MVEBU_DEC_WIN_CTRL_EN_OFF	(0)
+#define MVEBU_DEC_WIN_BASE_OFF		(16)
+
+/* set io decode window */
+int set_io_addr_dec(struct mbus_win_map *win_map, struct dec_win_config *dec_win)
+{
+	struct mbus_win *win;
+	int id;
+	u32 ctrl = 0;
+	u32 base = 0;
+
+	/* disable all windows first */
+	for (id = 0; id < dec_win->max_win; id++)
+		writel(0, MVEBU_DEC_WIN_CTRL_REG(dec_win->dec_win_base, id, dec_win->win_offset));
+
+	/* configure eMMC decode windows for DRAM, according to CPU-DRAM
+	 * decode window configurations
+	 */
+	for (id = 0, win = &win_map->mbus_windows[id]; id < win_map->mbus_win_num; id++, win++) {
+		/* set size */
+		ctrl = win->win_size << MVEBU_DEC_WIN_CTRL_SIZE_OFF;
+		/* set attr */
+		ctrl |= win->attribute << MVEBU_DEC_WIN_CTRL_ATTR_OFF;
+		/* set target */
+		ctrl |= win->target << MVEBU_DEC_WIN_CTRL_TARGET_OFF;
+		/* set base */
+		base = win->base_addr << MVEBU_DEC_WIN_BASE_OFF;
+
+		/* set base address*/
+		writel(base, MVEBU_DEC_WIN_BASE_REG(dec_win->dec_win_base, id, dec_win->win_offset));
+		/* set remap window, some unit does not have remap window */
+		if (id < dec_win->max_remap)
+			writel(base, MVEBU_DEC_WIN_REMAP_REG(dec_win->dec_win_base, id, dec_win->win_offset));
+		/* set control register */
+		writel(ctrl, MVEBU_DEC_WIN_CTRL_REG(dec_win->dec_win_base, id, dec_win->win_offset));
+		/* enable the address decode window at last to make it effective */
+		ctrl |= win->enabled << MVEBU_DEC_WIN_CTRL_EN_OFF;
+		writel(ctrl, MVEBU_DEC_WIN_CTRL_REG(dec_win->dec_win_base, id, dec_win->win_offset));
+
+		debug("set_io_addr_dec %d result: ctrl(0x%x) base(0x%x)",
+		      id, readl(MVEBU_DEC_WIN_CTRL_REG(dec_win->dec_win_base, id, dec_win->win_offset)),
+		      readl(MVEBU_DEC_WIN_BASE_REG(dec_win->dec_win_base, id, dec_win->win_offset)));
+		if (id < dec_win->max_remap)
+			debug(" remap(%x)\n",
+			      readl(MVEBU_DEC_WIN_REMAP_REG(dec_win->dec_win_base, id, dec_win->win_offset)));
+		else
+			debug("\n");
+	}
+	return 0;
+}
+
+int init_io_addr_dec(void)
+{
+	int ret = 0;
+	u32 node;
+	u32 count;
+	int index;
+	struct mbus_win_map win_map;
+	struct dec_win_config dec_win;
+	const void *blob = gd->fdt_blob;
+	struct io_dec_fdt_info *fdt_info = io_dec_fdt_arr;
+
+	debug("Initializing MBUS IO address decode windows\n");
+	debug_enter();
+
+	/* fetch CPU-DRAM window mapping information by reading
+	 * CPU-DRAM decode windows (only the enabled ones)
+	 */
+	mbus_win_map_build(&win_map);
+	for (index = 0; index < win_map.mbus_win_num; index++)
+		debug("MBUS DRAM mapping %d base(0x%llx) size(0x%llx) target(%d) attr(%d)\n",
+		      index, (u64)win_map.mbus_windows[index].base_addr, (u64)win_map.mbus_windows[index].win_size,
+		      win_map.mbus_windows[index].target, win_map.mbus_windows[index].attribute);
+
+	/* Get I/O address decoding node from the FDT blob */
+	node = fdt_node_offset_by_compatible(blob, -1, fdtdec_get_compatible(COMPAT_MVEBU_MBUS_IO_DEC));
+	if (node < 0) {
+		error("No I/O address decoding node found in FDT blob\n");
+		return -1;
+	}
+
+	/* Get the array of the windows and fill the map data */
+	count = fdtdec_get_int_array_count(blob, node, "unit_io_decode_info", (u32 *)fdt_info, IO_UNIT_NUM_MAX * 3);
+	if (count <= 0) {
+		debug("no windows configurations found\n");
+		return 0;
+	}
+
+	/* each window has 3 variables in FDT (base, size, flags)
+	 * base: base address of IO decode window
+	 * size: size of IO decode window register in unit of byte
+	 * flags: information about this IO decode window which is combined by IO_ATTR
+	 *     IO_ATTR(max_win, max_remap, remap_size, win_offset) (((max_win) << 24) | ((max_remap) << 16) |
+	 *            ((remap_size) << 8) | (win_offset))
+	 *            max_win: how many decode window that this unit has
+	 *            max_remap: the decode window number including remapping that this unit has
+	 *            remap_size: remap window size in unit of bits, normally should be 32 or 64
+	 *            win_offset: the offset between continuous decode windows with the same unit, typically 0x10
+	 *
+	 * Example in FDT: <0xcb00 0x30 IO_ATTR(3, 0, 32, 0x10)>
+	 */
+	count = count / 3;
+	for (index = 0; index < count; index++, fdt_info++) {
+		dec_win.dec_win_base = (void *)((u64)fdt_info->base);
+		dec_win.max_win = (fdt_info->flags >> 24) & 0xFF;
+		dec_win.max_remap = (fdt_info->flags >> 16) & 0xFF;
+		dec_win.remap_size = (fdt_info->flags >> 8) & 0xFF;
+		dec_win.win_offset = fdt_info->flags & 0xFF;
+
+		/* set I/O address decode window */
+		ret = set_io_addr_dec(&win_map, &dec_win);
+		if (ret) {
+			error("failed to set io address decode\n");
+			break;
+		}
+		debug("set io decode window successfully, base(0x%x) size(0x%x)",
+		      fdt_info->base, fdt_info->size);
+		debug(" max_win(%d) max_remap(%d) remap_size(%d) win_offset(%d)\n",
+		      dec_win.max_win, dec_win.max_remap, dec_win.remap_size, dec_win.win_offset);
+	}
+
+	debug_exit();
+	return ret;
+}
diff --git a/arch/arm/cpu/armv8/armada3700/mvebu_misc_init.c b/arch/arm/cpu/armv8/armada3700/mvebu_misc_init.c
new file mode 100644
index 0000000..64cd517
--- /dev/null
+++ b/arch/arm/cpu/armv8/armada3700/mvebu_misc_init.c
@@ -0,0 +1,41 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/mvebu.h>
+
+void misc_init_cci400(void)
+{
+	debug_enter();
+
+	/*
+	   CCI-400 enable snoop and dvm on S3 port.
+	   For details see the <CoreLink CCI-400 Cache Coherent Interconnect> document.
+	   bit[0] - Enable issuing of snoop requests from this slave interface.
+	   bit[1] - Enable issuing of DVM message requests from this slave interface
+	   bit[29:2] - Reserved
+	   bit[30] - Slave interface supports snoops
+	   bit[31] - Slave interface supports DVM messages
+	 */
+	writel(0xC0000003, MVEBU_CCI_S3_SNOOP_CTRL_REG);
+
+	/* Add units configuration code here */
+
+	debug_exit();
+}
diff --git a/arch/arm/cpu/armv8/armada3700/psci.S b/arch/arm/cpu/armv8/armada3700/psci.S
new file mode 100644
index 0000000..4c59cfa
--- /dev/null
+++ b/arch/arm/cpu/armv8/armada3700/psci.S
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2013 - ARM Ltd
+ * Author: Marc Zyngier <marc.zyngier@arm.com>
+ *
+ * Based on code by Carl van Schaik <carl@ok-labs.com>.
+ *
+ * Copyright (C) 2015 Marvell International Ltd.
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+*/
+
+#include <config.h>
+#include <linux/linkage.h>
+#include <asm/psci.h>
+#include <asm/gic.h>
+#include <asm/macro.h>
+
+#define MVEBU_CPU_1_RESET_VECTOR 0x14044
+#define MVEBU_CPU_1_RESET_REG 0xD00C
+#define MVEBU_CPU_1_RESET_BIT 31
+#define MVEBU_NB_REGS_BASE 0x13000
+#define MVEBU_WARM_RESET_REG 0x840
+#define MVEBU_WARM_RESET_MAGIC 0x1D1E
+
+/*
+  * Now there is only very limited support for PSCI feature.
+  * We only support wake up CPU1 from CPU0 to test SMP
+  * feature in Kernel.
+  *
+  * TODO: Add the rest of PSCI feature which includes
+  * will be added, including suspend/on any cpu from other
+  * cpu and get affinity_info routine.
+  */
+
+
+.pushsection ._secure.text, "ax"
+
+enable_affinity:
+	/* Activate Affinity in CA-53 configuration
+	 * Enable the SMPEN bit in CPUECTLR_EL1 */
+	mrs x0, S3_1_c15_c2_1
+	orr x0, x0, #0x40
+	msr S3_1_c15_c2_1, x0
+	ret
+
+.globl	psci_arch_init
+psci_arch_init:
+	add     x29, x30, 0 /* keep return address */
+	bl	enable_affinity
+	bl	psci_build_stack
+	ret	x29
+
+psci_build_stack:
+
+	mrs     x5, SCR_EL3
+	bic	x5, x5, #1	/* Secure mode */
+	msr	SCR_EL3, x5
+	isb
+
+	mrs 	x4, MPIDR_EL1	/* get current CPU - Use affinity level 1 */
+	asr 	x4, x4, #8
+	and 	x4, x4, #0xff
+
+	mov	x5, #400		/* 1kB of stack per CPU */
+	mul	x4, x4, x5
+
+	adr	x5, text_end		/* end of text */
+	add	x5, x5, #0x2000		/* Skip two pages */
+	lsr	x5, x5, #12		/* Align to start of page */
+	lsl	x5, x5, #12
+	sub	sp, x5, x4		/* here's our stack! */
+
+	ret
+
+.globl	psci_0_2_system_reset
+psci_0_2_system_reset:
+	mov	x0, #(MVEBU_REGS_BASE)
+	add	x3, x0, #(MVEBU_NB_REGS_BASE)
+	add	x3, x3, #(MVEBU_WARM_RESET_REG)
+	mov	w0, #(MVEBU_WARM_RESET_MAGIC)
+	str	w0, [x3]
+	ret
+
+	/* x1 = target CPU */
+	/* x2 = target PC */
+.globl	psci_0_2_cpu_on_64
+psci_0_2_cpu_on_64:
+
+	adr	x0, _target_pc
+	str	x2, [x0]
+
+	dsb     sy
+
+	mov	x0, #(MVEBU_REGS_BASE)
+
+	/* set the cpu_1 start address */
+	ldr x3, =MVEBU_CPU_1_RESET_VECTOR
+	add	x3, x0, x3
+	adr x2, _armadalp_cpu_entry
+	lsr x2, x2, #2 /* 0x14044 is bit[33:2] of start address	 */
+	str 	w2, [x3]
+
+	/* get the cpu out of reset */
+	ldr x3, =MVEBU_CPU_1_RESET_REG
+	add	x3, x0, x3
+	mov 	w4, #1
+	lsl w4, w4, #MVEBU_CPU_1_RESET_BIT
+	mvn		w5, w4
+	ldr w2, [x3]
+	and	w2, w2, w5
+	str w2, [x3]
+	ldr w2, [x3]
+	orr 	w2, w2, w4
+	str 	w2, [x3]
+
+	/* return success */
+	mov	x0, #ARM_PSCI_RET_SUCCESS	/* Return PSCI_RET_SUCCESS */
+	ret
+
+.global _armadalp_cpu_entry
+_armadalp_cpu_entry:
+
+	bl	enable_affinity
+
+	isb
+
+	/*
+	 * Could be EL3/EL2/EL1, Initial State:
+	 * Little Endian, MMU Disabled, i/dCache Disabled
+	 */
+	adr	x0, vectors
+	switch_el x1, 3f, 2f, 1f
+3:	msr	vbar_el3, x0
+	mrs	x0, scr_el3
+	orr	x0, x0, #0xf			/* SCR_EL3.NS|IRQ|FIQ|EA */
+	msr	scr_el3, x0
+	msr	cptr_el3, xzr			/* Enable FP/SIMD */
+	ldr	x0, =COUNTER_FREQUENCY
+	msr	cntfrq_el0, x0			/* Initialize CNTFRQ */
+	b	0f
+2:	msr	vbar_el2, x0
+	mov	x0, #0x33ff
+	msr	cptr_el2, x0			/* Enable FP/SIMD */
+	b	0f
+1:	msr	vbar_el1, x0
+	mov	x0, #3 << 20
+	msr	cpacr_el1, x0			/* Enable FP/SIMD */
+0:
+
+#if defined(CONFIG_GICV3)
+	ldr	x0, =GICR_BASE
+	bl	gic_init_secure_percpu
+#elif defined(CONFIG_GICV2)
+	ldr	x0, =GICD_BASE
+	ldr	x1, =GICC_BASE
+	bl	gic_init_secure_percpu
+#endif
+
+	bl	psci_build_stack
+
+	bl	armv8_switch_to_el2
+#ifdef CONFIG_ARMV8_SWITCH_TO_EL1
+	bl	armv8_switch_to_el1
+#endif
+
+	adr	x0, _target_pc
+	ldr x0, [x0]
+	br	x0
+
+	/* 64 bit alignment for elements accessed as data */
+	.align 4
+_target_pc:
+	.quad 0x0
+
+text_end:
+	.popsection
diff --git a/arch/arm/cpu/armv8/armada3700/soc-init.c b/arch/arm/cpu/armv8/armada3700/soc-init.c
new file mode 100644
index 0000000..2938228
--- /dev/null
+++ b/arch/arm/cpu/armv8/armada3700/soc-init.c
@@ -0,0 +1,256 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+#define DEBUG
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/soc.h>
+#include <netdev.h>
+#include <asm/arch/mbus_reg.h>
+#include <asm/arch-mvebu/mbus.h>
+#include <asm/arch-mvebu/pinctl.h>
+#include <i2c.h>
+#include <libfdt.h>
+
+/* IO expander I2C device */
+#define I2C_IO_EXP_ADDR	0x22
+#define I2C_IO_CFG_REG_0	0x6
+#define I2C_IO_DATA_OUT_REG_0	0x2
+#define I2C_IO_REG_0_SATA_OFF	2
+#define I2C_IO_REG_0_USB_H_OFF	1
+
+/* NB warm reset */
+#define MVEBU_NB_WARM_RST_REG	(MVEBU_GPIO_NB_REG_BASE + 0x40)
+/* NB warm reset magic number, write it to MVEBU_GPIO_NB_RST_REG triggers warm reset */
+#define MVEBU_NB_WARM_RST_MAGIC_NUM	(0x1d1e)
+
+int soc_early_init_f(void)
+{
+#ifdef CONFIG_MVEBU_PINCTL
+	mvebu_pinctl_probe();
+#endif
+
+	return 0;
+}
+
+int soc_get_rev(void)
+{
+	/* This should read the soc rev from some register*/
+	return 0;
+}
+
+int soc_get_id(void)
+{
+	/* TO-DO, get soc ID from PCIe register */
+	/* in ArmadaLP, there is no device ID register, like A38x,
+	    it needs to be got from PCIe register, like A370 and AXP */
+	u32 id = 0x9991;
+	return id;
+}
+
+void soc_init(void)
+{
+	/* Do early SOC specific init here */
+
+	/* now there is no timer/MPP driver,
+	  * currently we put all this kind of
+	  * configuration here, and will remove
+	  * this after official driver is ready
+	  */
+#ifdef CONFIG_PALLADIUM
+
+#ifdef CONFIG_I2C_MV
+	/* 0xD0013830[10] = 1'b0 (select GPIO pins to use for I2C_1) */
+	writel((readl(0xd0013830) & ~(1 << 10)), 0xd0013830);
+#endif /* CONFIG_I2C_MV */
+
+#endif /* CONFIG_PALLADIUM */
+	return;
+}
+
+#ifdef CONFIG_MVNETA
+/**
+ * cpu_eth_init()
+ *	invoke mvneta_initialize for each port, which is the initialization
+ *	entrance of mvneta driver.
+ *
+ * Input:
+ *	bis - db_info
+ *
+ * Return:
+ *	0 - cool
+ */
+int cpu_eth_init(bd_t *bis)
+{
+	/* init neta module */
+	if (1 != mvneta_initialize(bis)) {
+		error("failed to init mvneta\n");
+		return 1;
+	}
+	/* in ArmadaLP, there is a new register, internal Register Base Address, for GBE to
+	    access other internal Register. since GBE is on South bridge, not the same island
+	    as CPU, here we set internal reg base value 0xf100000 into it.
+	    NETA drvier initialization does not rely on this configuration, so do it after
+	    mvneta_initialize() */
+	writel(MVEBU_REGS_BASE, MVEBU_ARLP_GBE0_INTERNAL_REG_BASE);
+	writel(MVEBU_REGS_BASE, MVEBU_ARLP_GBE1_INTERNAL_REG_BASE);
+
+	return 0;
+}
+#endif /* CONFIG_MVNETA */
+
+#ifdef CONFIG_I2C_MV
+void i2c_clk_enable(void)
+{
+	/* i2c is enabled by default,
+	  * but need this empty routine
+	  * to pass compilation.
+	*/
+	return;
+}
+
+#endif /* CONFIG_I2C_MV */
+
+int dram_init(void)
+{
+#ifdef CONFIG_PALLADIUM
+	/* NO DRAM init sequence in Pallaidum, so set static DRAM size of 256MB */
+	gd->ram_size = 0x20000000;
+#else
+	gd->ram_size = 0;
+
+	/* DDR size has been read from dts DDR node in SPL
+	 * ddr driver and pass to u-boot. */
+	gd->ram_size = (get_info(DRAM_CS0_SIZE) << 20);
+
+	if (gd->ram_size == 0) {
+		error("No DRAM banks detected");
+		return 1;
+	}
+#endif
+
+	return 0;
+}
+
+void reset_cpu(ulong ignored)
+{
+	/* write magic number of 0x1d1e to North Bridge Warm Reset register
+	   to trigger warm reset */
+	writel(MVEBU_NB_WARM_RST_MAGIC_NUM, MVEBU_NB_WARM_RST_REG);
+}
+
+#ifdef CONFIG_SCSI_AHCI_PLAT
+void board_ahci_power_on(void)
+{
+/* This I2C IO expander configuration is board specific,
+ * and adequate only to Marvell A3700 DB board
+ */
+#ifdef CONFIG_DEVEL_BOARD
+	int ret;
+	unsigned char buffer[1];
+
+	/* Enable power of SATA by set IO expander via I2C,
+	 * to set corresponding bit to output mode to enable the power for SATA.
+	 */
+	ret = i2c_read(I2C_IO_EXP_ADDR, I2C_IO_CFG_REG_0, sizeof(unsigned char), buffer, sizeof(buffer));
+	if (ret)
+		error("failed to read IO expander value via I2C\n");
+
+	buffer[0] &= ~(1 << I2C_IO_REG_0_SATA_OFF);
+	ret = i2c_write(I2C_IO_EXP_ADDR, I2C_IO_CFG_REG_0, sizeof(unsigned char), buffer, sizeof(buffer));
+	if (ret)
+		error("failed to set IO expander via I2C\n");
+#endif /* CONFIG_DEVEL_BOARD */
+}
+#endif /* CONFIG_SCSI_AHCI_PLAT */
+
+#ifdef CONFIG_USB_XHCI
+/* Set USB VBUS signals (via I2C IO expander/GPIO) as output and set output value as enabled */
+void board_usb_vbus_init(void)
+{
+#ifdef CONFIG_DEVEL_BOARD
+/* This I2C IO expander configuration is board specific, only to Marvell A3700 DB board.
+ * (I2C device at address 0x22, Register 0, BIT 1) */
+	int ret_read, ret_write;
+	unsigned char cfg_val[1], out_val[1];
+	const void *blob = gd->fdt_blob;
+
+	/* Make sure board is supported (currently only A3700-DB is supported) */
+	if (fdt_node_check_compatible(blob, 0, "marvell,armada-lp-db0") != 0) {
+		error("Missing USB VBUS power configuration for current board.\n");
+		return;
+	}
+
+	printf("Enable USB VBUS.\n");
+
+	/* initialize I2C */
+	init_func_i2c();
+
+	/* Read configuration (direction) and set VBUS pin as output (reset pin = output) */
+	ret_read = i2c_read(I2C_IO_EXP_ADDR, I2C_IO_CFG_REG_0, sizeof(unsigned char), cfg_val, sizeof(cfg_val));
+	cfg_val[0] &= ~(1 << I2C_IO_REG_0_USB_H_OFF);
+	ret_write = i2c_write(I2C_IO_EXP_ADDR, I2C_IO_CFG_REG_0, sizeof(unsigned char),
+			cfg_val, sizeof(cfg_val));
+	if (ret_read || ret_write)
+		error("failed to set USB VBUS configuration on I2C IO expander\n");
+
+	/* Read VBUS output value, and disable it */
+	ret_read = i2c_read(I2C_IO_EXP_ADDR, I2C_IO_DATA_OUT_REG_0, sizeof(unsigned char), out_val, sizeof(out_val));
+	out_val[0] &= ~(1 << I2C_IO_REG_0_USB_H_OFF);
+
+	ret_write = i2c_write(I2C_IO_EXP_ADDR, I2C_IO_DATA_OUT_REG_0, sizeof(unsigned char), out_val, sizeof(out_val));
+	if (ret_read || ret_write)
+		error("failed to lower USB VBUS power on I2C IO expander\n");
+
+	/* required delay for configuration to settle - must wait for power on port is disabled
+	 * in case VBUS signal was high, required 3 seconds delay to let VBUS signal fully settle down */
+	udelay(3000000);
+
+	/* Enable VBUS power: Set output value of VBUS pin as enabled */
+	out_val[0] |= (1 << I2C_IO_REG_0_USB_H_OFF);
+
+	ret_write = i2c_write(I2C_IO_EXP_ADDR, I2C_IO_DATA_OUT_REG_0, sizeof(unsigned char), out_val, sizeof(out_val));
+	if (ret_write)
+		error("failed to raise USB VBUS power on I2C IO expander\n");
+
+	udelay(500000); /* required delay to let output value settle up*/
+
+#endif /* CONFIG_DEVEL_BOARD */
+
+}
+#endif /* CONFIG_USB_XHCI */
+
+/************************************************************************
+   Function:  mvebu_is_in_recovery_mode
+
+   The function checks if the system currently boots into recovery mode.
+   The recovery mode is intended to bring up bricked board using UART
+   port as the boot device. This mode is either trigered by escape
+   sequence or by reset sample jumpers.
+
+   Return - 1 if recovery mode is active or 0 otherwise
+************************************************************************/
+bool mvebu_is_in_recovery_mode(void)
+{
+	u32 regval;
+
+	/* Check if we are in UART recovery boot mode - currently selected by botstrap */
+	regval = (readl(MVEBU_TEST_PIN_LATCH_N) & MVEBU_BOOTMODE_MASK) >> MVEBU_BOOTMODE_OFFS;
+	return regval == MVEBU_BOOTMODE_UART;
+}
diff --git a/arch/arm/cpu/armv8/armada3700/spl.c b/arch/arm/cpu/armv8/armada3700/spl.c
new file mode 100644
index 0000000..2fa37f5
--- /dev/null
+++ b/arch/arm/cpu/armv8/armada3700/spl.c
@@ -0,0 +1,115 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+#include <common.h>
+#include <asm/arch-mvebu/comphy.h>
+#include <asm/arch-mvebu/io_addr_dec.h>
+#include <asm/arch/clock.h>
+#include <asm/arch-mvebu/mbus.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch-mvebu/mvebu_misc.h>
+#include <asm/arch-mvebu/ddr.h>
+#include <asm/arch-mvebu/fdt.h>
+#include <spl.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void (*ptr_uboot_start)(void);
+
+void board_init_f(ulong silent)
+{
+	gd = &gdata;
+	gd->baudrate = CONFIG_BAUDRATE;
+
+	/* Silence flag is not supported by CM3 WTP BootROM */
+	gd->flags &= ~GD_FLG_SILENT;
+
+	/* isetup_fdt set default FDT to work with:
+	   - customer/regular mode: point to the defined
+	     FDT by CONFIG_DEFAULT_DEVICE_TREE.
+	   - Marvell multi FDT mode: set the first compiled relevant device
+	     tree for the SoC, required for i2c initialization to read EEPROM data */
+	setup_fdt();
+
+/* multi FDT feature reads eeprom, which requires I2C support
+ * but for Armada3700, I2C feature depends on GPIO configuration,
+ * so mvebu_setup_fdt need to be invoked after it.
+ *
+ * but GPIO driver also need to read FDT file, for reg base and
+ * other configurations. For reg base it is OK, since all the fdt
+ * files for all the boards should have the same value.
+ *
+ * as far as the I2C related GPIO settings, we will demand from HW that
+ * all Marvell boards will use the same set of I2C pins setup.
+ *
+ * GPIO need to be split into two stages: static shared (for I2C),
+ * and then dynamic-fdt-based. the first step will be done before
+ * mvebu_setup_fdt(), and the second one will be after it.
+ */
+#ifdef CONFIG_MVEBU_SPL_A3700_GPIO
+	mvebu_init_gpio();
+#endif
+
+#ifdef CONFIG_BOARD_CONFIG_EEPROM
+	cfg_eeprom_init();
+#endif
+
+#ifdef CONFIG_MULTI_DT_FILE
+	/* Update gd->fdt_blob according to multi-fdt data in eeprom */
+	mvebu_setup_fdt();
+#endif
+
+	/* UART1 and UART2 clocks are sourced from XTAL by default
+	* (see RD0012010 register for the details). Additionally the GPIO
+	* control (RD0013830) sets the GPIO1[26:25] as the UART1 pins by default.
+	* Therefore it is safe to start using UART before call to early_spl_init()
+	*/
+	preloader_console_init();
+
+	/* Clock should be enabeld before initialize the I/O units */
+#ifdef CONFIG_MVEBU_A3700_CLOCK
+	init_clock();
+#endif
+
+#ifdef CONFIG_MVEBU_A3700_MISC_INIT
+	misc_init_cci400();
+#endif
+
+	/* Init all relevant drivers (e.g. DDR, comphy...) */
+#ifdef CONFIG_MVEBU_COMPHY_SUPPORT
+	if (comphy_init(gd->fdt_blob))
+		error("COMPHY initialization failed\n");
+#endif
+#ifdef CONFIG_MVEBU_SPL_DDR_SUPPORT
+	mvebu_dram_init(gd->fdt_blob);
+#endif
+
+#ifdef CONFIG_MVEBU_MBUS
+	init_mbus();
+#endif
+
+#ifdef CONFIG_MVEBU_A3700_IO_ADDR_DEC
+	init_io_addr_dec();
+#endif
+
+	debug("SPL processing done. Jumping to u-boot\n\n");
+	ptr_uboot_start = 0;
+	/* Jump from SPL to u-boot start address */
+	ptr_uboot_start();
+}
+
diff --git a/arch/arm/cpu/armv8/armadalp/Kconfig b/arch/arm/cpu/armv8/armadalp/Kconfig
deleted file mode 100644
index f2228e0..0000000
--- a/arch/arm/cpu/armv8/armadalp/Kconfig
+++ /dev/null
@@ -1,73 +0,0 @@
-if TARGET_ARMADA_LP
-
-config SYS_CPU
-	string
-	default "armv8"
-
-config SYS_BOARD
-	string
-	default "armadalp"
-
-config SYS_VENDOR
-	string
-	default "mvebu"
-
-config SYS_SOC
-	string
-	default "armadalp"
-
-config SYS_CONFIG_NAME
-	string
-	default "armadalp"
-
-config ARMV8_PSCI
-	bool
-	default y
-
-config PALLADIUM
-	bool "Support palladium emulation"
-	default n
-	help
-	  Choose this option to enable
-	  Palladium support.
-	  There are certain differences
-	  between palladium and real SoC,
-	  like Clock and PHY, this should
-	  not be enabled for real SoC.
-
-config MVEBU_SPL_A3700_GPIO
-	bool "GPIO configuration for A3700 in SPL"
-	depends on TARGET_ARMADA_LP
-	default y
-	help
-	  Choose this option to enable GPIO
-	  configuration for A3700 in SPL.
-	  This will be removed later, and be
-	  implemented by MPP/PIN-CTRL driver.
-
-config MVEBU_A3700_IO_ADDR_DEC
-	bool "Armada-3700 Address decoding support"
-	depends on !MVEBU_SPL_DDR_OVER_PCI_SUPPORT
-	default n
-	help
-	  Choose this option to add support
-	  for Marvell Armada-3700 address decoding driver
-
-config MVEBU_A3700_MISC_INIT
-	bool "Armada-3700 miscellaneous initialization procedures support"
-	default n
-	help
-	  Choose this option to add support
-	  for Marvell Armada-3700 miscellaneous init procedures
-
-config MVEBU_A3700_CLOCK
-	bool "Armada-3700  clock support"
-	default n
-	help
-	  Choose this option to support
-	  Marvell Armada-3700 clock driver.
-	  For the first stage all clocks will be enabled
-	  by default.
-
-endif
-
diff --git a/arch/arm/cpu/armv8/armadalp/Makefile b/arch/arm/cpu/armv8/armadalp/Makefile
deleted file mode 100644
index be2f6db..0000000
--- a/arch/arm/cpu/armv8/armadalp/Makefile
+++ /dev/null
@@ -1,26 +0,0 @@
-#
-# ***************************************************************************
-# Copyright (C) 2015 Marvell International Ltd.
-# ***************************************************************************
-# This program is free software: you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the Free
-# Software Foundation, either version 2 of the License, or any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-# ***************************************************************************
-#
-
-obj-y += soc-init.o
-obj-$(CONFIG_SPL_BUILD) += spl.o
-obj-y += clock.o
-obj-$(CONFIG_ARMV8_PSCI)	+= psci.o
-obj-$(CONFIG_MVEBU_A3700_IO_ADDR_DEC) += mvebu_io_addr_dec.o
-obj-$(CONFIG_MVEBU_SPL_A3700_GPIO) += mvebu_gpio.o
-obj-$(CONFIG_MVEBU_A3700_MISC_INIT) += mvebu_misc_init.o
-obj-$(CONFIG_MVEBU_A3700_CLOCK) += mvebu_clock.o
diff --git a/arch/arm/cpu/armv8/armadalp/clock.c b/arch/arm/cpu/armv8/armadalp/clock.c
deleted file mode 100644
index dace4f9..0000000
--- a/arch/arm/cpu/armv8/armadalp/clock.c
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
-* ***************************************************************************
-* Copyright (C) 2015 Marvell International Ltd.
-* ***************************************************************************
-* This program is free software: you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the Free
-* Software Foundation, either version 2 of the License, or any later version.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program.  If not, see <http://www.gnu.org/licenses/>.
-* ***************************************************************************
-*/
-
-#include <common.h>
-#include <asm/arch-mvebu/clock.h>
-#include <asm/arch/clock.h>
-
-u32 soc_tclk_get(void)
-{
-	return 200000000;
-}
-
-u32 soc_cpu_clk_get(void)
-{
-	return get_cpu_clk() * 1000000;
-}
-
-u32 soc_ddr_clk_get(void)
-{
-	return get_ddr_clk() * 1000000;
-}
-
-u32 soc_l2_clk_get(void)
-{
-	return 800000000;
-}
-
-u32 soc_timer_clk_get(void)
-{
-	return 800000000;
-}
-
-void soc_print_clock_info(void)
-{
-	printf("       CPU    @ %d [MHz]\n", soc_cpu_clk_get() / 1000000);
-	printf("       L2     @ %d [MHz]\n", soc_l2_clk_get() / 1000000);
-	printf("       TClock @ %d [MHz]\n", soc_tclk_get() / 1000000);
-	printf("       DDR    @ %d [MHz]\n", soc_ddr_clk_get() / 1000000);
-}
diff --git a/arch/arm/cpu/armv8/armadalp/mvebu_clock.c b/arch/arm/cpu/armv8/armadalp/mvebu_clock.c
deleted file mode 100644
index db0ca74..0000000
--- a/arch/arm/cpu/armv8/armadalp/mvebu_clock.c
+++ /dev/null
@@ -1,607 +0,0 @@
-/*
- * ***************************************************************************
- * Copyright (C) 2015 Marvell International Ltd.
- * ***************************************************************************
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation, either version 2 of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * ***************************************************************************
- */
-/*#define DEBUG*/
-#include <common.h>
-#include <fdtdec.h>
-#include <asm/io.h>
-#include <asm/arch-mvebu/fdt.h>
-#include <asm/arch-mvebu/mvebu.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/soc-info.h>	/* XTAL and Boot mode */
-#include <asm/io.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-static struct a3700_clock_cfg a3700_clock_configs[] = MVEBU_A3700_CLOCK_CFGS;
-
-
-/***************************************************************************************************
-  * get_ref_clk
-  *
-  * return: reference clock in MHz (25 or 40)
- ***************************************************************************************************/
-u32 get_ref_clk(void)
-{
-	u32 regval;
-
-	regval = (readl(MVEBU_TEST_PIN_LATCH_N) & MVEBU_XTAL_MODE_MASK) >> MVEBU_XTAL_MODE_OFFS;
-
-	if (regval == MVEBU_XTAL_CLOCK_25MHZ)
-		return 25;
-	else
-		return 40;
-}
-
-/******************************************************************************
-* Name: get_tbg_vco_sel
-*
-* Description:	calculate the vco parameters for TBG based on the target clock.
-*
-* Input:	kvco_mhz - KVCO clock freq in MHz
-*
-* Output:	vco_intpi - Phase Interpolator Bias Current
-*		vco_range - VCO frequency range (0x8 - 0xF)
-*
-* Return: 0 - OK
-******************************************************************************/
-static int get_tbg_vco_sel(u32 kvco_mhz,
-			   u32 *vco_intpi,
-			   u32 *vco_range)
-{
-	u8  index;
-	u16 vco_top_ranges_mhz[8] = {1350, 1500, 1750, 2000, 2200, 2400, 2600, 3000};
-
-	debug_enter();
-
-	if ((kvco_mhz <= MVEBU_KVCO_MIN) && (kvco_mhz >= MVEBU_KVCO_MAX)) {
-		error("Invalid KVCO CLK requested - %d MHz\n", kvco_mhz);
-		return 1;
-	}
-
-	/* Select the range the KVCO fits to.
-	   Valid values are 0x8 through 0xF.
-	   See TBG_A_KVCO and TBG_B_KVCO fields for details
-	 */
-	for (index = 0; index < 8; index++) {
-		if (kvco_mhz <= vco_top_ranges_mhz[index]) {
-			*vco_range = index + 8;
-			break;
-		}
-	}
-
-	/* INTPI - Phase Interpolator Bias Current
-	  8 <= KVCO is 2.5 ~ 3.0 GHz,
-	  6 <= KVCO is 2.0 ~ 2.5 GHz,
-	  5 <= KVCO is 1.5 ~ 2.0 GHz
-	 */
-	if (kvco_mhz > 2500)
-		*vco_intpi = 8;
-	else if (kvco_mhz < 2000)
-		*vco_intpi = 5;
-	else
-		*vco_intpi = 6;
-
-	debug_exit();
-	return 0;
-}
-
-/******************************************************************************
-* Name: set_tbg_clock
-*
-* Description:	Change the TBG(A/B) clock
-*		All affected North/South bridge clock sources should be
-*		switched to XTAL mode prior to calling this function!
-*
-* Input:	kvco_mhz:     AKVCO clock for TBG-X in MHz
-*		se_vco_div:   single-ended clock VCO divider (TBG_X_S)
-*		diff_vco_div: differential clock VCO post divider (TBG_X_P)
-*		tbg_typ:      TBG type (A/B)
-* Output:	None
-* Return:	0 if OK
-******************************************************************************/
-static u32 set_tbg_clock(u32 kvco_mhz,
-			       u32 se_vco_div,
-			       u32 diff_vco_div,
-			       enum a3700_clock_src tbg_typ)
-{
-	u32 vco_range = 0, vco_intpi = 0;
-	u32 tbg_M, tbg_N;
-	u32 icp;
-	u32 regval;
-	int ret;
-
-	debug_enter();
-
-	/* Try to keep Fref/M as close as possible to 10 MHz */
-	if (get_ref_clk() == 40) {
-		/* 40MHz */
-		debug("REF clock is 40MHz\n");
-		tbg_M = 4;	/* 10MHz */
-		icp = 5;	/* 8 */
-	} else	{
-		/* 25MHz */
-		debug("REF clock is 25MHz\n");
-		tbg_M = 3;	/* 8.33MHz */
-		icp = 6;	/* 9 */
-	}
-
-	ret = get_tbg_vco_sel(kvco_mhz, &vco_intpi, &vco_range);
-	if (ret != 0) {
-		error("Failed to obtain VCO divider selection\n");
-		return ret;
-	}
-
-	/* TBG frequency is calculated according to formula:
-		Ftbg = Fkvco / se_vco_div
-	   where
-		Fkvco = N * Fref * 4 / M
-
-	   N - TBG_A_FBDIV or TBG_B_FBDIV
-	   M - TBG_A_REFDIV or TBG_B_REFDIV
-	   se_vco_div - TBG_A_VCODIV_SEL_SE or TBG_B_VCODIV_SEL_SE
-	   Fref - reference clock 25MHz or 40 MHz
-	  */
-	tbg_N = (kvco_mhz * tbg_M / get_ref_clk()) >> 2;
-	debug("TBG-%s: SE vco_div %#x, DIFF vco_div %#x,vco_range %#x tbg_N %#x KVCO = %d MHz\n",
-	      tbg_typ == TBG_A ? "A" : "B", se_vco_div, diff_vco_div, vco_range, tbg_N, kvco_mhz);
-
-	/* 1. Switch all North/South Bridge clock sources to XTAL
-	      Should be already done by the function caller */
-
-	/* 2. Set TBG-A (bit[0]) or TBG-B (bit[16]) to reset state  */
-	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
-	regval |= (tbg_typ == TBG_A) ? BIT0 : BIT16;
-	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
-
-	/* The A3700 FS requires to power down TGB before
-	   changing PLL parameters. However it turns out that
-	   this step is not essential. Putting TBG into reset
-	   state is enough.
-	   3. Power down TBG-A (bit[1]) or TBG-B (bit[17])
-	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
-	regval |= (tbg_typ == TBG_A) ? BIT1 : BIT17;
-	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
-	*/
-
-	/* 4. Set TBG-A (bit[10:2]) or TBG-B (bit[26:18]) FBDIV (N) value */
-	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
-	regval &= (tbg_typ == TBG_A) ? ~(0xFFUL << 2) : ~(0xFFUL << 18);
-	regval |= (tbg_typ == TBG_A) ? (tbg_N << 2) : (tbg_N << 18);
-	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
-
-	/* 5. Set TBG-A (bit[8:0]) or TBG-B (bit[24:16]) REFDIV (M) value */
-	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL7);
-	regval &= (tbg_typ == TBG_A) ? ~(0x1FFUL << 0) : ~(0x1FFUL << 16);
-	regval |= (tbg_typ == TBG_A) ? (tbg_M << 0) : (tbg_M << 16);
-	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL7);
-
-	/* 6a. Set TBG-A (bit[8:0]) or TBG-B (bit[24:16]) SE VCODIV value  */
-	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
-	regval &= (tbg_typ == TBG_A) ? ~(0x1FFUL << 0) : ~(0x1FFUL << 16);
-	regval |= (tbg_typ == TBG_A) ? (se_vco_div << 0) : (se_vco_div << 16);
-	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL1);
-
-	/* 6b. Set TBG-A (bit[9:1]) or TBG-B (bit[25:17]) DIFF VCODIV value  */
-	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL8);
-	regval &= (tbg_typ == TBG_A) ? ~(0x1FFUL << 1) : ~(0x1FFUL << 17);
-	regval |= (tbg_typ == TBG_A) ? (diff_vco_div << 1) : (diff_vco_div << 17);
-	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL8);
-
-	/* 7. Set TBG-A (bit[11]) or TBG-B (bit[27]) PLL Bandwidth to normal (0x0) */
-	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
-	regval &= (tbg_typ == TBG_A) ? ~(0x1UL << 11) : ~(0x1UL << 27);
-	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL1);
-
-	/* 8. Set TBG-A (bit[11:8]) or TBG-B (bit[27:24]) ICP Charge Pump Current value */
-	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL2);
-	regval &= (tbg_typ == TBG_A) ? ~(0xFUL << 8) : ~(0xFUL << 24);
-	regval |= (tbg_typ == TBG_A) ? (icp << 8) : (icp << 24);
-	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL2);
-
-	/* 9. Set TBG-A (bit[3:0]) or TBG-B (bit[19:16]) KVCO range value  */
-	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL3);
-	regval &= (tbg_typ == TBG_A) ? ~(0xFUL << 0) : ~(0xFUL << 16);
-	regval |= (tbg_typ == TBG_A) ? (vco_range << 0) : (vco_range << 16);
-	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL3);
-
-	/* 10. Set TBG-A (bit[3:0]) or TBG-B (bit[19:16]) INTPI value  */
-	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL2);
-	regval &= (tbg_typ == TBG_A) ? ~(0xFUL << 0) : ~(0xFUL << 16);
-	regval |= (tbg_typ == TBG_A) ? (vco_intpi << 0) : (vco_intpi << 16);
-	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL2);
-
-	/* The A3700 FS requires to power down TGB before
-	   changing PLL parameters. However it turns out that
-	   this step is not essential. Putting TBG into reset
-	   state is enough.
-	   11. Power up TBG-A (bit[1]) or TBG-B (bit[17])
-	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
-	regval &= (tbg_typ == TBG_A) ? ~(BIT1) : ~(BIT17);
-	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
-	*/
-
-	/* 12. Release TBG-A (bit[0]) or TBG-B (bit[16]) from reset */
-	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
-	regval &= (tbg_typ == TBG_A) ? ~(BIT0) : ~(BIT16);
-	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL0);
-
-	/* 13. Set TBG-A (bit[9]) or TBG-B (bit[25]) Bypass to disable - get CLKOUT from PLL */
-	regval = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
-	regval &= (tbg_typ == TBG_A) ? ~(BIT9) : ~(BIT25);
-	writel(regval, MVEBU_NORTH_BRG_TBG_CTRL1);
-
-	/* 14. Wait for TBG-A (bit[15] and TBG-B (bit[31]) PLL lock */
-	do {
-		regval = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
-		regval &= BIT15 | BIT31;
-	} while (regval != (BIT15 | BIT31));
-
-	/* 15. Switch all North/South Bridge clock sources to clock divider
-	       Will be done by function caller when required */
-
-	/* Wait for stable clock output, suggested 40us */
-	udelay(40);
-
-	debug_exit();
-	return 0;
-}
-
-#ifdef MVEBU_A3700_ENABLE_SSC
-/******************************************************************************
-* Name: set_ssc_mode
-*
-* Description: Setup Spread Spectrum Clcok for TBG-A/B
-*
-* Input:	None
-* Output:	None
-* Return:	Non-zero on error
-******************************************************************************/
-static u32 set_ssc_mode(void)
-{
-	debug_enter();
-	return 0;
-	debug_exit();
-}
-#endif /* MVEBU_A3700_ENABLE_SSC */
-
-/******************************************************************************
-* Name: set_clocks
-*
-* Description: Configure entire clock tree according to CPU and DDR frequency
-*
-* Input:	cpu_clk_mhz: required CPU clock
-*		ddr_clk_mhz: required DDR clock
-*		tbg_a_kvco_mhz: required TBG-A KVCO frequency or 0 for any available
-*		tbg_b_kvco_mhz: required TBG-B KVCO frequency or 0 for any available
-* Output:	None
-* Return:	Non-zero if the requested settings are not supported
-******************************************************************************/
-u32 set_clocks(u32 cpu_clk_mhz, u32 ddr_clk_mhz, u32 tbg_a_kvco_mhz, u32 tbg_b_kvco_mhz)
-{
-	u32 clock_cfgs_cnt = sizeof(a3700_clock_configs)/sizeof(a3700_clock_configs[0]);
-	u32 cfg;
-	struct a3700_clock_cfg *clk_cfg = 0;
-	u32 rval, reg_val;
-
-	debug_enter();
-
-	/* Search for the supported clock tree configuration */
-	for (cfg = 0; cfg < clock_cfgs_cnt; cfg++) {
-		if ((a3700_clock_configs[cfg].cpu_freq_mhz == cpu_clk_mhz) &&
-		    (a3700_clock_configs[cfg].ddr_freq_mhz == ddr_clk_mhz) &&
-		    ((tbg_a_kvco_mhz == 0) || (a3700_clock_configs[cfg].tbg_a.kvco_mhz == tbg_a_kvco_mhz)) &&
-		    ((tbg_b_kvco_mhz == 0) || (a3700_clock_configs[cfg].tbg_b.kvco_mhz == tbg_b_kvco_mhz))) {
-			clk_cfg = &a3700_clock_configs[cfg];
-			debug("Found valid FREQ preset(#%d): CPU=%dMHz, DDR=%dMHz\n", cfg,
-			      a3700_clock_configs[cfg].cpu_freq_mhz, a3700_clock_configs[cfg].ddr_freq_mhz);
-			break;
-		}
-	}
-
-	if (clk_cfg == 0) {
-		error("Unable to find valid FREQ preset for CPU=%dMHz, DDR=%dMHz, TBG-A=%dMHz, TBG-B=%dMHz\n",
-		      cpu_clk_mhz, ddr_clk_mhz, tbg_a_kvco_mhz, tbg_b_kvco_mhz);
-		return 1;
-	}
-
-	/* Switch all North/South Bridge clock sources to XTAL
-	   prior to make any change to the clock configuration */
-	writel(0x00000000, MVEBU_NORTH_CLOCK_SELECT_REG);
-	writel(0x00000000, MVEBU_SOUTH_CLOCK_SELECT_REG);
-
-	rval = set_tbg_clock(clk_cfg->tbg_a.kvco_mhz,
-			     clk_cfg->tbg_a.se_vcodiv,
-			     clk_cfg->tbg_a.diff_vcodiv,
-			     TBG_A);
-	if (rval) {
-		error("Failed to set TBG-A clock to %dMHz\n", clk_cfg->tbg_a.kvco_mhz);
-		return rval;
-	}
-
-	rval = set_tbg_clock(clk_cfg->tbg_b.kvco_mhz,
-			     clk_cfg->tbg_b.se_vcodiv,
-			     clk_cfg->tbg_b.diff_vcodiv,
-			     TBG_B);
-	if (rval) {
-		error("Failed to set TBG-B clock to %dMHz\n", clk_cfg->tbg_b.kvco_mhz);
-		return rval;
-	}
-
-	/* North Bridge clock tree configuration */
-	/* Enable all clocks */
-	writel(NB_ALL_CLK_ENABLE, MVEBU_NORTH_CLOCK_ENABLE_REG);
-
-	/* Setup dividers */
-	reg_val = readl(MVEBU_NORTH_CLOCK_DIVIDER_SELECT0_REG);
-	reg_val &= NB_CLK_DIV0_MASK_ALL;
-	reg_val |= clk_cfg->nb_clk_cfg.div0.pwm_clk_prscl2 & 0x7;
-	reg_val |= (clk_cfg->nb_clk_cfg.div0.pwm_clk_prscl1 & 0x7) << 3;
-	reg_val |= (clk_cfg->nb_clk_cfg.div0.ddr_fclk_clk_prscl2 & 0x7) << 12;
-	reg_val |= (clk_cfg->nb_clk_cfg.div0.ddr_fclk_clk_prscl1 & 0x7) << 15;
-	reg_val |= (clk_cfg->nb_clk_cfg.div0.ddr_phy_mck_div_sel & 0x1) << 18;
-	reg_val |= (clk_cfg->nb_clk_cfg.div0.trace_div_sel & 0x7) << 20;
-	reg_val |= (clk_cfg->nb_clk_cfg.div0.counter_clk_prscl & 0x7) << 23;
-	reg_val |= (clk_cfg->nb_clk_cfg.div0.a53_cpu_clk_prscl & 0x7) << 28;
-	writel(reg_val, MVEBU_NORTH_CLOCK_DIVIDER_SELECT0_REG);
-
-	reg_val = readl(MVEBU_NORTH_CLOCK_DIVIDER_SELECT1_REG);
-	reg_val &= NB_CLK_DIV1_MASK_ALL;
-	reg_val |= clk_cfg->nb_clk_cfg.div1.sec_at_clk_prscl2 & 0x7;
-	reg_val |= (clk_cfg->nb_clk_cfg.div1.sec_at_clk_prscl1 & 0x7) << 3;
-	reg_val |= (clk_cfg->nb_clk_cfg.div1.sec_dap_clk_prscl2 & 0x7) << 6;
-	reg_val |= (clk_cfg->nb_clk_cfg.div1.sec_dap_clk_prscl1 & 0x7) << 9;
-	reg_val |= (clk_cfg->nb_clk_cfg.div1.tsecm_clk_prscl2 & 0x7) << 12;
-	reg_val |= (clk_cfg->nb_clk_cfg.div1.tsecm_clk_prscl1 & 0x7) << 15;
-	reg_val |= (clk_cfg->nb_clk_cfg.div1.setm_tmx_clk_prscl & 0x7) << 18;
-	reg_val |= (clk_cfg->nb_clk_cfg.div1.sqf_clk_prscl2 & 0x7) << 24;
-	reg_val |= (clk_cfg->nb_clk_cfg.div1.sqf_clk_prscl1 & 0x7) << 27;
-	writel(reg_val, MVEBU_NORTH_CLOCK_DIVIDER_SELECT1_REG);
-
-	reg_val = readl(MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG);
-	reg_val &= NB_CLK_DIV2_MASK_ALL;
-	reg_val |= clk_cfg->nb_clk_cfg.div2.wc_ahb_div_sel & 0x7;
-	reg_val |= (clk_cfg->nb_clk_cfg.div2.sata_h_clk_prscl2 & 0x7) << 7;
-	reg_val |= (clk_cfg->nb_clk_cfg.div2.sata_h_clk_prscl1 & 0x7) << 10;
-	reg_val |= (clk_cfg->nb_clk_cfg.div2.mmc_clk_prscl2 & 0x7) << 13;
-	reg_val |= (clk_cfg->nb_clk_cfg.div2.mmc_clk_prscl1 & 0x7) << 16;
-	reg_val |= (clk_cfg->nb_clk_cfg.div2.eip97_clk_prscl2 & 0x7) << 19;
-	reg_val |= (clk_cfg->nb_clk_cfg.div2.eip97_clk_prscl1 & 0x7) << 22;
-	reg_val |= (clk_cfg->nb_clk_cfg.div2.atb_clk_div_sel & 0x3) << 25;
-	/* Always use "divide by 1 (0)" for counter clock and ignore table value
-	reg_val |= (clk_cfg->nb_clk_cfg.div2.cpu_cnt_clk_div_sel & 0x3) << 27;
-	*/
-	reg_val |= (clk_cfg->nb_clk_cfg.div2.plkdbg_clk_div_sel & 0x3) << 29;
-	writel(reg_val, MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG);
-
-	/* Setup connection to clock lines */
-	reg_val = readl(MVEBU_NORTH_CLOCK_TBG_SELECT_REG);
-	reg_val &= NB_CLK_TBG_SEL_MASK_ALL;
-	reg_val |= clk_cfg->nb_clk_cfg.clock_sel.mmc_pclk_sel & 0x3;
-	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.sata_host_pclk_sel & 0x3) << 2;
-	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.sec_at_pclk_sel & 0x3) << 4;
-	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.sec_dap_pclk_sel & 0x3) << 6;
-	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.tsecm_pclk_sel & 0x3) << 8;
-	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.setm_tmx_pclk_sel & 0x3) << 10;
-	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.sqf_pclk_sel & 0x3) << 12;
-	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.pwm_pclk_sel & 0x3) << 14;
-	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.ddr_fclk_pclk_sel & 0x3) << 16;
-	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.trace_pclk_sel & 0x3) << 18;
-	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.counter_pclk_sel & 0x3) << 20;
-	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.a53_cpu_pclk_sel & 0x3) << 22;
-	reg_val |= (clk_cfg->nb_clk_cfg.clock_sel.eip97_pclk_sel & 0x3) << 24;
-	writel(reg_val, MVEBU_NORTH_CLOCK_TBG_SELECT_REG);
-
-	/* South Bridge clock tree configuration */
-	/* Enable all clocks */
-	writel(SB_ALL_CLK_ENABLE, MVEBU_SOUTH_CLOCK_ENABLE_REG);
-
-	/* Setup dividers */
-	reg_val = readl(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT0_REG);
-	reg_val &= SB_CLK_DIV0_MASK_ALL;
-	reg_val |= (clk_cfg->sb_clk_cfg.div0.sdio_clk_prscl2 & 0x7) << 3;
-	reg_val |= (clk_cfg->sb_clk_cfg.div0.sdio_clk_prscl1 & 0x7) << 6;
-	reg_val |= (clk_cfg->sb_clk_cfg.div0.usb32_usb2_sys_clk_prscl2 & 0x7) << 9;
-	reg_val |= (clk_cfg->sb_clk_cfg.div0.usb32_usb2_sys_clk_prscl1 & 0x7) << 12;
-	reg_val |= (clk_cfg->sb_clk_cfg.div0.usb32_ss_sys_clk_prscl2 & 0x7) << 15;
-	reg_val |= (clk_cfg->sb_clk_cfg.div0.usb32_ss_sys_clk_prscl1 & 0x7) << 18;
-	reg_val |= (clk_cfg->sb_clk_cfg.div0.sb_axi_clk_prscl2 & 0x7) << 21;
-	reg_val |= (clk_cfg->sb_clk_cfg.div0.sb_axi_clk_prscl1 & 0x7) << 24;
-	writel(reg_val, MVEBU_SOUTH_CLOCK_DIVIDER_SELECT0_REG);
-
-	reg_val = readl(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG);
-	reg_val &= SB_CLK_DIV1_MASK_ALL;
-	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_125_clk_prscl2 & 0x7) << 6;
-	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_125_clk_prscl1 & 0x7) << 9;
-	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_bm_core_clk_div2_sel & 0x1) << 12;
-	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe1_core_clk_div2_sel & 0x1) << 13;
-	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe0_core_clk_div2_sel & 0x1) << 14;
-	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_core_clk_prscl2 & 0x7) << 18;
-	reg_val |= (clk_cfg->sb_clk_cfg.div1.gbe_core_clk_prscl1 & 0x7) << 21;
-	writel(reg_val, MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG);
-
-	reg_val = readl(MVEBU_SOUTH_CLOCK_DIVIDER_SELECT2_REG);
-	reg_val &= SB_CLK_DIV2_MASK_ALL;
-	reg_val |= (clk_cfg->sb_clk_cfg.div2.gbe_50_clk_prscl2 & 0x7) << 6;
-	reg_val |= (clk_cfg->sb_clk_cfg.div2.gbe_50_clk_prscl1 & 0x7) << 9;
-	writel(reg_val, MVEBU_SOUTH_CLOCK_DIVIDER_SELECT2_REG);
-
-	/* Setup connection to clock lines */
-	reg_val = readl(MVEBU_SOUTH_CLOCK_TBG_SELECT_REG);
-	reg_val &= SB_CLK_TBG_SEL_MASK_ALL;
-	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.gbe_50_pclk_sel & 0x3) << 6;
-	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.gbe_core_pclk_sel & 0x3) << 8;
-	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.gbe_125_pclk_sel & 0x3) << 10;
-	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.sdio_pclk_sel & 0x3) << 14;
-	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.usb32_usb2_sys_pclk_sel & 0x3) << 16;
-	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.usb32_ss_sys_pclk_sel & 0x3) << 18;
-	reg_val |= (clk_cfg->sb_clk_cfg.clock_sel.sb_axi_pclk_sel & 0x3) << 20;
-	writel(reg_val, MVEBU_SOUTH_CLOCK_TBG_SELECT_REG);
-
-
-#ifdef MVEBU_A3700_ENABLE_SSC
-	set_ssc_mode();
-#else
-	/* Disable SSC for TBG-A (bit[10]) and TBG-B (bit[26]) */
-	reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL3);
-	reg_val &= ~(BIT10 | BIT26);
-	writel(reg_val, MVEBU_NORTH_BRG_TBG_CTRL3);
-#endif /* MVEBU_A3700_ENABLE_SSC */
-
-	/* Switch all North/South Bridge clock sources from XTAL to clock divider
-	   excepting counter clock, which remains to be connected to XTAL */
-	writel(0x00009FFF, MVEBU_NORTH_CLOCK_SELECT_REG);
-	writel(0x000007AA, MVEBU_SOUTH_CLOCK_SELECT_REG);
-
-	debug_exit();
-	return rval;
-}
-
-int init_clock(void)
-{
-	int node, count, idx, ret;
-	const void *blob = gd->fdt_blob;
-	int tbl_sz = sizeof(a3700_clock_configs)/sizeof(a3700_clock_configs[0]);
-	u32 vdd_val;
-
-	debug_enter();
-
-	count = fdtdec_find_aliases_for_id(blob, "freq", COMPAT_MVEBU_A3700_FREQ, &node, 1);
-	if (count == 0) {
-		error("The frequency preset is not defined in DT, using default\n");
-		idx = MVEBU_A3700_DEF_CLOCK_PRESET_IDX;
-	} else {
-		idx = fdtdec_get_int(blob, node, "preset", MVEBU_A3700_DEF_CLOCK_PRESET_IDX);
-		if ((idx >= tbl_sz) || (idx < 0)) {
-			error("Unsupported frequency preset in DT (%d), using default\n", idx);
-			idx = MVEBU_A3700_DEF_CLOCK_PRESET_IDX;
-		}
-	}
-
-	printf("Setting clocks to CPU=%dMHz and DDR=%dMHz\n",
-		a3700_clock_configs[idx].cpu_freq_mhz, a3700_clock_configs[idx].ddr_freq_mhz);
-
-	ret =  set_clocks(a3700_clock_configs[idx].cpu_freq_mhz,
-			  a3700_clock_configs[idx].ddr_freq_mhz,
-			  a3700_clock_configs[idx].tbg_a.kvco_mhz,
-			  a3700_clock_configs[idx].tbg_b.kvco_mhz);
-	if (ret)
-		error("Failed to configure system clocks\n");
-
-	/* Enable AVS for high CPU clocks */
-	if (a3700_clock_configs[idx].cpu_freq_mhz >= 800)
-		vdd_val = AVS_VDD_VAL(AVS_VDD_800_MHZ_MV);
-	else if (a3700_clock_configs[idx].cpu_freq_mhz == 600)
-		vdd_val = AVS_VDD_VAL(AVS_VDD_600_MHZ_MV);
-	else
-		vdd_val = 0;
-
-	if (vdd_val != 0) {
-		u32 avs_reg = AVS_SOFT_RESET | AVS_SPEED_TARGET_MASK | AVS_SEL_VSENCE0 |
-				(vdd_val << AVS_LOW_VDD_LIMIT_OFFS) |
-				(vdd_val << AVS_HIGH_VDD_LIMIT_OFFS);
-
-		writel(avs_reg, MVEBU_AVS_CTRL_0);
-		avs_reg &= ~AVS_SOFT_RESET;
-		writel(avs_reg, MVEBU_AVS_CTRL_0);
-		avs_reg |= AVS_ENABLE;
-		writel(avs_reg, MVEBU_AVS_CTRL_0);
-		printf("AVS enabled (%d mV)\n",
-			a3700_clock_configs[idx].cpu_freq_mhz == 600 ?
-			AVS_VDD_600_MHZ_MV : AVS_VDD_800_MHZ_MV);
-	}
-
-	debug_exit();
-	return ret;
-}
-
-static u32 get_tbg_clk(enum a3700_clock_line tbg_typ)
-{
-	u32 tbg_M, tbg_N, vco_div;
-	u32 ref, reg_val;
-
-	/* get ref clock */
-	ref = get_ref_clk();
-
-	/* get M, N */
-	reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL7);
-	tbg_M = ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_A_P)) ?
-		(reg_val & 0x1FFUL) : ((reg_val >> 16) & 0x1FFUL);
-	tbg_M = (tbg_M == 0) ? 1 : tbg_M;
-
-	reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL0);
-	tbg_N = ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_A_P)) ?
-		((reg_val >> 2) & 0x1FFUL) : ((reg_val >> 18) & 0x1FFUL);
-
-	if ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_B_S)) {
-		/* get SE VCODIV */
-		reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL1);
-		reg_val = (tbg_typ == TBG_A_S) ?
-			  (reg_val & 0x1FFUL) : ((reg_val >> 16) & 0x1FFUL);
-	} else {
-		/* get DIFF VCODIV */
-		reg_val = readl(MVEBU_NORTH_BRG_TBG_CTRL8);
-		reg_val = (tbg_typ == TBG_A_P) ?
-			  ((reg_val >> 1) & 0x1FFUL) : ((reg_val >> 17) & 0x1FFUL);
-	}
-	if (reg_val > 7)
-		return 0; /*invalid*/
-
-	vco_div = 0x1 << reg_val;
-
-	return ((tbg_N * ref) << 2)/(tbg_M * vco_div);
-}
-
-u32 get_cpu_clk(void)
-{
-	u32 tbg, cpu_prscl;
-	enum a3700_clock_line tbg_typ;
-
-	/* 1. check cpu clock select */
-	if (!((readl(MVEBU_NORTH_CLOCK_SELECT_REG) >> 15) & 0x1))
-		return 0; /* CPU clock is using XTAL output*/
-
-	/* 2. get TBG select */
-	tbg_typ = (readl(MVEBU_NORTH_CLOCK_TBG_SELECT_REG) >> 22) & 0x3;
-
-	/* 3. get TBG clock */
-	tbg = get_tbg_clk(tbg_typ);
-	if (tbg == 0)
-		return 0;
-
-	/* 4. get CPU clk divider */
-	cpu_prscl = (readl(MVEBU_NORTH_CLOCK_DIVIDER_SELECT0_REG) >> 28) & 0x7;
-	if (cpu_prscl == 7)
-		return 0; /* divider value error */
-
-	return tbg/cpu_prscl;
-}
-
-u32 get_ddr_clk(void)
-{
-	u32 tbg;
-
-	/* 1. check DDR clock select */
-	if (!((readl(MVEBU_NORTH_CLOCK_SELECT_REG) >> 10) & 0x1))
-		return 0; /* DDR clock is using XTAL output*/
-
-	/* 2. get TBG_A clock */
-	tbg = get_tbg_clk(TBG_A_S);
-	if (tbg == 0)
-		return 0;
-
-	return tbg>>1;
-}
diff --git a/arch/arm/cpu/armv8/armadalp/mvebu_gpio.c b/arch/arm/cpu/armv8/armadalp/mvebu_gpio.c
deleted file mode 100644
index 4811cc0..0000000
--- a/arch/arm/cpu/armv8/armadalp/mvebu_gpio.c
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * ***************************************************************************
- * Copyright (C) 2015 Marvell International Ltd.
- * ***************************************************************************
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation, either version 2 of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * ***************************************************************************
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/gpio.h>
-
-/*
- * reset PCIe device
- */
-void mvebu_reset_pcie_dev(void)
-{
-	u32 reg_val;
-
-	/* Set PCIe reset to 0 */
-	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_VAL_REG);
-	reg_val &= ~(1 << MVEBU_GPIO_PCIE_RESET_OFF);
-	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_VAL_REG);
-
-	/* Set to GPIO output mode */
-	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_EN_REG);
-	reg_val |= (1 << MVEBU_GPIO_PCIE_RESET_OFF);
-	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_EN_REG);
-
-	/* Set PCIe to GPIO mode */
-	reg_val = readl(MVEBU_GPIO_SB_SEL_REG);
-	reg_val |= (1 << MVEBU_GPIO_PCIE_EN_OFF);
-	writel(reg_val, MVEBU_GPIO_SB_SEL_REG);
-
-	/* typical delay for NIC to finish reset from NIC specification */
-	udelay(100);
-
-	/* Release PCIe reset */
-	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_VAL_REG);
-	reg_val |= (1 << MVEBU_GPIO_PCIE_RESET_OFF);
-	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_VAL_REG);
-}
-
-/*
- * initialize SB SDIO device
- */
-void mvebu_init_sdio(void)
-{
-	u32 reg_val;
-
-	/* Set SDIO to 0 which is 3.3v */
-	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_VAL_REG);
-	reg_val &= ~(1 << MVEBU_GPIO_SDIO_VOLTAGE_OFF);
-	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_VAL_REG);
-
-	/* Set to GPIO output mode */
-	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_EN_REG);
-	reg_val |= (1 << MVEBU_GPIO_SDIO_VOLTAGE_OFF);
-	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_EN_REG);
-
-	/* Set test pin to SDIO mode */
-	reg_val = readl(MVEBU_GPIO_SB_SEL_REG);
-	reg_val &= ~(1 << MVEBU_GPIO_SB_SDIO_EN_OFF);
-	writel(reg_val, MVEBU_GPIO_SB_SEL_REG);
-}
-
-/*
- * set SB SDIO device
- */
-void mvebu_set_sdio(int voltage)
-{
-	u32 reg_val;
-
-	/* Set SDIO to 0 which is 3.3v */
-	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_VAL_REG);
-	if (MVEBU_GPIO_SDIO_VOLTAGE_1_8V == voltage)
-		reg_val |= (1 << MVEBU_GPIO_SDIO_VOLTAGE_OFF);
-	else
-		reg_val &= ~(1 << MVEBU_GPIO_SDIO_VOLTAGE_OFF);
-	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_VAL_REG);
-}
-
-/*
- * mvebu_init_gpio
- *
- * This function sets GPIO configuration for Armada3700
- * by hardcoded value.
- * And this routine (patch) will be removed (revert),
- * and implemented by MPP/PIN-CTRL driver later.
- *
- */
-void mvebu_init_gpio(void)
-{
-	u32 reg_val;
-
-	/*
-	 * NETA GPIO
-	 * on Palladium, RGMII is used
-	 */
-	reg_val = readl(MVEBU_GPIO_SB_SEL_REG);
-	reg_val = reg_val & (~(1 << MVEBU_GPIO_RGMII_GPIO_EN_OFF));
-	writel(reg_val, MVEBU_GPIO_SB_SEL_REG);
-
-	/*
-	 * I2C, SPI GPIO
-	 */
-	reg_val = readl(MVEBU_GPIO_NB_SEL_REG);
-	/* enable GPIO for I2C */
-	reg_val = reg_val & (~(1 << MVEBU_GPIO_TW1_GPIO_EN_OFF));
-	/* enable GPIO for SPI
-	 * In A3700 Register Spec, it says that In North bridge GPIO configuration,
-	 * bit 18 is for SPI quad mode, but this is not accurate description.
-	 * In fact, bit 18 controls HOLD and WP pins for SPI, which is needed for all
-	 * SPI mode, single, dual, and quad.
-	 */
-	reg_val = reg_val & (~(1 << MVEBU_GPIO_SPI_GPIO_EN_OFF));
-	writel(reg_val, MVEBU_GPIO_NB_SEL_REG);
-
-	/* set hiden GPIO setting for SPI
-	 * in north_bridge_test_pin_out_en register 13804,
-	 * bit 28 is the one which enables CS, CLK pin to be
-	 * output, need to set it to 1.
-	 * normally, it is needed only in UART boot mode,
-	 * but after trying all other modes, it is OK to set it.
-	 * later, we could read the SAR register, and do not
-	 * set it in other boot mode.
-	 */
-	reg_val = readl(MVEBU_GPIO_NB_OUTPUT_EN_HIGH_REG);
-	reg_val = reg_val | (1 << MVEBU_GPIO_NB_OUTPUT_SPI_EN_OFF);
-	writel(reg_val, MVEBU_GPIO_NB_OUTPUT_EN_HIGH_REG);
-
-	/* set SB SDIO to 3.3v by default */
-	mvebu_init_sdio();
-
-	return;
-}
diff --git a/arch/arm/cpu/armv8/armadalp/mvebu_io_addr_dec.c b/arch/arm/cpu/armv8/armadalp/mvebu_io_addr_dec.c
deleted file mode 100644
index ce2b38e..0000000
--- a/arch/arm/cpu/armv8/armadalp/mvebu_io_addr_dec.c
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * ***************************************************************************
- * Copyright (C) 2015 Marvell International Ltd.
- * ***************************************************************************
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation, either version 2 of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * ***************************************************************************
- */
-
-/* #define DEBUG */
-#include <common.h>
-#include <asm/arch-mvebu/mvebu.h>
-#include <asm/arch-mvebu/mbus.h>
-#include <asm/io.h>
-#include <fdtdec.h>
-#include <asm/arch-mvebu/fdt.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-struct dec_win_config {
-	void __iomem *dec_win_base;
-	u32 max_win;
-	u32 max_remap;
-	u32 remap_size;
-	u32 win_offset;
-};
-
-struct io_dec_fdt_info {
-	u32 base;
-	u32 size;
-	u32 flags;
-};
-
-/* There are up to 14 IO unit which need address deocode in Armada-3700 */
-#define IO_UNIT_NUM_MAX		(14)
-struct io_dec_fdt_info __attribute__((section(".data")))io_dec_fdt_arr[IO_UNIT_NUM_MAX];
-
-#define MVEBU_DEC_WIN_CTRL_REG(base, win, off)	(MVEBU_REGS_BASE + base + (win * off))
-#define MVEBU_DEC_WIN_BASE_REG(base, win, off)	(MVEBU_REGS_BASE + base + (win * off) + 0x4)
-#define MVEBU_DEC_WIN_REMAP_REG(base, win, off)	(MVEBU_REGS_BASE + base + (win * off) + 0x8)
-
-#define MVEBU_DEC_WIN_CTRL_SIZE_OFF	(16)
-#define MVEBU_DEC_WIN_CTRL_ATTR_OFF	(8)
-#define MVEBU_DEC_WIN_CTRL_TARGET_OFF	(4)
-#define MVEBU_DEC_WIN_CTRL_EN_OFF	(0)
-#define MVEBU_DEC_WIN_BASE_OFF		(16)
-
-/* set io decode window */
-int set_io_addr_dec(struct mbus_win_map *win_map, struct dec_win_config *dec_win)
-{
-	struct mbus_win *win;
-	int id;
-	u32 ctrl = 0;
-	u32 base = 0;
-
-	/* disable all windows first */
-	for (id = 0; id < dec_win->max_win; id++)
-		writel(0, MVEBU_DEC_WIN_CTRL_REG(dec_win->dec_win_base, id, dec_win->win_offset));
-
-	/* configure eMMC decode windows for DRAM, according to CPU-DRAM
-	 * decode window configurations
-	 */
-	for (id = 0, win = &win_map->mbus_windows[id]; id < win_map->mbus_win_num; id++, win++) {
-		/* set size */
-		ctrl = win->win_size << MVEBU_DEC_WIN_CTRL_SIZE_OFF;
-		/* set attr */
-		ctrl |= win->attribute << MVEBU_DEC_WIN_CTRL_ATTR_OFF;
-		/* set target */
-		ctrl |= win->target << MVEBU_DEC_WIN_CTRL_TARGET_OFF;
-		/* set base */
-		base = win->base_addr << MVEBU_DEC_WIN_BASE_OFF;
-
-		/* set base address*/
-		writel(base, MVEBU_DEC_WIN_BASE_REG(dec_win->dec_win_base, id, dec_win->win_offset));
-		/* set remap window, some unit does not have remap window */
-		if (id < dec_win->max_remap)
-			writel(base, MVEBU_DEC_WIN_REMAP_REG(dec_win->dec_win_base, id, dec_win->win_offset));
-		/* set control register */
-		writel(ctrl, MVEBU_DEC_WIN_CTRL_REG(dec_win->dec_win_base, id, dec_win->win_offset));
-		/* enable the address decode window at last to make it effective */
-		ctrl |= win->enabled << MVEBU_DEC_WIN_CTRL_EN_OFF;
-		writel(ctrl, MVEBU_DEC_WIN_CTRL_REG(dec_win->dec_win_base, id, dec_win->win_offset));
-
-		debug("set_io_addr_dec %d result: ctrl(0x%x) base(0x%x)",
-		      id, readl(MVEBU_DEC_WIN_CTRL_REG(dec_win->dec_win_base, id, dec_win->win_offset)),
-		      readl(MVEBU_DEC_WIN_BASE_REG(dec_win->dec_win_base, id, dec_win->win_offset)));
-		if (id < dec_win->max_remap)
-			debug(" remap(%x)\n",
-			      readl(MVEBU_DEC_WIN_REMAP_REG(dec_win->dec_win_base, id, dec_win->win_offset)));
-		else
-			debug("\n");
-	}
-	return 0;
-}
-
-int init_io_addr_dec(void)
-{
-	int ret = 0;
-	u32 node;
-	u32 count;
-	int index;
-	struct mbus_win_map win_map;
-	struct dec_win_config dec_win;
-	const void *blob = gd->fdt_blob;
-	struct io_dec_fdt_info *fdt_info = io_dec_fdt_arr;
-
-	debug("Initializing MBUS IO address decode windows\n");
-	debug_enter();
-
-	/* fetch CPU-DRAM window mapping information by reading
-	 * CPU-DRAM decode windows (only the enabled ones)
-	 */
-	mbus_win_map_build(&win_map);
-	for (index = 0; index < win_map.mbus_win_num; index++)
-		debug("MBUS DRAM mapping %d base(0x%llx) size(0x%llx) target(%d) attr(%d)\n",
-		      index, (u64)win_map.mbus_windows[index].base_addr, (u64)win_map.mbus_windows[index].win_size,
-		      win_map.mbus_windows[index].target, win_map.mbus_windows[index].attribute);
-
-	/* Get I/O address decoding node from the FDT blob */
-	node = fdt_node_offset_by_compatible(blob, -1, fdtdec_get_compatible(COMPAT_MVEBU_MBUS_IO_DEC));
-	if (node < 0) {
-		error("No I/O address decoding node found in FDT blob\n");
-		return -1;
-	}
-
-	/* Get the array of the windows and fill the map data */
-	count = fdtdec_get_int_array_count(blob, node, "unit_io_decode_info", (u32 *)fdt_info, IO_UNIT_NUM_MAX * 3);
-	if (count <= 0) {
-		debug("no windows configurations found\n");
-		return 0;
-	}
-
-	/* each window has 3 variables in FDT (base, size, flags)
-	 * base: base address of IO decode window
-	 * size: size of IO decode window register in unit of byte
-	 * flags: information about this IO decode window which is combined by IO_ATTR
-	 *     IO_ATTR(max_win, max_remap, remap_size, win_offset) (((max_win) << 24) | ((max_remap) << 16) |
-	 *            ((remap_size) << 8) | (win_offset))
-	 *            max_win: how many decode window that this unit has
-	 *            max_remap: the decode window number including remapping that this unit has
-	 *            remap_size: remap window size in unit of bits, normally should be 32 or 64
-	 *            win_offset: the offset between continuous decode windows with the same unit, typically 0x10
-	 *
-	 * Example in FDT: <0xcb00 0x30 IO_ATTR(3, 0, 32, 0x10)>
-	 */
-	count = count / 3;
-	for (index = 0; index < count; index++, fdt_info++) {
-		dec_win.dec_win_base = (void *)((u64)fdt_info->base);
-		dec_win.max_win = (fdt_info->flags >> 24) & 0xFF;
-		dec_win.max_remap = (fdt_info->flags >> 16) & 0xFF;
-		dec_win.remap_size = (fdt_info->flags >> 8) & 0xFF;
-		dec_win.win_offset = fdt_info->flags & 0xFF;
-
-		/* set I/O address decode window */
-		ret = set_io_addr_dec(&win_map, &dec_win);
-		if (ret) {
-			error("failed to set io address decode\n");
-			break;
-		}
-		debug("set io decode window successfully, base(0x%x) size(0x%x)",
-		      fdt_info->base, fdt_info->size);
-		debug(" max_win(%d) max_remap(%d) remap_size(%d) win_offset(%d)\n",
-		      dec_win.max_win, dec_win.max_remap, dec_win.remap_size, dec_win.win_offset);
-	}
-
-	debug_exit();
-	return ret;
-}
diff --git a/arch/arm/cpu/armv8/armadalp/mvebu_misc_init.c b/arch/arm/cpu/armv8/armadalp/mvebu_misc_init.c
deleted file mode 100644
index 64cd517..0000000
--- a/arch/arm/cpu/armv8/armadalp/mvebu_misc_init.c
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * ***************************************************************************
- * Copyright (C) 2015 Marvell International Ltd.
- * ***************************************************************************
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation, either version 2 of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * ***************************************************************************
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch-mvebu/mvebu.h>
-
-void misc_init_cci400(void)
-{
-	debug_enter();
-
-	/*
-	   CCI-400 enable snoop and dvm on S3 port.
-	   For details see the <CoreLink CCI-400 Cache Coherent Interconnect> document.
-	   bit[0] - Enable issuing of snoop requests from this slave interface.
-	   bit[1] - Enable issuing of DVM message requests from this slave interface
-	   bit[29:2] - Reserved
-	   bit[30] - Slave interface supports snoops
-	   bit[31] - Slave interface supports DVM messages
-	 */
-	writel(0xC0000003, MVEBU_CCI_S3_SNOOP_CTRL_REG);
-
-	/* Add units configuration code here */
-
-	debug_exit();
-}
diff --git a/arch/arm/cpu/armv8/armadalp/psci.S b/arch/arm/cpu/armv8/armadalp/psci.S
deleted file mode 100644
index 4c59cfa..0000000
--- a/arch/arm/cpu/armv8/armadalp/psci.S
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Copyright (C) 2013 - ARM Ltd
- * Author: Marc Zyngier <marc.zyngier@arm.com>
- *
- * Based on code by Carl van Schaik <carl@ok-labs.com>.
- *
- * Copyright (C) 2015 Marvell International Ltd.
- *
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation, either version 2 of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * ***************************************************************************
-*/
-
-#include <config.h>
-#include <linux/linkage.h>
-#include <asm/psci.h>
-#include <asm/gic.h>
-#include <asm/macro.h>
-
-#define MVEBU_CPU_1_RESET_VECTOR 0x14044
-#define MVEBU_CPU_1_RESET_REG 0xD00C
-#define MVEBU_CPU_1_RESET_BIT 31
-#define MVEBU_NB_REGS_BASE 0x13000
-#define MVEBU_WARM_RESET_REG 0x840
-#define MVEBU_WARM_RESET_MAGIC 0x1D1E
-
-/*
-  * Now there is only very limited support for PSCI feature.
-  * We only support wake up CPU1 from CPU0 to test SMP
-  * feature in Kernel.
-  *
-  * TODO: Add the rest of PSCI feature which includes
-  * will be added, including suspend/on any cpu from other
-  * cpu and get affinity_info routine.
-  */
-
-
-.pushsection ._secure.text, "ax"
-
-enable_affinity:
-	/* Activate Affinity in CA-53 configuration
-	 * Enable the SMPEN bit in CPUECTLR_EL1 */
-	mrs x0, S3_1_c15_c2_1
-	orr x0, x0, #0x40
-	msr S3_1_c15_c2_1, x0
-	ret
-
-.globl	psci_arch_init
-psci_arch_init:
-	add     x29, x30, 0 /* keep return address */
-	bl	enable_affinity
-	bl	psci_build_stack
-	ret	x29
-
-psci_build_stack:
-
-	mrs     x5, SCR_EL3
-	bic	x5, x5, #1	/* Secure mode */
-	msr	SCR_EL3, x5
-	isb
-
-	mrs 	x4, MPIDR_EL1	/* get current CPU - Use affinity level 1 */
-	asr 	x4, x4, #8
-	and 	x4, x4, #0xff
-
-	mov	x5, #400		/* 1kB of stack per CPU */
-	mul	x4, x4, x5
-
-	adr	x5, text_end		/* end of text */
-	add	x5, x5, #0x2000		/* Skip two pages */
-	lsr	x5, x5, #12		/* Align to start of page */
-	lsl	x5, x5, #12
-	sub	sp, x5, x4		/* here's our stack! */
-
-	ret
-
-.globl	psci_0_2_system_reset
-psci_0_2_system_reset:
-	mov	x0, #(MVEBU_REGS_BASE)
-	add	x3, x0, #(MVEBU_NB_REGS_BASE)
-	add	x3, x3, #(MVEBU_WARM_RESET_REG)
-	mov	w0, #(MVEBU_WARM_RESET_MAGIC)
-	str	w0, [x3]
-	ret
-
-	/* x1 = target CPU */
-	/* x2 = target PC */
-.globl	psci_0_2_cpu_on_64
-psci_0_2_cpu_on_64:
-
-	adr	x0, _target_pc
-	str	x2, [x0]
-
-	dsb     sy
-
-	mov	x0, #(MVEBU_REGS_BASE)
-
-	/* set the cpu_1 start address */
-	ldr x3, =MVEBU_CPU_1_RESET_VECTOR
-	add	x3, x0, x3
-	adr x2, _armadalp_cpu_entry
-	lsr x2, x2, #2 /* 0x14044 is bit[33:2] of start address	 */
-	str 	w2, [x3]
-
-	/* get the cpu out of reset */
-	ldr x3, =MVEBU_CPU_1_RESET_REG
-	add	x3, x0, x3
-	mov 	w4, #1
-	lsl w4, w4, #MVEBU_CPU_1_RESET_BIT
-	mvn		w5, w4
-	ldr w2, [x3]
-	and	w2, w2, w5
-	str w2, [x3]
-	ldr w2, [x3]
-	orr 	w2, w2, w4
-	str 	w2, [x3]
-
-	/* return success */
-	mov	x0, #ARM_PSCI_RET_SUCCESS	/* Return PSCI_RET_SUCCESS */
-	ret
-
-.global _armadalp_cpu_entry
-_armadalp_cpu_entry:
-
-	bl	enable_affinity
-
-	isb
-
-	/*
-	 * Could be EL3/EL2/EL1, Initial State:
-	 * Little Endian, MMU Disabled, i/dCache Disabled
-	 */
-	adr	x0, vectors
-	switch_el x1, 3f, 2f, 1f
-3:	msr	vbar_el3, x0
-	mrs	x0, scr_el3
-	orr	x0, x0, #0xf			/* SCR_EL3.NS|IRQ|FIQ|EA */
-	msr	scr_el3, x0
-	msr	cptr_el3, xzr			/* Enable FP/SIMD */
-	ldr	x0, =COUNTER_FREQUENCY
-	msr	cntfrq_el0, x0			/* Initialize CNTFRQ */
-	b	0f
-2:	msr	vbar_el2, x0
-	mov	x0, #0x33ff
-	msr	cptr_el2, x0			/* Enable FP/SIMD */
-	b	0f
-1:	msr	vbar_el1, x0
-	mov	x0, #3 << 20
-	msr	cpacr_el1, x0			/* Enable FP/SIMD */
-0:
-
-#if defined(CONFIG_GICV3)
-	ldr	x0, =GICR_BASE
-	bl	gic_init_secure_percpu
-#elif defined(CONFIG_GICV2)
-	ldr	x0, =GICD_BASE
-	ldr	x1, =GICC_BASE
-	bl	gic_init_secure_percpu
-#endif
-
-	bl	psci_build_stack
-
-	bl	armv8_switch_to_el2
-#ifdef CONFIG_ARMV8_SWITCH_TO_EL1
-	bl	armv8_switch_to_el1
-#endif
-
-	adr	x0, _target_pc
-	ldr x0, [x0]
-	br	x0
-
-	/* 64 bit alignment for elements accessed as data */
-	.align 4
-_target_pc:
-	.quad 0x0
-
-text_end:
-	.popsection
diff --git a/arch/arm/cpu/armv8/armadalp/soc-init.c b/arch/arm/cpu/armv8/armadalp/soc-init.c
deleted file mode 100644
index 2938228..0000000
--- a/arch/arm/cpu/armv8/armadalp/soc-init.c
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
-* ***************************************************************************
-* Copyright (C) 2015 Marvell International Ltd.
-* ***************************************************************************
-* This program is free software: you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the Free
-* Software Foundation, either version 2 of the License, or any later version.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program.  If not, see <http://www.gnu.org/licenses/>.
-* ***************************************************************************
-*/
-
-#define DEBUG
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch-mvebu/soc.h>
-#include <netdev.h>
-#include <asm/arch/mbus_reg.h>
-#include <asm/arch-mvebu/mbus.h>
-#include <asm/arch-mvebu/pinctl.h>
-#include <i2c.h>
-#include <libfdt.h>
-
-/* IO expander I2C device */
-#define I2C_IO_EXP_ADDR	0x22
-#define I2C_IO_CFG_REG_0	0x6
-#define I2C_IO_DATA_OUT_REG_0	0x2
-#define I2C_IO_REG_0_SATA_OFF	2
-#define I2C_IO_REG_0_USB_H_OFF	1
-
-/* NB warm reset */
-#define MVEBU_NB_WARM_RST_REG	(MVEBU_GPIO_NB_REG_BASE + 0x40)
-/* NB warm reset magic number, write it to MVEBU_GPIO_NB_RST_REG triggers warm reset */
-#define MVEBU_NB_WARM_RST_MAGIC_NUM	(0x1d1e)
-
-int soc_early_init_f(void)
-{
-#ifdef CONFIG_MVEBU_PINCTL
-	mvebu_pinctl_probe();
-#endif
-
-	return 0;
-}
-
-int soc_get_rev(void)
-{
-	/* This should read the soc rev from some register*/
-	return 0;
-}
-
-int soc_get_id(void)
-{
-	/* TO-DO, get soc ID from PCIe register */
-	/* in ArmadaLP, there is no device ID register, like A38x,
-	    it needs to be got from PCIe register, like A370 and AXP */
-	u32 id = 0x9991;
-	return id;
-}
-
-void soc_init(void)
-{
-	/* Do early SOC specific init here */
-
-	/* now there is no timer/MPP driver,
-	  * currently we put all this kind of
-	  * configuration here, and will remove
-	  * this after official driver is ready
-	  */
-#ifdef CONFIG_PALLADIUM
-
-#ifdef CONFIG_I2C_MV
-	/* 0xD0013830[10] = 1'b0 (select GPIO pins to use for I2C_1) */
-	writel((readl(0xd0013830) & ~(1 << 10)), 0xd0013830);
-#endif /* CONFIG_I2C_MV */
-
-#endif /* CONFIG_PALLADIUM */
-	return;
-}
-
-#ifdef CONFIG_MVNETA
-/**
- * cpu_eth_init()
- *	invoke mvneta_initialize for each port, which is the initialization
- *	entrance of mvneta driver.
- *
- * Input:
- *	bis - db_info
- *
- * Return:
- *	0 - cool
- */
-int cpu_eth_init(bd_t *bis)
-{
-	/* init neta module */
-	if (1 != mvneta_initialize(bis)) {
-		error("failed to init mvneta\n");
-		return 1;
-	}
-	/* in ArmadaLP, there is a new register, internal Register Base Address, for GBE to
-	    access other internal Register. since GBE is on South bridge, not the same island
-	    as CPU, here we set internal reg base value 0xf100000 into it.
-	    NETA drvier initialization does not rely on this configuration, so do it after
-	    mvneta_initialize() */
-	writel(MVEBU_REGS_BASE, MVEBU_ARLP_GBE0_INTERNAL_REG_BASE);
-	writel(MVEBU_REGS_BASE, MVEBU_ARLP_GBE1_INTERNAL_REG_BASE);
-
-	return 0;
-}
-#endif /* CONFIG_MVNETA */
-
-#ifdef CONFIG_I2C_MV
-void i2c_clk_enable(void)
-{
-	/* i2c is enabled by default,
-	  * but need this empty routine
-	  * to pass compilation.
-	*/
-	return;
-}
-
-#endif /* CONFIG_I2C_MV */
-
-int dram_init(void)
-{
-#ifdef CONFIG_PALLADIUM
-	/* NO DRAM init sequence in Pallaidum, so set static DRAM size of 256MB */
-	gd->ram_size = 0x20000000;
-#else
-	gd->ram_size = 0;
-
-	/* DDR size has been read from dts DDR node in SPL
-	 * ddr driver and pass to u-boot. */
-	gd->ram_size = (get_info(DRAM_CS0_SIZE) << 20);
-
-	if (gd->ram_size == 0) {
-		error("No DRAM banks detected");
-		return 1;
-	}
-#endif
-
-	return 0;
-}
-
-void reset_cpu(ulong ignored)
-{
-	/* write magic number of 0x1d1e to North Bridge Warm Reset register
-	   to trigger warm reset */
-	writel(MVEBU_NB_WARM_RST_MAGIC_NUM, MVEBU_NB_WARM_RST_REG);
-}
-
-#ifdef CONFIG_SCSI_AHCI_PLAT
-void board_ahci_power_on(void)
-{
-/* This I2C IO expander configuration is board specific,
- * and adequate only to Marvell A3700 DB board
- */
-#ifdef CONFIG_DEVEL_BOARD
-	int ret;
-	unsigned char buffer[1];
-
-	/* Enable power of SATA by set IO expander via I2C,
-	 * to set corresponding bit to output mode to enable the power for SATA.
-	 */
-	ret = i2c_read(I2C_IO_EXP_ADDR, I2C_IO_CFG_REG_0, sizeof(unsigned char), buffer, sizeof(buffer));
-	if (ret)
-		error("failed to read IO expander value via I2C\n");
-
-	buffer[0] &= ~(1 << I2C_IO_REG_0_SATA_OFF);
-	ret = i2c_write(I2C_IO_EXP_ADDR, I2C_IO_CFG_REG_0, sizeof(unsigned char), buffer, sizeof(buffer));
-	if (ret)
-		error("failed to set IO expander via I2C\n");
-#endif /* CONFIG_DEVEL_BOARD */
-}
-#endif /* CONFIG_SCSI_AHCI_PLAT */
-
-#ifdef CONFIG_USB_XHCI
-/* Set USB VBUS signals (via I2C IO expander/GPIO) as output and set output value as enabled */
-void board_usb_vbus_init(void)
-{
-#ifdef CONFIG_DEVEL_BOARD
-/* This I2C IO expander configuration is board specific, only to Marvell A3700 DB board.
- * (I2C device at address 0x22, Register 0, BIT 1) */
-	int ret_read, ret_write;
-	unsigned char cfg_val[1], out_val[1];
-	const void *blob = gd->fdt_blob;
-
-	/* Make sure board is supported (currently only A3700-DB is supported) */
-	if (fdt_node_check_compatible(blob, 0, "marvell,armada-lp-db0") != 0) {
-		error("Missing USB VBUS power configuration for current board.\n");
-		return;
-	}
-
-	printf("Enable USB VBUS.\n");
-
-	/* initialize I2C */
-	init_func_i2c();
-
-	/* Read configuration (direction) and set VBUS pin as output (reset pin = output) */
-	ret_read = i2c_read(I2C_IO_EXP_ADDR, I2C_IO_CFG_REG_0, sizeof(unsigned char), cfg_val, sizeof(cfg_val));
-	cfg_val[0] &= ~(1 << I2C_IO_REG_0_USB_H_OFF);
-	ret_write = i2c_write(I2C_IO_EXP_ADDR, I2C_IO_CFG_REG_0, sizeof(unsigned char),
-			cfg_val, sizeof(cfg_val));
-	if (ret_read || ret_write)
-		error("failed to set USB VBUS configuration on I2C IO expander\n");
-
-	/* Read VBUS output value, and disable it */
-	ret_read = i2c_read(I2C_IO_EXP_ADDR, I2C_IO_DATA_OUT_REG_0, sizeof(unsigned char), out_val, sizeof(out_val));
-	out_val[0] &= ~(1 << I2C_IO_REG_0_USB_H_OFF);
-
-	ret_write = i2c_write(I2C_IO_EXP_ADDR, I2C_IO_DATA_OUT_REG_0, sizeof(unsigned char), out_val, sizeof(out_val));
-	if (ret_read || ret_write)
-		error("failed to lower USB VBUS power on I2C IO expander\n");
-
-	/* required delay for configuration to settle - must wait for power on port is disabled
-	 * in case VBUS signal was high, required 3 seconds delay to let VBUS signal fully settle down */
-	udelay(3000000);
-
-	/* Enable VBUS power: Set output value of VBUS pin as enabled */
-	out_val[0] |= (1 << I2C_IO_REG_0_USB_H_OFF);
-
-	ret_write = i2c_write(I2C_IO_EXP_ADDR, I2C_IO_DATA_OUT_REG_0, sizeof(unsigned char), out_val, sizeof(out_val));
-	if (ret_write)
-		error("failed to raise USB VBUS power on I2C IO expander\n");
-
-	udelay(500000); /* required delay to let output value settle up*/
-
-#endif /* CONFIG_DEVEL_BOARD */
-
-}
-#endif /* CONFIG_USB_XHCI */
-
-/************************************************************************
-   Function:  mvebu_is_in_recovery_mode
-
-   The function checks if the system currently boots into recovery mode.
-   The recovery mode is intended to bring up bricked board using UART
-   port as the boot device. This mode is either trigered by escape
-   sequence or by reset sample jumpers.
-
-   Return - 1 if recovery mode is active or 0 otherwise
-************************************************************************/
-bool mvebu_is_in_recovery_mode(void)
-{
-	u32 regval;
-
-	/* Check if we are in UART recovery boot mode - currently selected by botstrap */
-	regval = (readl(MVEBU_TEST_PIN_LATCH_N) & MVEBU_BOOTMODE_MASK) >> MVEBU_BOOTMODE_OFFS;
-	return regval == MVEBU_BOOTMODE_UART;
-}
diff --git a/arch/arm/cpu/armv8/armadalp/spl.c b/arch/arm/cpu/armv8/armadalp/spl.c
deleted file mode 100644
index 2fa37f5..0000000
--- a/arch/arm/cpu/armv8/armadalp/spl.c
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * ***************************************************************************
- * Copyright (C) 2015 Marvell International Ltd.
- * ***************************************************************************
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation, either version 2 of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * ***************************************************************************
- */
-
-#include <common.h>
-#include <asm/arch-mvebu/comphy.h>
-#include <asm/arch-mvebu/io_addr_dec.h>
-#include <asm/arch/clock.h>
-#include <asm/arch-mvebu/mbus.h>
-#include <asm/arch/gpio.h>
-#include <asm/arch-mvebu/mvebu_misc.h>
-#include <asm/arch-mvebu/ddr.h>
-#include <asm/arch-mvebu/fdt.h>
-#include <spl.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-void (*ptr_uboot_start)(void);
-
-void board_init_f(ulong silent)
-{
-	gd = &gdata;
-	gd->baudrate = CONFIG_BAUDRATE;
-
-	/* Silence flag is not supported by CM3 WTP BootROM */
-	gd->flags &= ~GD_FLG_SILENT;
-
-	/* isetup_fdt set default FDT to work with:
-	   - customer/regular mode: point to the defined
-	     FDT by CONFIG_DEFAULT_DEVICE_TREE.
-	   - Marvell multi FDT mode: set the first compiled relevant device
-	     tree for the SoC, required for i2c initialization to read EEPROM data */
-	setup_fdt();
-
-/* multi FDT feature reads eeprom, which requires I2C support
- * but for Armada3700, I2C feature depends on GPIO configuration,
- * so mvebu_setup_fdt need to be invoked after it.
- *
- * but GPIO driver also need to read FDT file, for reg base and
- * other configurations. For reg base it is OK, since all the fdt
- * files for all the boards should have the same value.
- *
- * as far as the I2C related GPIO settings, we will demand from HW that
- * all Marvell boards will use the same set of I2C pins setup.
- *
- * GPIO need to be split into two stages: static shared (for I2C),
- * and then dynamic-fdt-based. the first step will be done before
- * mvebu_setup_fdt(), and the second one will be after it.
- */
-#ifdef CONFIG_MVEBU_SPL_A3700_GPIO
-	mvebu_init_gpio();
-#endif
-
-#ifdef CONFIG_BOARD_CONFIG_EEPROM
-	cfg_eeprom_init();
-#endif
-
-#ifdef CONFIG_MULTI_DT_FILE
-	/* Update gd->fdt_blob according to multi-fdt data in eeprom */
-	mvebu_setup_fdt();
-#endif
-
-	/* UART1 and UART2 clocks are sourced from XTAL by default
-	* (see RD0012010 register for the details). Additionally the GPIO
-	* control (RD0013830) sets the GPIO1[26:25] as the UART1 pins by default.
-	* Therefore it is safe to start using UART before call to early_spl_init()
-	*/
-	preloader_console_init();
-
-	/* Clock should be enabeld before initialize the I/O units */
-#ifdef CONFIG_MVEBU_A3700_CLOCK
-	init_clock();
-#endif
-
-#ifdef CONFIG_MVEBU_A3700_MISC_INIT
-	misc_init_cci400();
-#endif
-
-	/* Init all relevant drivers (e.g. DDR, comphy...) */
-#ifdef CONFIG_MVEBU_COMPHY_SUPPORT
-	if (comphy_init(gd->fdt_blob))
-		error("COMPHY initialization failed\n");
-#endif
-#ifdef CONFIG_MVEBU_SPL_DDR_SUPPORT
-	mvebu_dram_init(gd->fdt_blob);
-#endif
-
-#ifdef CONFIG_MVEBU_MBUS
-	init_mbus();
-#endif
-
-#ifdef CONFIG_MVEBU_A3700_IO_ADDR_DEC
-	init_io_addr_dec();
-#endif
-
-	debug("SPL processing done. Jumping to u-boot\n\n");
-	ptr_uboot_start = 0;
-	/* Jump from SPL to u-boot start address */
-	ptr_uboot_start();
-}
-
diff --git a/arch/arm/cpu/mvebu-common/Kconfig b/arch/arm/cpu/mvebu-common/Kconfig
index 7baa1b2..7fbe4a9 100644
--- a/arch/arm/cpu/mvebu-common/Kconfig
+++ b/arch/arm/cpu/mvebu-common/Kconfig
@@ -1,7 +1,7 @@
 
 source "arch/arm/cpu/armv8/armada8k/Kconfig"
 source "arch/arm/cpu/armv7/armada38x/Kconfig"
-source "arch/arm/cpu/armv8/armadalp/Kconfig"
+source "arch/arm/cpu/armv8/armada3700/Kconfig"
 
 config MVEBU
 	bool "Support MVEBU devices"
diff --git a/arch/arm/include/asm/arch-armada3700/board-info.h b/arch/arm/include/asm/arch-armada3700/board-info.h
new file mode 100644
index 0000000..0487267
--- /dev/null
+++ b/arch/arm/include/asm/arch-armada3700/board-info.h
@@ -0,0 +1,52 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+/* Armada3700 Marvell boards */
+#include <dt-bindings/multi-fdt/multi-fdt.h>
+
+/*
+	ARMAMA3700_MARVELL_BOARD_ID_BASE = 0x10, for multi-fdt feature,
+	each Soc takes 0x10 boards that starts from 0x10, A8K has taken
+	0x10 to 0x1f, but since A8K and A3700 would not be compiled
+	together, to align with A8K, A3700 should also take 0x10 to 0x1f.
+	And as A3700 DB, it is the first board, should take board_id as 0x10.
+*/
+#define ARMAMA3700_MARVELL_BOARD_ID_BASE	 A3700_DB_ID
+#define ARMAMA3700_DB			(ARMAMA3700_MARVELL_BOARD_ID_BASE + 0)
+#define ARMAMA3700_MARVELL_MAX_BOARD_ID	(ARMAMA3700_MARVELL_BOARD_ID_BASE + 1)
+#define ARMAMA3700_MARVELL_BOARD_NUM	(ARMAMA3700_MARVELL_MAX_BOARD_ID - ARMAMA3700_MARVELL_BOARD_ID_BASE)
+
+#define MARVELL_BOARD_ID_BASE		ARMAMA3700_MARVELL_BOARD_ID_BASE
+#define MV_MAX_MARVELL_BOARD_ID		ARMAMA3700_MARVELL_MAX_BOARD_ID
+#define MV_MARVELL_BOARD_NUM		ARMAMA3700_MARVELL_BOARD_NUM
+#define MV_DEFAULT_BOARD_ID		ARMAMA3700_DB
+
+#define BOARD_DEV_TWSI_INIT_EEPROM 0x57
+#define MULTI_FDT_EEPROM_ADDR_LEN 2
+
+/*
+	fdt_config_id is ID for each dts for a certain board.
+	It starts from 1.
+	+ arch/arm/dts/armada-lp-db.dts, board_id = A3700_DB_CONFIG_ID_USB3..
+	+ arch/arm/dts/armada-lp-db-sgmii1.dts, board_id = A3700_DB_CONFIG_ID_SGMII1.
+*/
+#define DEFAULT_FDT_CONFIG_ID	A3700_DB_CONFIG_ID_USB3
+
+#define DEFAULT_FDT_PER_BOARD { \
+	DEFAULT_FDT_CONFIG_ID,	/* default fdt_config_id for armada-3700-db board */	\
+}
diff --git a/arch/arm/include/asm/arch-armada3700/clock.h b/arch/arm/include/asm/arch-armada3700/clock.h
new file mode 100644
index 0000000..8abf1f3
--- /dev/null
+++ b/arch/arm/include/asm/arch-armada3700/clock.h
@@ -0,0 +1,580 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+#ifndef _ARMADALP_CLOCK_H_
+#define _ARMADALP_CLOCK_H_
+
+/* Spread Spectrum Clock */
+#undef MVEBU_A3700_ENABLE_SSC
+
+#ifdef MVEBU_A3700_ENABLE_SSC
+/* In order to use the SSC function, the KVCO must be operated above 2 GHz */
+#define MVEBU_KVCO_MIN		2000
+#else
+#define MVEBU_KVCO_MIN		1200
+#endif /* MVEBU_A3700_ENABLE_SSC */
+
+#define MVEBU_KVCO_MAX		3000
+
+/****************/
+/* North Bridge */
+/****************/
+#define MVEBU_NORTH_BRG_PLL_BASE		(MVEBU_NORTH_CLOCK_REGS_BASE + 0x200)
+#define MVEBU_NORTH_BRG_TBG_CFG			(MVEBU_NORTH_BRG_PLL_BASE + 0x0)
+#define MVEBU_NORTH_BRG_TBG_CTRL0		(MVEBU_NORTH_BRG_PLL_BASE + 0x4)
+#define MVEBU_NORTH_BRG_TBG_CTRL1		(MVEBU_NORTH_BRG_PLL_BASE + 0x8)
+#define MVEBU_NORTH_BRG_TBG_CTRL2		(MVEBU_NORTH_BRG_PLL_BASE + 0xC)
+#define MVEBU_NORTH_BRG_TBG_CTRL3		(MVEBU_NORTH_BRG_PLL_BASE + 0x10)
+#define MVEBU_NORTH_BRG_TBG_CTRL4		(MVEBU_NORTH_BRG_PLL_BASE + 0x14)
+#define MVEBU_NORTH_BRG_TBG_CTRL5		(MVEBU_NORTH_BRG_PLL_BASE + 0x18)
+#define MVEBU_NORTH_BRG_TBG_CTRL6		(MVEBU_NORTH_BRG_PLL_BASE + 0x1C)
+#define MVEBU_NORTH_BRG_TBG_CTRL7		(MVEBU_NORTH_BRG_PLL_BASE + 0x20)
+#define MVEBU_NORTH_BRG_TBG_CTRL8		(MVEBU_NORTH_BRG_PLL_BASE + 0x30)
+
+#define MVEBU_NORTH_CLOCK_TBG_SELECT_REG	(MVEBU_NORTH_CLOCK_REGS_BASE + 0x0)
+#define NB_CLK_TBG_SEL_MASK_ALL			(0x3F << 26)
+
+/* north bridge clock divider select registers */
+#define MVEBU_NORTH_CLOCK_DIVIDER_SELECT0_REG	(MVEBU_NORTH_CLOCK_REGS_BASE + 0x4)
+#define NB_CLK_DIV0_MASK_ALL			(BIT31 | (0x3 << 26) | BIT19 | (0x3F << 6))
+
+#define MVEBU_NORTH_CLOCK_DIVIDER_SELECT1_REG	(MVEBU_NORTH_CLOCK_REGS_BASE + 0x8)
+#define NB_CLK_DIV1_MASK_ALL			((0x3 << 30) | (0x7 << 21))
+
+#define MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG	(MVEBU_NORTH_CLOCK_REGS_BASE + 0xC)
+#define NB_CLK_DIV2_MASK_ALL			(BIT31 | (0xF << 3))
+#define CPU_CNT_CLK_DIV_SEL_OFFS		(27)
+
+/* north bridge clock source register */
+#define MVEBU_NORTH_CLOCK_SELECT_REG		(MVEBU_NORTH_CLOCK_REGS_BASE + 0x10)
+#define NB_CLK_SEL_MASK_ALL			((0xFFFF << 16) | BIT14)
+
+/* north bridge clock enable register */
+#define MVEBU_NORTH_CLOCK_ENABLE_REG		(MVEBU_NORTH_CLOCK_REGS_BASE + 0x14)
+#define NB_ALL_CLK_ENABLE			(0x0)
+
+/****************/
+/* South Bridge */
+/****************/
+
+/* south bridge clock enable register */
+#define MVEBU_SOUTH_CLOCK_TBG_SELECT_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x0)
+#define SB_CLK_TBG_SEL_MASK_ALL			((0x3FF << 22) | (0x3 << 12) | 0x3F)
+#define GBE_125_TBG_SEL_OFFS			(10)
+
+#define MVEBU_SOUTH_CLOCK_DIVIDER_SELECT0_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x4)
+#define SB_CLK_DIV0_MASK_ALL			((0x1F << 27) | 0x7)
+#define AXI_CLK_PRSCL1_OFFS			(24)
+#define AXI_CLK_PRSCL2_OFFS			(21)
+#define USB32_SS_SYS_CLK_PRSCL1_OFFS		(18)
+#define USB32_SS_SYS_CLK_PRSCL2_OFFS		(15)
+#define USB32_USB2_SYS_CLK_PRSCL1_OFFS		(12)
+#define USB32_USB2_SYS_CLK_PRSCL2_OFFS		(9)
+
+#define MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x8)
+#define SB_CLK_DIV1_MASK_ALL			((0xFF << 24) | (0x7 << 15) | 0x3F)
+#define GBE_125_CLK_PRSCL_MASK			(0x7)
+#define GBE_125_CLK_PRSCL1_OFF			(9)
+#define GBE_125_CLK_PRSCL2_OFF			(6)
+
+#define MVEBU_SOUTH_CLOCK_DIVIDER_SELECT2_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0xC)
+#define SB_CLK_DIV2_MASK_ALL			((0xFFFFF << 12) | 0x3F)
+
+/* south bridge clock source register */
+#define MVEBU_SOUTH_CLOCK_SELECT_REG		(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x10)
+#define SB_AXI_CLK_SEL_OFFS			(10)
+#define USB32_SS_SYS_CLK_SEL_OFFS		(9)
+#define USB32_USB2_SYS_CLK_SEL_OFFS		(8)
+#define SDIO_CLK_SEL_OFFS			(7)
+#define GBE_CORE_CLK_SEL_OFFS			(5)
+#define GBE_125_CLK_SEL_OFFS			(3)
+#define GBE_50_CLK_SEL_OFFS			(1)
+
+
+/* south bridge clock enable register */
+#define MVEBU_SOUTH_CLOCK_ENABLE_REG		(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x14)
+/* (GBE0 and GBE1 have reversed logic) */
+#define SB_ALL_CLK_ENABLE			(BIT19 | BIT20)
+
+/* AVS */
+#define MVEBU_AVS_CTRL_0			(MVEBU_AVS_REGS_BASE)
+#define AVS_SOFT_RESET				(BIT31)
+#define AVS_ENABLE				(BIT30)
+#define AVS_SEL_VSENCE0				(BIT28)
+#define AVS_SPEED_TARGET_MASK			(0x0000FFFF)
+#define AVS_HIGH_VDD_LIMIT_OFFS			(16)
+#define AVS_LOW_VDD_LIMIT_OFFS			(22)
+#define AVS_VDD_LIMIT_MASK			(0x3F)
+#define AVS_VDD_MIN				(0x0)	/* 640 mV */
+#define AVS_VDD_MAX				(0x33)	/* 1342 mV */
+
+/* The AVS voltage formula:  AVSmv = (1.05/0.9)*(640 + field_val * 10) */
+#define AVS_VDD_VAL(mv)				((((mv) * 90)/105 - 640)/10)
+#define AVS_VDD_800_MHZ_MV			(1150)	/* mV for CPU >= 800 MHz */
+#define AVS_VDD_600_MHZ_MV			(1100)	/* mV for CPU 600 MHz */
+
+
+enum a3700_clock_src {
+	TBG_A,
+	TBG_B
+};
+
+enum a3700_clock_line {
+	TBG_A_P = 0,
+	TBG_B_P = 1,
+	TBG_A_S = 2,
+	TBG_B_S = 3
+};
+
+/*
+ * North Bridge Clocks
+ */
+/* North Bridge clock line selectors (0x13000) */
+struct a3700_nb_clock_sel {
+	enum a3700_clock_line mmc_pclk_sel;		/* [1:0] */
+	enum a3700_clock_line sata_host_pclk_sel;	/* [3:2] */
+	enum a3700_clock_line sec_at_pclk_sel;		/* [5:4] */
+	enum a3700_clock_line sec_dap_pclk_sel;		/* [7:6] */
+	enum a3700_clock_line tsecm_pclk_sel;		/* [9:8] */
+	enum a3700_clock_line setm_tmx_pclk_sel;	/* [11:10] */
+	enum a3700_clock_line sqf_pclk_sel;		/* [13:12] */
+	enum a3700_clock_line pwm_pclk_sel;		/* [15:14] */
+	enum a3700_clock_line ddr_fclk_pclk_sel;	/* [17:16] */
+	enum a3700_clock_line trace_pclk_sel;		/* [19:18] */
+	enum a3700_clock_line counter_pclk_sel;		/* [21:20] */
+	enum a3700_clock_line a53_cpu_pclk_sel;		/* [23:22] */
+	enum a3700_clock_line eip97_pclk_sel;		/* [25:24] */
+};
+
+/* North Bridge clock divider 0 (0x13004) */
+struct a3700_nb_clock_div_0 {
+	u8 pwm_clk_prscl2;	/* [2:0] */
+	u8 pwm_clk_prscl1;	/* [5:3] */
+	u8 ddr_fclk_clk_prscl2;	/* [14:12] */
+	u8 ddr_fclk_clk_prscl1;	/* [17:15] */
+	u8 ddr_phy_mck_div_sel;	/* [18] */
+	u8 trace_div_sel;	/* [22:20] */
+	u8 counter_clk_prscl;	/* [25:23] */
+	u8 a53_cpu_clk_prscl;	/* [30:28] */
+};
+
+/* North Bridge clock divider 1 (0x13008) */
+struct a3700_nb_clock_div_1 {
+	u8 sec_at_clk_prscl2;	/* [2:0] */
+	u8 sec_at_clk_prscl1;	/* [5:3] */
+	u8 sec_dap_clk_prscl2;	/* [8:6] */
+	u8 sec_dap_clk_prscl1;	/* [11:9] */
+	u8 tsecm_clk_prscl2;	/* [14:12] */
+	u8 tsecm_clk_prscl1;	/* [17:15] */
+	u8 setm_tmx_clk_prscl;	/* [20:18] */
+	u8 sqf_clk_prscl2;	/* [26:24] */
+	u8 sqf_clk_prscl1;	/* [29:27] */
+};
+
+/* North Bridge clock divider 2 (0x1300C) */
+struct a3700_nb_clock_div_2 {
+	u8 wc_ahb_div_sel;	/* [2:0] */
+	u8 sata_h_clk_prscl2;	/* [9:7] */
+	u8 sata_h_clk_prscl1;	/* [12:10] */
+	u8 mmc_clk_prscl2;	/* [15:13] */
+	u8 mmc_clk_prscl1;	/* [18:16] */
+	u8 eip97_clk_prscl2;	/* [21:19] */
+	u8 eip97_clk_prscl1;	/* [24:22] */
+	u8 atb_clk_div_sel;	/* [26:25] */
+	u8 cpu_cnt_clk_div_sel;	/* [28:27] */
+	u8 plkdbg_clk_div_sel;	/* [30:29] */
+};
+
+/* North Bridge clock configuration */
+struct a3700_nb_clock_cfg {
+	struct a3700_nb_clock_sel	clock_sel;
+	struct a3700_nb_clock_div_0	div0;
+	struct a3700_nb_clock_div_1	div1;
+	struct a3700_nb_clock_div_2	div2;
+};
+
+/*
+ * South Bridge Clocks
+ */
+ /* South Bridge clock line selectors (0x18000) */
+struct a3700_sb_clock_sel {
+	enum a3700_clock_line gbe_50_pclk_sel;		/* [7:6] */
+	enum a3700_clock_line gbe_core_pclk_sel;	/* [9:8] */
+	enum a3700_clock_line gbe_125_pclk_sel;		/* [11:10] */
+	enum a3700_clock_line sdio_pclk_sel;		/* [15:14] */
+	enum a3700_clock_line usb32_usb2_sys_pclk_sel;	/* [17:16] */
+	enum a3700_clock_line usb32_ss_sys_pclk_sel;	/* [19:18] */
+	enum a3700_clock_line sb_axi_pclk_sel;		/* [21:20] */
+};
+
+/* South Bridge clock divider 0 (0x18004) */
+struct a3700_sb_clock_div_0 {
+	u8 sdio_clk_prscl2;		/* [5:3] */
+	u8 sdio_clk_prscl1;		/* [8:6] */
+	u8 usb32_usb2_sys_clk_prscl2;	/* [11:9] */
+	u8 usb32_usb2_sys_clk_prscl1;	/* [14:12] */
+	u8 usb32_ss_sys_clk_prscl2;	/* [17:15] */
+	u8 usb32_ss_sys_clk_prscl1;	/* [20:18] */
+	u8 sb_axi_clk_prscl2;		/* [23:21] */
+	u8 sb_axi_clk_prscl1;		/* [24:24] */
+};
+
+/* South Bridge clock divider 1 (0x18008) */
+struct a3700_sb_clock_div_1 {
+	u8 gbe_125_clk_prscl2;		/* [8:6] */
+	u8 gbe_125_clk_prscl1;		/* [11:9] */
+	u8 gbe_bm_core_clk_div2_sel;	/* [12] */
+	u8 gbe1_core_clk_div2_sel;	/* [13] */
+	u8 gbe0_core_clk_div2_sel;	/* [14] */
+	u8 gbe_core_clk_prscl2;		/* [20:18] */
+	u8 gbe_core_clk_prscl1;		/* [23:21] */
+};
+
+/* South Bridge clock divider 2 (0x1800C) */
+struct a3700_sb_clock_div_2 {
+	u8 gbe_50_clk_prscl2;		/* [8:6] */
+	u8 gbe_50_clk_prscl1;		/* [11:9] */
+};
+
+/* South Bridge clock configuration */
+struct a3700_sb_clock_cfg {
+	struct a3700_sb_clock_sel	clock_sel;
+	struct a3700_sb_clock_div_0	div0;
+	struct a3700_sb_clock_div_1	div1;
+	struct a3700_sb_clock_div_2	div2;
+};
+
+struct a3700_tbg_cfg {
+	u32	kvco_mhz;
+	u32	se_vcodiv;
+	u32	diff_vcodiv;
+};
+
+/* System-wide clock configuration */
+struct a3700_clock_cfg {
+	u32				cpu_freq_mhz;
+	u32				ddr_freq_mhz;
+	struct a3700_tbg_cfg		tbg_a;
+	struct a3700_tbg_cfg		tbg_b;
+	struct a3700_nb_clock_cfg	nb_clk_cfg;
+	struct a3700_sb_clock_cfg	sb_clk_cfg;
+};
+
+/* This index points to configuration selected in MVEBU_A3700_CLOCK_CFGS
+   when DT entry is missing or invalid */
+#define MVEBU_A3700_DEF_CLOCK_PRESET_IDX	1
+
+/* Init values for the static clock configurations array */
+/*
+*************************************************************************************************************************************
+Configuration 0 – CPU 600, DDR 600
+
+		SE DIV	DIFF DIV
+KVCO-A	2400	1	1	← 2^n
+KVCO-B	2000	1	1	← 2^n						NB				SB
+=====================================================================================================================================
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-S	1200	3	1	sdio_pclk_sel		400	SB					DIV0[8:6]	DIV0[5:3]
+	2^n →	1	NA	ddr_phy_mck_div_sel	600	NB	DIV0[18]	NA
+		3	1	mmc_pclk_sel		400	NB	DIV2[15:13]	DIV2[18:16]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-P	1200	2	NA	a53_cpu_pclk_sel	600	NB	DIV0[30:28]	NA
+		2	NA	wc_ahb_div_sel		300	NB	DIV2[2:0]	NA
+	2^n →	0	NA	atb_clk_div_sel		600	NB	DIV2[26:5]	NA
+	2^n →	1	NA	plkdbg_clk_div_sel	300	NB	DIV2[30:29]	NA
+		2	NA	setm_tmx_pclk_sel	600	NB	DIV1[20:18]	NA
+		2	NA	trace_pclk_sel		600	NB	DIV0[22:20]	NA
+		3	2	tsecm_pclk_sel		200	NB	DIV1[14:12]	DIV1[17:15]
+		3	2	sqf_pclk_sel		200	NB	DIV1[26:24]	DIV1[29:27]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B_S	1000	2	1	eip97_pclk_sel		500	NB	DIV2[24:22]	DIV2[21:19]
+		5	2	pwm_pclk_sel		100	NB	DIV0[5:3]	DIV0[2:0]
+		5	1	sec_at_pclk_sel		200	NB	DIV1[5:3]	DIV1[2:0]
+		5	2	sec_dap_pclk_sel	100	NB	DIV1[11:9]	DIV1[8:6]
+		5	1	sata_host_pclk_sel	200	NB	DIV2[9:7]	DIV2[12:10]
+		4	2	ddr_fclk_pclk_sel	125	NB	DIV0[17:15]	DIV0[14:12]
+		6	NA	counter_pclk_sel	167	NB	DIV0[25:23]	NA
+	2^n →	1	NA	cpu_cnt_clk_div_sel	83	NB	DIV2[28:27]	NA
+		4	1	gbe_core_pclk_sel	250	SB					DIV1[20:18]	DIV1[23:21]
+		1	NA	gbe_bm_core_clk_div2_sel250	SB					DIV1[12]	NA
+		1	NA	gbe1_core_clk_div2_sel	250	SB					DIV1[13]	NA
+		1	NA	gbe0_core_clk_div2_sel	250	SB					DIV1[14]	NA
+		4	2	gbe_125_pclk_sel	125	SB					DIV1[11:9]	DIV1[8:6]
+		5	1	sb_axi_pclk_sel		200	SB					DIV0[20:18]	DIV0[23:21]
+		4	2	usb32_ss_sys_pclk_sel	125	SB					DIV0[17:15]	DIV0[20:18]
+		5	2	usb32_usb2_sys_pclk_sel	100	SB					DIV0[14:12]	DIV0[11:9]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B-P	1000	4	5	gbe_50_pclk_sel		50	SB					DIV2[11:9]	DIV2[8:6]
+*************************************************************************************************************************************
+*************************************************************************************************************************************
+Configuration 1 – CPU 400, DDR 600
+
+		SE DIV	DIFF DIV
+KVCO-A	2400	1	1	← 2^n
+KVCO-B	1600	1	1	← 2^n						NB				SB
+=====================================================================================================================================
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-S	1200	5	2	sec_at_pclk_sel		120	NB	DIV1[5:3]	DIV1[2:0]
+		5	4	sec_dap_pclk_sel	60	NB	DIV1[11:9]	DIV1[8:6]
+		5	4	pwm_pclk_sel		60	NB	DIV0[5:3]	DIV0[2:0]
+		2	6	ddr_fclk_pclk_sel	100	NB	DIV0[17:15]	DIV0[14:12]
+		1	4	eip97_pclk_sel		300	NB	DIV2[24:22]	DIV2[21:19]
+		2	2	gbe_core_pclk_sel	300	SB					DIV1[20:18]	DIV1[23:21]
+		1	NA	gbe_bm_core_clk_div2_sel300	SB					DIV1[12]	NA
+		1	NA	gbe1_core_clk_div2_sel	300	SB					DIV1[13]	NA
+		1	NA	gbe0_core_clk_div2_sel	300	SB					DIV1[14]	NA
+		5	1	sdio_pclk_sel		240	SB					DIV0[8:6]	DIV0[5:3]
+		4	5	usb32_usb2_sys_pclk_sel	60	SB					DIV0[14:12]	DIV0[11:9]
+		3	4	usb32_ss_sys_pclk_sel	100	SB					DIV0[17:15]	DIV0[20:18]
+	2^n →	1	NA	ddr_phy_mck_div_sel	600	NB	DIV0[18]	NA
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET	FREQ		PRE-1	BR	PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-P	1200	4	5	gbe_50_pclk_sel		60	SB					DIV2[11:9]	DIV2[8:6]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B_S	800	4	1	mmc_pclk_sel		200	NB	DIV2[15:13]	DIV2[18:16]
+		5	1	sata_host_pclk_sel	160	NB	DIV2[9:7]	DIV2[12:10]
+		5	1	tsecm_pclk_sel		160	NB	DIV1[14:12]	DIV1[17:15]
+		2	NA	setm_tmx_pclk_sel	400	NB	DIV1[20:18]	NA
+		5	1	sqf_pclk_sel		160	NB	DIV1[26:24]	DIV1[29:27]
+		2	NA	trace_pclk_sel		400	NB	DIV0[22:20]	NA
+		5	NA	counter_pclk_sel	160	NB	DIV0[25:23]	NA
+	2^n →	1	NA	cpu_cnt_clk_div_sel	80	NB	DIV2[28:27]	NA
+		2	NA	a53_cpu_pclk_sel	400	NB	DIV0[30:28]	NA
+		2	NA	wc_ahb_div_sel		200	NB	DIV2[2:0]	NA
+	2^n →	0	NA	atb_clk_div_sel		400	NB	DIV2[26:5]	NA
+	2^n →	1	NA	plkdbg_clk_div_sel	200	NB	DIV2[30:29]	NA
+		3	2	gbe_125_pclk_sel	133	SB					DIV1[11:9]	DIV1[8:6]
+		2	2	sb_axi_pclk_sel		200	SB					DIV0[20:18]	DIV0[23:21]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B-P	800
+*************************************************************************************************************************************
+*************************************************************************************************************************************
+Configuration 2 – CPU 1000, DDR 800
+
+		SE DIV	DIFF DIV
+KVCO-A	1600	0	1	← 2^n
+KVCO-B	2000	1	2	← 2^n						NB				SB
+=====================================================================================================================================
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-S	1600	4	1	mmc_pclk_sel		400	NB	DIV2[15:13]	DIV2[18:16]
+	2^n →	1	NA	ddr_phy_mck_div_sel	800	NB	DIV0[18]	NA
+		4	1	sdio_pclk_sel		400	SB					DIV0[8:6]	DIV0[5:3]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-P	800	5	NA	counter_pclk_sel	160	NB	DIV0[25:23]	NA
+	2^n →	1	NA	cpu_cnt_clk_div_sel	80	NB	DIV2[28:27]	NA
+		4	1	sqf_pclk_sel		200	NB	DIV1[26:24]	DIV1[29:27]
+		4	1	sata_host_pclk_sel	200	NB	DIV2[9:7]	DIV2[12:10]
+		4	1	tsecm_pclk_sel		200	NB	DIV1[14:12]	DIV1[17:15]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B_S	1000	5	1	sec_at_pclk_sel		200	NB	DIV1[5:3]	DIV1[2:0]
+		2	1	eip97_pclk_sel		500	NB	DIV2[24:22]	DIV2[21:19]
+		1	NA	setm_tmx_pclk_sel	1000	NB	DIV1[20:18]	NA
+		1	NA	trace_pclk_sel		1000	NB	DIV0[22:20]	NA
+		1	NA	a53_cpu_pclk_sel	1000	NB	DIV0[30:28]	NA
+		4	NA	wc_ahb_div_sel		250	NB	DIV2[2:0]	NA
+	2^n →	0	NA	atb_clk_div_sel		1000	NB	DIV2[26:5]	NA
+	2^n →	1	NA	plkdbg_clk_div_sel	500	NB	DIV2[30:29]	NA
+		4	2	ddr_fclk_pclk_sel	125	NB	DIV0[17:15]	DIV0[14:12]
+		5	2	sec_dap_pclk_sel	100	NB	DIV1[11:9]	DIV1[8:6]
+		5	2	pwm_pclk_sel		100	NB	DIV0[5:3]	DIV0[2:0]
+		4	1	gbe_core_pclk_sel	250	SB					DIV1[20:18]	DIV1[23:21]
+		1	NA	gbe_bm_core_clk_div2_sel250	SB					DIV1[12]	NA
+		1	NA	gbe1_core_clk_div2_sel	250	SB					DIV1[13]	NA
+		1	NA	gbe0_core_clk_div2_sel	250	SB					DIV1[14]	NA
+		4	2	gbe_125_pclk_sel	125	SB					DIV1[11:9]	DIV1[8:6]
+		2	2	sb_axi_pclk_sel		250	SB					DIV0[20:18]	DIV0[23:21]
+		4	2	usb32_ss_sys_pclk_sel	125	SB					DIV0[17:15]	DIV0[20:18]
+		5	2	usb32_usb2_sys_pclk_sel	100	SB					DIV0[14:12]	DIV0[11:9]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B-P	500	2	5	gbe_50_pclk_sel		50	SB					DIV2[11:9]	DIV2[8:6]
+*************************************************************************************************************************************
+*************************************************************************************************************************************
+Configuration 3 – CPU 800, DDR 800
+
+		SE DIV	DIFF DIV
+KVCO-A	1600	0	1	← 2^n
+KVCO-B	2000	1	2	← 2^n						NB				SB
+=====================================================================================================================================
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-S	1600	4	1	mmc_pclk_sel		400	NB	DIV2[15:13]	DIV2[18:16]
+	2^n →	1	NA	ddr_phy_mck_div_sel	800	NB	DIV0[18]	NA
+		4	1	sdio_pclk_sel		400	SB					DIV0[8:6]	DIV0[5:3]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-A-P	800	5	NA	counter_pclk_sel	160	NB	DIV0[25:23]	NA
+	2^n →	1	NA	cpu_cnt_clk_div_sel	80	NB	DIV2[28:27]	NA
+		4	1	sqf_pclk_sel		200	NB	DIV1[26:24]	DIV1[29:27]
+		4	1	sata_host_pclk_sel	200	NB	DIV2[9:7]	DIV2[12:10]
+		4	1	tsecm_pclk_sel		200	NB	DIV1[14:12]	DIV1[17:15]
+		2	1	eip97_pclk_sel		400	NB	DIV2[24:22]	DIV2[21:19]
+		1	NA	setm_tmx_pclk_sel	800	NB	DIV1[20:18]	NA
+		1	NA	trace_pclk_sel		800	NB	DIV0[22:20]	NA
+		1	NA	a53_cpu_pclk_sel	800	NB	DIV0[30:28]	NA
+		4	NA	wc_ahb_div_sel		200	NB	DIV2[2:0]	NA
+	2^n →	0	NA	atb_clk_div_sel		800	NB	DIV2[26:5]	NA
+	2^n →	1	NA	plkdbg_clk_div_sel	400	NB	DIV2[30:29]	NA
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B_S	1000	5	1	sec_at_pclk_sel		200	NB	DIV1[5:3]	DIV1[2:0]
+		4	2	ddr_fclk_pclk_sel	125	NB	DIV0[17:15]	DIV0[14:12]
+		5	2	sec_dap_pclk_sel	100	NB	DIV1[11:9]	DIV1[8:6]
+		5	2	pwm_pclk_sel		100	NB	DIV0[5:3]	DIV0[2:0]
+		4	1	gbe_core_pclk_sel	250	SB					DIV1[20:18]	DIV1[23:21]
+		1	NA	gbe_bm_core_clk_div2_sel250	SB					DIV1[12]	NA
+		1	NA	gbe1_core_clk_div2_sel	250	SB					DIV1[13]	NA
+		1	NA	gbe0_core_clk_div2_sel	250	SB					DIV1[14]	NA
+		4	2	gbe_125_pclk_sel	125	SB					DIV1[11:9]	DIV1[8:6]
+		2	2	sb_axi_pclk_sel		250	SB					DIV0[20:18]	DIV0[23:21]
+		4	2	usb32_ss_sys_pclk_sel	125	SB					DIV0[17:15]	DIV0[20:18]
+		5	2	usb32_usb2_sys_pclk_sel	100	SB					DIV0[14:12]	DIV0[11:9]
+-------------------------------------------------------------------------------------------------------------------------------------
+		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
+-------------------------------------------------------------------------------------------------------------------------------------
+TBG-B-P	500	2	5	gbe_50_pclk_sel		50	SB					DIV2[11:9]	DIV2[8:6]
+*************************************************************************************************************************************
+*/
+/* Init values for the static clock configurations array */
+#define MVEBU_A3700_CLOCK_CFGS	{\
+	 /* Clock tree configuration entry 0 (testing, not yet fully functional) */\
+	{ 600, 600, /* CPU, DDR */\
+		{2400, 1, 1}, /* TBG-A: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		{2000, 1, 1}, /* TBG-B: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		/* NorthBridge */\
+		{{TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S, TBG_A_P, TBG_A_P, TBG_A_P,\
+		  TBG_B_S, TBG_B_S, TBG_A_P, TBG_B_S, TBG_A_P, TBG_B_S},\
+		 {2, 5, 2, 4, 1, 2, 6, 2},		/* DIV0 */\
+		 {1, 5, 2, 5, 2, 3, 2, 2, 3},		/* DIV1 */\
+		 {2, 1, 5, 1, 3, 1, 2, 0, 1, 1} },	/* DIV2 */\
+		/* SouthBridge */\
+		{{TBG_B_P, TBG_B_S, TBG_B_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S},\
+		 {1, 3, 2, 5, 2, 4, 1, 5},	/* DIV0 */\
+		 {2, 4, 1, 1, 1, 4, 1},		/* DIV1 */\
+		 {5, 4} }			/* DIV2 */\
+	},\
+	/* Clock tree configuration entry 1 (default working setup) */\
+	{ 400, 600, /* CPU, DDR */\
+		{2400, 1, 1}, /* TBG-A: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		{1600, 1, 1}, /* TBG-B: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		/* NorthBridge */\
+		{{TBG_B_S, TBG_B_S, TBG_A_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S,\
+		 TBG_A_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S, TBG_A_S},\
+		{4, 5, 6, 2, 1, 2, 5, 2},		/* DIV0 */\
+		{2, 5, 4, 5, 1, 5, 2, 1, 5},		/* DIV1 */\
+		{2, 1, 5, 1, 4, 1, 4, 0, 1, 1} },	/* DIV2 */\
+		/* SouthBridge */\
+		{{TBG_A_P, TBG_A_S, TBG_B_S, TBG_A_S, TBG_A_S, TBG_A_S, TBG_B_S},\
+		{1, 5, 5, 4, 3, 4, 2, 2},	/* DIV0 */\
+		{2, 3, 1, 1, 1, 2, 4},		/* DIV1 */\
+		{5, 4} }			/* DIV2 */\
+	},\
+	/* Clock tree configuration entry 2 */\
+	{ 1000, 800, /* CPU, DDR */\
+		{1600, 0, 1}, /* TBG-A: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		{2000, 1, 2}, /* TBG-B: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		/* NorthBridge */\
+		{{TBG_A_S, TBG_A_P, TBG_B_S, TBG_B_S, TBG_A_P, TBG_B_S, TBG_A_P,\
+		  TBG_B_S, TBG_B_S, TBG_B_S, TBG_A_P, TBG_B_S, TBG_B_S},\
+		{4, 5, 2, 4, 1, 1, 5, 1},		/* DIV0 */\
+		{1, 5, 2, 5, 1, 4, 1, 1, 4},		/* DIV1 */\
+		{2, 1, 4, 1, 4, 2, 1, 0, 1, 1} },	/* DIV2 */\
+		/* SouthBridge */\
+		{{TBG_B_P, TBG_B_S, TBG_B_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S},\
+		{1, 4, 2, 5, 2, 4, 2, 2},	/* DIV0 */\
+		{2, 4, 1, 1, 1, 4, 1},		/* DIV1 */\
+		{5, 2} }			/* DIV2 */\
+	},\
+	/* Clock tree configuration entry 3 */\
+	{ 800, 800, /* CPU, DDR */\
+		{1600, 0, 1}, /* TBG-A: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		{2000, 1, 2}, /* TBG-B: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
+		/* NorthBridge */\
+		{{TBG_A_S, TBG_A_P, TBG_B_S, TBG_B_S, TBG_A_P, TBG_A_P, TBG_A_P,\
+		  TBG_B_S, TBG_B_S, TBG_A_P, TBG_A_P, TBG_A_P, TBG_A_P},\
+		{4, 5, 2, 4, 1, 1, 5, 1},		/* DIV0 */\
+		{1, 5, 2, 5, 1, 4, 1, 1, 4},		/* DIV1 */\
+		{2, 1, 4, 1, 4, 2, 1, 0, 1, 1} },	/* DIV2 */\
+		/* SouthBridge */\
+		{{TBG_B_P, TBG_B_S, TBG_B_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S},\
+		{1, 4, 2, 5, 2, 4, 2, 2},	/* DIV0 */\
+		{2, 4, 1, 1, 1, 4, 1},		/* DIV1 */\
+		{5, 2} }			/* DIV2 */\
+	},\
+}
+
+/*****************************************************************************
+* get_ref_clk
+*
+* return: reference clock in MHz (25 or 40)
+******************************************************************************/
+u32 get_ref_clk(void);
+
+/*****************************************************************************
+* get_cpu_clk
+*
+* return: current CPU clock in Mhz
+******************************************************************************/
+u32 get_cpu_clk(void);
+
+/*****************************************************************************
+* get_ddr_clk
+*
+* return: current DDR clock in Mhz
+******************************************************************************/
+u32 get_ddr_clk(void);
+
+
+/******************************************************************************
+* Name: set_clocks
+*
+* Description: Configure entire clock tree according to CPU and DDR frequency
+*
+* Input:	cpu_clk_mhz: required CPU clock
+*		ddr_clk_mhz: required DDR clock
+*		tbg_a_kvco_mhz: required TBG-A KVCO frequency or 0 for any available
+*		tbg_b_kvco_mhz: required TBG-B KVCO frequency or 0 for any available
+* Output:	None
+* Return:	Non-zero if the requested settings are not supported
+******************************************************************************/
+u32 set_clocks(u32 cpu_clk_mhz, u32 ddr_clk_mhz, u32 tbg_a_kvco_mhz, u32 tbg_b_kvco_mhz);
+
+int init_clock(void);
+
+#endif /* _ARMADALP_CLOCK_H_ */
diff --git a/arch/arm/include/asm/arch-armada3700/gpio.h b/arch/arm/include/asm/arch-armada3700/gpio.h
new file mode 100644
index 0000000..c4e69d1
--- /dev/null
+++ b/arch/arm/include/asm/arch-armada3700/gpio.h
@@ -0,0 +1,45 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+#ifndef _MVEBU_GPIO_H_
+#define _MVEBU_GPIO_H_
+
+#define MVEBU_GPIO_NB_OUTPUT_EN_REG		(MVEBU_GPIO_NB_REG_BASE)
+#define MVEBU_GPIO_NB_OUTPUT_EN_HIGH_REG	(MVEBU_GPIO_NB_REG_BASE + 0x4)
+#define MVEBU_GPIO_NB_OUTPUT_SPI_EN_OFF		(28)/* This is hidden bit which is reserved in function spec */
+#define MVEBU_GPIO_NB_OUTPUT_VAL_REG		(MVEBU_GPIO_NB_REG_BASE + 0x18)
+#define MVEBU_GPIO_NB_SEL_REG			(MVEBU_GPIO_NB_REG_BASE + 0x30)
+#define MVEBU_GPIO_TW1_GPIO_EN_OFF		(10)
+#define MVEBU_GPIO_SPI_GPIO_EN_OFF		(18)
+
+#define MVEBU_GPIO_SB_OUTPUT_EN_REG		(MVEBU_GPIO_SB_REG_BASE)
+#define MVEBU_GPIO_SB_OUTPUT_VAL_REG		(MVEBU_GPIO_SB_REG_BASE + 0x18)
+#define MVEBU_GPIO_PCIE_RESET_OFF		(3)
+#define MVEBU_GPIO_SDIO_VOLTAGE_3_3V		(0)
+#define MVEBU_GPIO_SDIO_VOLTAGE_1_8V		(1)
+#define MVEBU_GPIO_SDIO_VOLTAGE_OFF		(22)
+#define MVEBU_GPIO_SB_SEL_REG			(MVEBU_GPIO_SB_REG_BASE + 0x30)
+#define MVEBU_GPIO_SB_SDIO_EN_OFF		(2)
+#define MVEBU_GPIO_RGMII_GPIO_EN_OFF		(3)
+#define MVEBU_GPIO_PCIE_EN_OFF			(4)
+
+void mvebu_set_sdio(int voltage);
+void mvebu_reset_pcie_dev(void);
+void mvebu_init_gpio(void);
+
+#endif /* _MVEBU_GPIO_H_ */
diff --git a/arch/arm/include/asm/arch-armada3700/mbus_reg.h b/arch/arm/include/asm/arch-armada3700/mbus_reg.h
new file mode 100644
index 0000000..03e29c2
--- /dev/null
+++ b/arch/arm/include/asm/arch-armada3700/mbus_reg.h
@@ -0,0 +1,49 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+#ifndef _MBUS_ARLP_H_
+#define _MBUS_ARLP_H_
+
+#define MBUS_WIN_CTRL_REG(win_num)		(win_num * 0x10)
+#define MBUS_CR_WIN_ENABLE				0x1
+#define MBUS_CR_WIN_TARGET_OFFS			4
+#define MBUS_CR_WIN_TARGET_MASK			(0xf << MBUS_CR_WIN_TARGET_OFFS)
+#define MBUS_CR_WIN_ATTR_OFFS			8
+#define MBUS_CR_WIN_ATTR_MASK			(0xff << MBUS_CR_WIN_ATTR_OFFS)
+
+#define MBUS_WIN_SIZE_REG(win_num)		(0x4 + win_num * 0x10)
+#define MBUS_CR_WIN_SIZE_OFFS			0
+#define MBUS_CR_WIN_SIZE_MASK			(0xffffff << MBUS_CR_WIN_SIZE_OFFS)
+#define MBUS_CR_WIN_SIZE_ALIGNMENT		0x10000
+
+
+#define MBUS_WIN_BASE_REG(win_num)		(0x8 + win_num * 0x10)
+#define MBUS_BR_BASE_OFFS				0
+#define MBUS_BR_BASE_MASK				(0xffffff <<  MBUS_BR_BASE_OFFS)
+
+#define MBUS_WIN_REMAP_LOW_REG(win_num)	(0xc + win_num * 0x10)
+#define MBUS_RLR_REMAP_LOW_OFFS			0
+#define MBUS_RLR_REMAP_LOW_MASK			(0xffffff << MBUS_RLR_REMAP_LOW_OFFS)
+
+/* there is no remap_high reg in ArmadaLP, just define here to pass compilation */
+#define MBUS_WIN_REMAP_HIGH_REG(win_num)	(0xc + win_num * 0x10)
+
+#define MBUS_WIN_INTEREG_REG			(0xF0)
+
+#endif	/* _MBUS_ARLP_H_ */
+
diff --git a/arch/arm/include/asm/arch-armada3700/memory-map.h b/arch/arm/include/asm/arch-armada3700/memory-map.h
new file mode 100644
index 0000000..6e249cf
--- /dev/null
+++ b/arch/arm/include/asm/arch-armada3700/memory-map.h
@@ -0,0 +1,36 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+/* Memory Map */
+/* 0x00000000 - 0x7FFFFFFF - DRAM */
+/* 0x80000000 - 0x8FFFFFFF - IHB-PCIe */
+/* 0xD0000000 - 0xD0300000 - Internal Reg */
+/* 0xD0700000 - 0xD070FFFF - CCI */
+/* 0xE0000000 - 0xE7FFFFFF - IHB */
+/* 0xE8000000 - 0xEFFFFFFF - PCIe */
+/* 0xF0000000 - 0xF001FFFF - rWTM */
+/* 0xFFF00000 - 0xFFFFFFFF - Boot Room */
+
+#ifdef __ASSEMBLY__
+#define MVEBU_REGS_BASE		(0xD0000000)
+#else
+#define MVEBU_REGS_BASE		(0xD0000000UL)
+#endif
+#define MVEBU_REGS_SIZE		(0x300000)
+
+
diff --git a/arch/arm/include/asm/arch-armada3700/misc-regs.h b/arch/arm/include/asm/arch-armada3700/misc-regs.h
new file mode 100644
index 0000000..9dfe1d8
--- /dev/null
+++ b/arch/arm/include/asm/arch-armada3700/misc-regs.h
@@ -0,0 +1,35 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+#ifndef _MISC_REGS_H_
+#define _MISC_REGS_H_
+#include <asm/arch/regs-base.h>
+
+#define MVEBU_NB_PM_PWRDWN_OPT_REG     (MVEBU_NORTH_PM_REGS_BASE + 0x8)
+#define L2_SRAM_LKG_PD_EN              (BIT8)
+#define CPU_ROM_PD_EN                  (BIT10)
+#define AVS_DISABLE_MODE               (BIT14)
+#define DDRPHY_PAD_PWRDWN_EN           (BIT22)
+
+#define MVEBU_AXI_DCTRL_CTRL_RST_REG   (MVEBU_AXI_DCTRL_REGS_BASE)
+#define DDRPHY_MODE_SELECT             (BIT16)         /* 0: 2 to 1, 1: 4 to 1 */
+
+#define MVEBU_AXI_DCTRL_MCM_SEL_REG    (MVEBU_AXI_DCTRL_REGS_BASE + 0x4)
+
+
+#endif /* _MISC_REGS_H_ */
diff --git a/arch/arm/include/asm/arch-armada3700/pcie-core.h b/arch/arm/include/asm/arch-armada3700/pcie-core.h
new file mode 100644
index 0000000..f0f5f39
--- /dev/null
+++ b/arch/arm/include/asm/arch-armada3700/pcie-core.h
@@ -0,0 +1,408 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+/* pcie-core.h
+ *
+ * Definition for PCIe core unit
+ *
+ * Author: Victor Gu <xigu@marvell.com>
+ *
+ * March 6, 2015
+ *
+ */
+
+#ifndef _PCIE_CORE_H_
+#define _PCIE_CORE_H_
+
+#include <asm/arch/memory-map.h>
+#include <asm/arch-mvebu/mvebu.h>
+#include <pci.h>
+
+/* ArLP RC has only 1 port */
+#define PCIE_ADVK_MAX_PORT	(1)
+
+/*
+ * Make it 1 because we fake up internal bus 0.
+ * We fake up internal bus 0 because we assume root port 0
+ * is on bus 0. In that case, if we send a config TLP to
+ * Endpoint device on bus 1, it must be a Type 1 TLP.
+ * However, it's not. Because we only have one link, without
+ * any internal bus.
+ * If we don't fake internal bus, then just leave it 0.
+ */
+#define PCIE_ADVK_ACTUAL_FIRST_BUSNO	1
+
+#define SIZE_8BIT	1
+#define SIZE_16BIT	2
+#define SIZE_32BIT	4
+
+#define LOCAL_VENDOR_ID		0x11AB
+#define LOCAL_DEVICE_ID		0x0
+#define LOCAL_SUBVENDOR_ID	0x11AB
+#define LOCAL_SUBDEVICE_ID	0x0
+#define LOCAL_CLASS_CODE	0x2
+#define LOCAL_SUBCLASS_CODE	0x0
+#define LOCAL_REVISION_ID	0x0
+#define LOCAL_PROGIF_CODE	0x0
+
+#define BAR_PCIE_MEM		0x0
+#define BAR_PCIE_REG		0x4
+
+/*
+ * Used in PIO read/write
+ * Should choose this value more carefully
+ */
+#define PCIE_CORE_PIO_TIMEOUT_NUM	1000
+#define PCIE_CORE_PIO_ADDR_MASK	0xfffffffc
+/* This defines the size of VPD RAM */
+#define PCIE_CORE_VPD_RAM_SIZE	0x400 /*1K*/
+
+/* Time out number to get PCIe link up */
+#define PCIE_LINK_TIMEOUT_NUM	1000
+
+/* Transaction types */
+#define PCIE_MEM_RD		0x0
+#define PCIE_MEM_WR		0x2
+#define PCIE_IO_RD		0x4
+#define PCIE_IO_WR		0x6
+#define PCIE_CONFIG_RD_TYPE0	0x8
+#define PCIE_CONFIG_RD_TYPE1	0x9
+#define PCIE_CONFIG_WR_TYPE0	0xa
+#define PCIE_CONFIG_WR_TYPE1	0xb
+#define PCIE_MSG_REQ		0xc
+
+/* Message codes
+ * virtual legacy interrupt messages
+ */
+#define MSG_ASSERT_INTA		0x20
+#define MSG_ASSERT_INTB		0x21
+#define MSG_ASSERT_INTC		0x22
+#define MSG_ASSERT_INTD		0x23
+#define MSG_DEASSERT_INTA	0x24
+#define MSG_DEASSERT_INTB	0x25
+#define MSG_DEASSERT_INTC	0x26
+#define MSG_DEASSERT_INTD	0x27
+
+/* Power related messages */
+#define MSG_PM_ACTIVE_STATE_NAK	0x14
+#define MSG_PM_PME		0x18
+#define MSG_PM_TURN_OFF		0x19
+#define MSG_PM_TO_ACK		0x1b
+
+/* Error messages */
+#define MSG_ERR_COR		0x30
+#define MSG_ERR_NONFATAL	0x31
+#define MSG_ERR_FATAL		0x33
+
+/* Unlock message */
+#define MSG_UNLOCK		0x00
+
+/* Slot power limit set message */
+#define MSG_SET_SLOT_POWER_LIMIT	0x50
+
+/* Hot-Plug related messages */
+#define MSG_ATT_INDICATOR_ON		0x41
+#define MSG_ATT_INDICATOR_BLINK		0x43
+#define MSG_ATT_INDICATOR_OFF		0x40
+#define MSG_POWER_INDICATOR_ON		0x45
+#define MSG_POWER_INDICATOR_BLINK	0x47
+#define MSG_POWER_INDICATOR_OFF		0x44
+#define MSG_ATT_BUTTON_PRESSED		0x48
+
+#define PCIE_CORE_DEV_CTRL_STATS_REG	0xC8
+#define PCIE_CORE_LINK_CTRL_STAT_REG	0xD0
+#define PCIE_CORE_LINK_TRAINING_SHIFT	5
+#define PCIE_CORE_LINK_SPEED_SHIFT	16
+#define PCIE_CORE_LINK_SPEED_MASK	0xF
+#define PCIE_CORE_LINK_WIDTH_SHIFT	20
+#define PCIE_CORE_LINK_WIDTH_MASK	0x3F
+#define PCIE_CORE_LINK_DLL_STATE_SHIFT	29
+#define PCIE_CORE_LINK_DLL_STATE_MASK	0x1
+
+#define PCIE_DLL_STATE_ACTIVE	1
+#define PCIE_DLL_STATE_INACTIVE	0
+
+#define PCIE_CORE_ERR_CAP_CTRL_REG	0x118
+
+/* Shift */
+#define PCIE_CORE_PIO_CTRL_BYTE_COUNT_SHIFT	16
+
+/* Aardvark PIO registers */
+#define PIO_BASE_ADDR			0x4000
+#define PCIE_CORE_PIO_CTRL		0x0
+#define PCIE_CORE_PIO_STAT		0x4
+#define PCIE_CORE_PIO_ADDR_LS		0x8
+#define PCIE_CORE_PIO_ADDR_MS		0xc
+#define PCIE_CORE_PIO_WR_DATA		0x10
+#define PCIE_CORE_PIO_WR_DATA_STRB	0x14
+#define PCIE_CORE_PIO_RD_DATA		0x18
+#define PCIE_CORE_PIO_START		0x1c
+#define PCIE_CORE_PIO_ISR		0x20
+#define PCIE_CORE_PIO_ISRM		0x24
+
+/* Aardvark PCIe DPMU registers */
+#define DPMU_BASE_ADDR			0x4400
+#define PCIE_CORE_DPMU_CTRL0		0x0
+
+/* Aardvark Control registers */
+#define CONTROL_BASE_ADDR	0x4800
+#define PCIE_CORE_CTRL0_REG	0x0
+#define PCIE_GEN_SEL_MSK	0x3
+#define PCIE_GEN_SEL_SHIFT	0x0
+#define SPEED_GEN_1		0
+#define SPEED_GEN_2		1
+#define SPEED_GEN_3		2
+#define IS_RC_MSK		0x4
+#define IS_RC_SHIFT		2
+#define LANE_CNT_MSK		0x18
+#define LANE_CNT_SHIFT		0x3
+#define LANE_COUNT_1		(0 << LANE_CNT_SHIFT)
+#define LANE_COUNT_2		(1 << LANE_CNT_SHIFT)
+#define LANE_COUNT_4		(2 << LANE_CNT_SHIFT)
+#define LANE_COUNT_8		(3 << LANE_CNT_SHIFT)
+#define LINK_TRAINNING_EN	BIT6
+#define CORE_RESET_MSK		BIT7
+#define MGMT_RESET_MSK		BIT8
+#define MGMT_STICKY_RESET_MSK	BIT9
+#define APP_RESET_MSK		BIT16
+#define LEGACY_INTA		BIT28
+#define LEGACY_INTB		BIT29
+#define LEGACY_INTC		BIT30
+#define LEGACY_INTD		BIT31
+#define PCIE_CORE_CTRL1_REG	0x4
+#define HOT_RESET_GEN		BIT0
+#define PCIE_CORE_CTRL2_REG	0x8
+#define STRICT_ORDER_ENABLE	BIT5
+#define OB_WIN_ENABLE		BIT6
+#define MSI_ENABLE		BIT10
+#define PCIE_CORE_FLUSH_REG	0xC
+#define PCIE_CORE_FLUSH_TIMER_MASK	0xFFFF
+#define PCIE_CORE_FORCE_FLUSH	BIT16
+#define PCIE_CORE_FLUSH_ACTIVE	BIT17
+#define PCIE_CORE_FLUSH_CLEAR	BIT18
+#define PCIE_CORE_PWR_CTRL_REG	0x10
+#define REQ_PM_TRANSITION_L23	(1 << 0)
+#define POWER_STATE_CHANGE_ACK	(1 << 1)
+#define PCIE_CORE_PHY_REF_CLK_REG	0x14
+#define PCIE_CORE_EN_TX		(1 << 1)
+#define PCIE_CORE_EN_RX		(1 << 2)
+#define PCIE_CORE_SEL_AMP_MASK	0x7
+#define PCIE_CORE_SEL_AMP_SHIFT	0x8
+#define PCIE_CORE_EN_PU		(1 << 12)
+#define PCIE_CORE_MSG_LOG0		0x30
+#define PCIE_CORE_MSG_LOG0_MSK		0xFF
+#define PCIE_CORE_ISR0			0x40
+#define PCIE_CORE_ISR0_HOT_RESET		BIT0
+#define PCIE_CORE_ISR0_LINK_DOWN		BIT1
+#define PCIE_CORE_ISR0_INB_MSG			BIT2
+#define PCIE_CORE_ISR0_DP_PERR			BIT3
+#define PCIE_CORE_ISR0_DP_FERR			BIT4
+#define PCIE_CORE_ISR0_MSG_PME2ACK		BIT5
+#define PCIE_CORE_ISR0_MSG_PM_TURN_OFF		BIT6
+#define PCIE_CORE_ISR0_MSG_PM_PME		BIT7
+#define PCIE_CORE_ISR0_MSG_PM_ACTIVE_NAK	BIT8
+#define PCIE_CORE_ISR0_LEGACY_INT_SENT		BIT9
+#define PCIE_CORE_ISR0_LEGACY_INTA_ASSERT	BIT16
+#define PCIE_CORE_ISR0_LEGACY_INTB_ASSERT	BIT17
+#define PCIE_CORE_ISR0_LEGACY_INTC_ASSERT	BIT18
+#define PCIE_CORE_ISR0_LEGACY_INTD_ASSERT	BIT19
+#define PCIE_CORE_ISR0_LEGACY_INTA_DEASSERT	BIT20
+#define PCIE_CORE_ISR0_LEGACY_INTB_DEASSERT	BIT21
+#define PCIE_CORE_ISR0_LEGACY_INTC_DEASSERT	BIT22
+#define PCIE_CORE_ISR0_LEGACY_INTD_DEASSERT	BIT23
+#define PCIE_CORE_ISRM0				0x44
+#define PCIE_CORE_ISR1				0x48
+#define PCIE_CORE_ISR1_PWR_CHANGE_STATE		BIT4
+#define PCIE_CORE_ISR1_FLUSH_OFF		BIT5
+#define PCIE_CORE_ISRM1				0x4c
+#define PCIE_CORE_MSI_MSG_LOW_ADDR		0x50
+#define PCIE_CORE_MSI_MSG_HIGH_ADDR		0x54
+#define PCIE_CORE_MSI_MSG_ISR_STAT		0x58
+#define PCIE_CORE_MSI_MSG_ISR_MASK		0x5c
+#define PCIE_CORE_DP_PAR_CNTL	0x60
+#define PCIE_CORE_DP_PAR_STAT0	0x64
+#define PCIE_CORE_DP_PAR_STAT1	0x68
+
+/* Victor: below PF/VF register do not exist in ArLP */
+#define PCIE_CORE_PF_FLR_CTRL	0x80
+#define PCIE_CORE_PF_FLR_STAT	0x84
+#define PCIE_CORE_VF_FLR_CTRL	0x88
+#define PCIE_CORE_VF_FLR_TRL	0x8c
+
+#define PCIE_CORE_MSI_PAYLOAD	0x9c
+
+#define OB_WIN_BASE_ADDR	0x4c00
+#define OB_WIN_MATCH_LS		0x00
+#define OB_WIN_MATCH_MS		0x04
+#define OB_WIN_REMAP_LS		0x08
+#define OB_WIN_REMAP_MS		0x0c
+#define OB_WIN_MASK_LS		0x10
+#define OB_WIN_MASK_MS		0x14
+#define OB_WIN_ACTIONS		0x18
+
+#define OB_WIN_BLOCK_SIZE	0x20
+
+#define OB_Default_ACTIONS	0xfc
+
+#define OB_PCIE_MEM		0x0
+#define OB_PCIE_IO		0x4
+#define OB_PCIE_CONFIG0		0x8
+#define OB_PCIE_CONFIG1		0x9
+#define OB_PCIE_MSG		0xc
+#define OB_PCIE_MSG_VENDOR	0xd
+
+#define OB_ATTR_SEL		BIT11
+#define OB_FUNC_SEL		BIT23
+
+/* PCIe address translation registers */
+#define ADDR_TRANSLATION_ADDR	0x5800
+#define AT_PF0_BAR0		0x0
+#define BAR_TYPE_32b		0
+#define BAR_TYPE_64b		0x4
+#define BAR_ADDR_MASK		(~0x7F)
+#define AT_PF0_BAR1		0x4
+#define AT_PF0_BAR2		0x8
+#define AT_PF0_BAR3		0xc
+#define AT_PF0_BAR4		0x10
+#define AT_PF0_BAR5		0x14
+#define MSG_BAR			0x100
+#define EXT_ROM_BAR		0x120
+#define AT_ISEL_PF0_BAR0	0x200
+#define AT_ISEL_PF0_BAR1	0x204
+#define AT_ISEL_PF0_BAR2	0x208
+#define AT_ISEL_PF0_BAR3	0x20c
+#define AT_ISEL_PF0_BAR4	0x210
+#define AT_ISEL_PF0_BAR5	0x214
+
+#define LMI_BASE_ADDR		0x6000
+#define PHY_CONF_REG0		0x0
+#define PHY_ERR_REPORT		BIT6
+#define LTSSM_STATE_SHIFT	24
+#define LTSSM_STATE_MASK	0x3f000000
+#define LTSSM_STATE_L0		0x10
+#define PHY_CONF_REG1		0x4
+#define DLL_TIMER_CONF		0x8
+#define REPLAY_TIMEOUT_MASK	0xffff
+#define REPLAY_TIMEOUT_SHIFT	0
+#define ACK_TIMEOUT_MASK	0xffff0000
+#define ACK_TIMEOUT_SHIFT	16
+#define RCV_CREDIT_LT_REG0	0xc
+#define RCV_CREDIT_LT_REG1	0x10
+#define TRANSMIT_CREDIT_LT_REG0	0x14
+#define TRANSMIT_CREDIT_LT_REG1	0x18
+#define TRANSMIT_CREDIT_UPDATE_REG0 0x1c
+#define TRANSMIT_CREDIT_UPDATE_REG1 0x20
+#define L0S_TIMEOUT_REG		0x24
+#define L0S_TIMEOUT_SHIFT	0
+#define L0S_TIMEOUT_MASK	0xffff
+#define L2_ENTRY_ENABLE		BIT16
+#define L1_REENTRY_DELAY	0x40
+#define LOCAL_VENDOR_ID_REG	0x44
+#define ASPM_L1_TIMEOUT_REG	0x48
+#define ASPM_L1_TIMEOUT_MASK	0xfffff
+#define LOCAL_ERR_STAT_REG	0x20c
+#define PNP_RX_FIFO_PAR		BIT0
+#define CPL_RX_FIFO_PAR		BIT1
+#define REPLAY_BUF_PAR		BIT2
+#define PNP_RX_FIFO_OVERFLOW	BIT3
+#define CPL_RX_FIFO_OVERFLOW	BIT4
+#define REPLAY_TIMEOUT		BIT5
+#define REPLAY_TIMER_ROLLOVER	BIT6
+#define PHY_ERR			BIT7
+#define MALFORMED_TLP		BIT8
+#define UNEXPECTED_CPL		BIT9
+#define FLOW_CONTROL_ERR	BIT10
+#define CPL_TIMEOUT		BIT11
+#define LOCAL_ERR_INT_MASK_REG	0x210
+#define LCRC_ERR_COUNT_REG	0x214
+#define LCRC_COUNT_MASK		0xffff
+#define ECC_COR_ERR_COUNT_REG	0x218
+#define PNP_RX_FIFO_MASK	0xff
+#define PNP_RX_FIFO_SHIFT	0
+#define CPL_RX_FIFO_MASK	0xff00
+#define CPL_RX_FIFO_SHIFT	8
+#define REPLAY_RAM_MASK		0xff0000
+#define REPLAY_RAM_SHIFT	16
+#define PHY_FUNC_0_BAR_CONF_REG	0x240
+#define PHY_FUNC_1_BAR_CONF_REG	0x244
+#define BAR_0_1_APERTURE_SHIFT	0
+#define BAR_2_3_APERTURE_SHIFT	7
+#define BAR_4_5_APERTURE_SHIFT	19
+#define BAR_ROM_APERTURE_SHIFT	26
+#define BAR_0_1_ENABLE		(1 << 5)
+#define BAR_2_3_ENABLE		(1 << 12)
+#define BAR_4_5_ENABLE		(1 << 24)
+#define BAR_ROM_ENABLE		(1 << 31)
+#define BAR_0_1_PREFETCHABLE	(1 << 6)
+#define BAR_2_3_PREFETCHABLE	(1 << 13)
+#define BAR_4_5_PREFETCHABLE	(1 << 25)
+
+#define PHY_BASE_ADDR		0x8000		/* update for Sycamore */
+
+/* For new PIO */
+#define PCIE_BDF(dev)            (dev << 4)	/* PCI_BDF shifts 8bit, so we need extra 4bit shift */
+#define PCIE_BUS(bus)            ((bus & 0xFF) << 20)
+#define PCIE_DEV(dev)            ((dev & 0x1F) << 15)
+#define PCIE_FUNC(fun)           ((fun & 0x7)  << 12)
+#define PCIE_REG_ADDR(reg)       ((reg & 0xFFC) << 0)
+
+/* PCIe core controller registers */
+#define PCIE_CTRL_CORE_BASE_ADDR	0x18000
+#define PCIE_CTRL_CONFIG_REG		0x0
+#define PCIE_CTRL_MODE_SHIFT		0x0
+#define PCIE_CTRL_MODE_MASK		0x1
+
+#define PCIE_CORE_MODE_EP		0x0
+#define PCIE_CORE_MODE_RC		0x1
+
+/* PCIe interrupt registers */
+#define PCIE_CTRL_INT_BASE_ADDR		0x1B000
+#define RC_INT_STATS_REG		0x0
+#define RC_INT_MASK_REG			0x4
+
+/*
+ * Get the register address of a given function's configuration space(each funciton has an address space of 0x1000)
+ * baseaddr is the base address of a PCIe device in Aardvark
+ */
+#define PCIE_CORE_CONFIG_REG_ADDR(baseaddr, offset) ((u64)baseaddr + offset)
+
+/* Get the PIO registers addresses of a PCIE device, 0x4000 is the offset of PIO register block */
+#define PCIE_CORE_PIO_REG_ADDR(baseaddr, offset) ((u64)baseaddr + PIO_BASE_ADDR + offset)
+
+/* Get the Control registers addresses of a PCIE device, 0x4800 is the offset of control register block*/
+#define PCIE_CORE_CTRL_REG_ADDR(baseaddr, offset) ((u64)baseaddr + CONTROL_BASE_ADDR + offset)
+
+/* Get the Outbound Address Translation window register address, 0x4c00 is the offset of ob window register block */
+#define PCIE_CORE_OB_REG_ADDR(baseaddr, offset, win) ((u64)baseaddr + OB_WIN_BASE_ADDR + win*OB_WIN_BLOCK_SIZE + offset)
+
+/* Get the DPMU registers addresses of a PCIE device, 0x4400 is the offset of control register block */
+#define PCIE_CORE_DPMU_REG_ADDR(baseaddr, offset) ((u64)baseaddr + DPMU_BASE_ADDR + offset)
+
+/* Get the Address Translation registers address of a PCIE device's , 0x5800 is the offset of control register block */
+#define PCIE_CORE_AT_REG_ADDR(baseaddr, offset) ((u64)baseaddr + ADDR_TRANSLATION_ADDR + offset)
+
+/* Get the VPD addresses of a PCIe device, 0x5000 is the offset of VPD register block */
+#define PCIE_CORE_VPD_RAM_ADDR(baseaddr, vfnum, offset) ((u64)baseaddr + VPD_RAM_BASE_ADDR + offset)
+
+/* Get the LMI register address of a PCIE device, 0x6000 is the offset of control register block */
+#define PCIE_CORE_LMI_REG_ADDR(baseaddr, offset) ((u64)baseaddr + LMI_BASE_ADDR + offset)
+
+/* Get PCIe controller core configuration addresses of a PCIe device, 0x180000 is the offset of controller core block */
+#define PCIE_CTRL_CORE_REG_ADDR(baseaddr, offset) ((u64)baseaddr + PCIE_CTRL_CORE_BASE_ADDR + offset)
+
+#endif /* _PCIE_CORE_H_ */
+
diff --git a/arch/arm/include/asm/arch-armada3700/regs-base.h b/arch/arm/include/asm/arch-armada3700/regs-base.h
new file mode 100644
index 0000000..492ea58
--- /dev/null
+++ b/arch/arm/include/asm/arch-armada3700/regs-base.h
@@ -0,0 +1,72 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+#ifndef _REGS_BASE_H_
+#define _REGS_BASE_H_
+
+#include <asm/arch/memory-map.h>
+
+#define MPP_REGS_BASE		(MVEBU_REGS_BASE + 0x18000)
+#define MVEBU_ADEC_BASE		(MVEBU_REGS_BASE + 0xCF00)
+
+#define MVEBU_MISC_REGS_BASE	(MVEBU_REGS_BASE + 0x18200)
+#define MVEBU_DEVICE_ID_REG	(MVEBU_MISC_REGS_BASE + 0x38)
+#define MVEBU_DEVICE_REV_REG	(MVEBU_MISC_REGS_BASE + 0x3C)
+#define MVEBU_RESET_MASK_REG	(MVEBU_MISC_REGS_BASE + 0x60)
+#define MVEBU_SOFT_RESET_REG	(MVEBU_MISC_REGS_BASE + 0x64)
+
+#define MVEBU_GIC_BASE (MVEBU_REGS_BASE + 0x1d00000)
+#define MVEBU_GICD_BASE		(MVEBU_GIC_BASE)
+#define MVEBU_GICR_BASE		(MVEBU_GIC_BASE + 0x40000)
+#define MVEBU_GICC_BASE		(MVEBU_GIC_BASE + 0x80000)
+
+/* GBE register base address */
+#define MVEBU_ARLP_GBE0_INTERNAL_REG_BASE	MVEBU_REGS_BASE + 0xc364
+#define MVEBU_ARLP_GBE1_INTERNAL_REG_BASE	MVEBU_REGS_BASE + 0xc464
+
+/* CCI-400 */
+#define MVEBU_CCI_BASE			(MVEBU_REGS_BASE + 0x8000000)
+#define MVEBU_CCI_S3_SNOOP_CTRL_REG	(MVEBU_CCI_BASE + 0x4000)
+
+/* GPIO register base address */
+#define MVEBU_GPIO_NB_REG_BASE	(MVEBU_REGS_BASE + 0x13800)
+#define MVEBU_GPIO_SB_REG_BASE	(MVEBU_REGS_BASE + 0x18800)
+
+#define MVEBU_A3700_NB_TEST_PIN_OUTPUT_EN (MVEBU_REGS_BASE + 0x13804)
+#define MVEBU_A3700_NB_TEST_PIN_OUTPUT_SPI_EN_OFF (28)
+
+/* Clocks */
+#define MVEBU_NORTH_CLOCK_REGS_BASE	(MVEBU_REGS_BASE + 0x13000)
+#define MVEBU_SOUTH_CLOCK_REGS_BASE	(MVEBU_REGS_BASE + 0x18000)
+#define MVEBU_TESTPIN_NORTH_REG_BASE	(MVEBU_NORTH_CLOCK_REGS_BASE + 0x800)
+
+/* Reset sample */
+#define MVEBU_TEST_PIN_LATCH_N		(MVEBU_TESTPIN_NORTH_REG_BASE + 0x8)
+
+/* PM */
+#define MVEBU_NORTH_PM_REGS_BASE	(MVEBU_REGS_BASE + 0x14000)
+#define MVEBU_SOUTH_PM_REGS_BASE	(MVEBU_REGS_BASE + 0x19000)
+
+/* AXI DCTRL */
+#define MVEBU_AXI_DCTRL_REGS_BASE	(MVEBU_REGS_BASE + 0x2000)
+
+/* AVS */
+#define MVEBU_AVS_REGS_BASE		(MVEBU_REGS_BASE + 0x11500)
+
+
+#endif	/* _REGS_BASE_H_ */
diff --git a/arch/arm/include/asm/arch-armada3700/soc-info.h b/arch/arm/include/asm/arch-armada3700/soc-info.h
new file mode 100644
index 0000000..b003717
--- /dev/null
+++ b/arch/arm/include/asm/arch-armada3700/soc-info.h
@@ -0,0 +1,64 @@
+/*
+* ***************************************************************************
+* Copyright (C) 2015 Marvell International Ltd.
+* ***************************************************************************
+* This program is free software: you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the Free
+* Software Foundation, either version 2 of the License, or any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+* ***************************************************************************
+*/
+
+#ifndef _SOC_INFO_H_
+#define _SOC_INFO_H_
+
+/* MBUS definitions*/
+#define MAX_MBUS_WINS			10
+#define MAX_MBUS_REMAP_WINS		8
+#define INTERNAL_REG_WIN_NUM		11
+
+/* General MPP definitions */
+#define MAX_MPP_OPTS		7
+#define MAX_MPP_ID		56
+
+#define MPP_BIT_CNT		4
+#define MPP_FIELD_MASK		0x7
+#define MPP_FIELD_BITS		3
+#define MPP_VAL_MASK		0xF
+
+#define MPPS_PER_REG		(32 / MPP_BIT_CNT)
+#define MAX_MPP_REGS		((MAX_MPP_ID + MPPS_PER_REG) / MPPS_PER_REG)
+
+/* Pin Ctrl driver definitions */
+#define BITS_PER_PIN		1
+#define PIN_FUNC_MASK		((1 << BITS_PER_PIN) - 1)
+#define PIN_REG_SHIFT		5
+#define PIN_FIELD_MASK		((1 << PIN_REG_SHIFT) - 1)
+
+/********************************/
+/* REF Clock and Boot device    */
+/********************************/
+#define MVEBU_XTAL_MODE_MASK		BIT9
+#define MVEBU_XTAL_MODE_OFFS		(9)
+#define MVEBU_XTAL_CLOCK_25MHZ		(0x0)
+#define MVEBU_XTAL_CLOCK_40MHZ		(0x1)
+
+#define MVEBU_BOOTMODE_OFFS		(5)
+#define MVEBU_BOOTMODE_MASK		(0x7 << MVEBU_BOOTMODE_OFFS)
+#define MVEBU_BOOTMODE_NONE		(0)
+#define MVEBU_BOOTMODE_SPI_NOR		(1)
+#define MVEBU_BOOTMODE_EMMC_NORM	(2)
+#define MVEBU_BOOTMODE_EMMC_ALT		(3)
+#define MVEBU_BOOTMODE_SATA		(4)
+#define MVEBU_BOOTMODE_SPI_NAND		(5)
+#define MVEBU_BOOTMODE_UART		(6)
+#define MVEBU_BOOTMODE_RSRVD		(7)
+
+#endif	/* _SOC_INFO_H_ */
diff --git a/arch/arm/include/asm/arch-armadalp/board-info.h b/arch/arm/include/asm/arch-armadalp/board-info.h
deleted file mode 100644
index 0487267..0000000
--- a/arch/arm/include/asm/arch-armadalp/board-info.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * ***************************************************************************
- * Copyright (C) 2015 Marvell International Ltd.
- * ***************************************************************************
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation, either version 2 of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * ***************************************************************************
- */
-
-/* Armada3700 Marvell boards */
-#include <dt-bindings/multi-fdt/multi-fdt.h>
-
-/*
-	ARMAMA3700_MARVELL_BOARD_ID_BASE = 0x10, for multi-fdt feature,
-	each Soc takes 0x10 boards that starts from 0x10, A8K has taken
-	0x10 to 0x1f, but since A8K and A3700 would not be compiled
-	together, to align with A8K, A3700 should also take 0x10 to 0x1f.
-	And as A3700 DB, it is the first board, should take board_id as 0x10.
-*/
-#define ARMAMA3700_MARVELL_BOARD_ID_BASE	 A3700_DB_ID
-#define ARMAMA3700_DB			(ARMAMA3700_MARVELL_BOARD_ID_BASE + 0)
-#define ARMAMA3700_MARVELL_MAX_BOARD_ID	(ARMAMA3700_MARVELL_BOARD_ID_BASE + 1)
-#define ARMAMA3700_MARVELL_BOARD_NUM	(ARMAMA3700_MARVELL_MAX_BOARD_ID - ARMAMA3700_MARVELL_BOARD_ID_BASE)
-
-#define MARVELL_BOARD_ID_BASE		ARMAMA3700_MARVELL_BOARD_ID_BASE
-#define MV_MAX_MARVELL_BOARD_ID		ARMAMA3700_MARVELL_MAX_BOARD_ID
-#define MV_MARVELL_BOARD_NUM		ARMAMA3700_MARVELL_BOARD_NUM
-#define MV_DEFAULT_BOARD_ID		ARMAMA3700_DB
-
-#define BOARD_DEV_TWSI_INIT_EEPROM 0x57
-#define MULTI_FDT_EEPROM_ADDR_LEN 2
-
-/*
-	fdt_config_id is ID for each dts for a certain board.
-	It starts from 1.
-	+ arch/arm/dts/armada-lp-db.dts, board_id = A3700_DB_CONFIG_ID_USB3..
-	+ arch/arm/dts/armada-lp-db-sgmii1.dts, board_id = A3700_DB_CONFIG_ID_SGMII1.
-*/
-#define DEFAULT_FDT_CONFIG_ID	A3700_DB_CONFIG_ID_USB3
-
-#define DEFAULT_FDT_PER_BOARD { \
-	DEFAULT_FDT_CONFIG_ID,	/* default fdt_config_id for armada-3700-db board */	\
-}
diff --git a/arch/arm/include/asm/arch-armadalp/clock.h b/arch/arm/include/asm/arch-armadalp/clock.h
deleted file mode 100644
index 8abf1f3..0000000
--- a/arch/arm/include/asm/arch-armadalp/clock.h
+++ /dev/null
@@ -1,580 +0,0 @@
-/*
- * ***************************************************************************
- * Copyright (C) 2015 Marvell International Ltd.
- * ***************************************************************************
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation, either version 2 of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * ***************************************************************************
- */
-
-#ifndef _ARMADALP_CLOCK_H_
-#define _ARMADALP_CLOCK_H_
-
-/* Spread Spectrum Clock */
-#undef MVEBU_A3700_ENABLE_SSC
-
-#ifdef MVEBU_A3700_ENABLE_SSC
-/* In order to use the SSC function, the KVCO must be operated above 2 GHz */
-#define MVEBU_KVCO_MIN		2000
-#else
-#define MVEBU_KVCO_MIN		1200
-#endif /* MVEBU_A3700_ENABLE_SSC */
-
-#define MVEBU_KVCO_MAX		3000
-
-/****************/
-/* North Bridge */
-/****************/
-#define MVEBU_NORTH_BRG_PLL_BASE		(MVEBU_NORTH_CLOCK_REGS_BASE + 0x200)
-#define MVEBU_NORTH_BRG_TBG_CFG			(MVEBU_NORTH_BRG_PLL_BASE + 0x0)
-#define MVEBU_NORTH_BRG_TBG_CTRL0		(MVEBU_NORTH_BRG_PLL_BASE + 0x4)
-#define MVEBU_NORTH_BRG_TBG_CTRL1		(MVEBU_NORTH_BRG_PLL_BASE + 0x8)
-#define MVEBU_NORTH_BRG_TBG_CTRL2		(MVEBU_NORTH_BRG_PLL_BASE + 0xC)
-#define MVEBU_NORTH_BRG_TBG_CTRL3		(MVEBU_NORTH_BRG_PLL_BASE + 0x10)
-#define MVEBU_NORTH_BRG_TBG_CTRL4		(MVEBU_NORTH_BRG_PLL_BASE + 0x14)
-#define MVEBU_NORTH_BRG_TBG_CTRL5		(MVEBU_NORTH_BRG_PLL_BASE + 0x18)
-#define MVEBU_NORTH_BRG_TBG_CTRL6		(MVEBU_NORTH_BRG_PLL_BASE + 0x1C)
-#define MVEBU_NORTH_BRG_TBG_CTRL7		(MVEBU_NORTH_BRG_PLL_BASE + 0x20)
-#define MVEBU_NORTH_BRG_TBG_CTRL8		(MVEBU_NORTH_BRG_PLL_BASE + 0x30)
-
-#define MVEBU_NORTH_CLOCK_TBG_SELECT_REG	(MVEBU_NORTH_CLOCK_REGS_BASE + 0x0)
-#define NB_CLK_TBG_SEL_MASK_ALL			(0x3F << 26)
-
-/* north bridge clock divider select registers */
-#define MVEBU_NORTH_CLOCK_DIVIDER_SELECT0_REG	(MVEBU_NORTH_CLOCK_REGS_BASE + 0x4)
-#define NB_CLK_DIV0_MASK_ALL			(BIT31 | (0x3 << 26) | BIT19 | (0x3F << 6))
-
-#define MVEBU_NORTH_CLOCK_DIVIDER_SELECT1_REG	(MVEBU_NORTH_CLOCK_REGS_BASE + 0x8)
-#define NB_CLK_DIV1_MASK_ALL			((0x3 << 30) | (0x7 << 21))
-
-#define MVEBU_NORTH_CLOCK_DIVIDER_SELECT2_REG	(MVEBU_NORTH_CLOCK_REGS_BASE + 0xC)
-#define NB_CLK_DIV2_MASK_ALL			(BIT31 | (0xF << 3))
-#define CPU_CNT_CLK_DIV_SEL_OFFS		(27)
-
-/* north bridge clock source register */
-#define MVEBU_NORTH_CLOCK_SELECT_REG		(MVEBU_NORTH_CLOCK_REGS_BASE + 0x10)
-#define NB_CLK_SEL_MASK_ALL			((0xFFFF << 16) | BIT14)
-
-/* north bridge clock enable register */
-#define MVEBU_NORTH_CLOCK_ENABLE_REG		(MVEBU_NORTH_CLOCK_REGS_BASE + 0x14)
-#define NB_ALL_CLK_ENABLE			(0x0)
-
-/****************/
-/* South Bridge */
-/****************/
-
-/* south bridge clock enable register */
-#define MVEBU_SOUTH_CLOCK_TBG_SELECT_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x0)
-#define SB_CLK_TBG_SEL_MASK_ALL			((0x3FF << 22) | (0x3 << 12) | 0x3F)
-#define GBE_125_TBG_SEL_OFFS			(10)
-
-#define MVEBU_SOUTH_CLOCK_DIVIDER_SELECT0_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x4)
-#define SB_CLK_DIV0_MASK_ALL			((0x1F << 27) | 0x7)
-#define AXI_CLK_PRSCL1_OFFS			(24)
-#define AXI_CLK_PRSCL2_OFFS			(21)
-#define USB32_SS_SYS_CLK_PRSCL1_OFFS		(18)
-#define USB32_SS_SYS_CLK_PRSCL2_OFFS		(15)
-#define USB32_USB2_SYS_CLK_PRSCL1_OFFS		(12)
-#define USB32_USB2_SYS_CLK_PRSCL2_OFFS		(9)
-
-#define MVEBU_SOUTH_CLOCK_DIVIDER_SELECT1_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x8)
-#define SB_CLK_DIV1_MASK_ALL			((0xFF << 24) | (0x7 << 15) | 0x3F)
-#define GBE_125_CLK_PRSCL_MASK			(0x7)
-#define GBE_125_CLK_PRSCL1_OFF			(9)
-#define GBE_125_CLK_PRSCL2_OFF			(6)
-
-#define MVEBU_SOUTH_CLOCK_DIVIDER_SELECT2_REG	(MVEBU_SOUTH_CLOCK_REGS_BASE + 0xC)
-#define SB_CLK_DIV2_MASK_ALL			((0xFFFFF << 12) | 0x3F)
-
-/* south bridge clock source register */
-#define MVEBU_SOUTH_CLOCK_SELECT_REG		(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x10)
-#define SB_AXI_CLK_SEL_OFFS			(10)
-#define USB32_SS_SYS_CLK_SEL_OFFS		(9)
-#define USB32_USB2_SYS_CLK_SEL_OFFS		(8)
-#define SDIO_CLK_SEL_OFFS			(7)
-#define GBE_CORE_CLK_SEL_OFFS			(5)
-#define GBE_125_CLK_SEL_OFFS			(3)
-#define GBE_50_CLK_SEL_OFFS			(1)
-
-
-/* south bridge clock enable register */
-#define MVEBU_SOUTH_CLOCK_ENABLE_REG		(MVEBU_SOUTH_CLOCK_REGS_BASE + 0x14)
-/* (GBE0 and GBE1 have reversed logic) */
-#define SB_ALL_CLK_ENABLE			(BIT19 | BIT20)
-
-/* AVS */
-#define MVEBU_AVS_CTRL_0			(MVEBU_AVS_REGS_BASE)
-#define AVS_SOFT_RESET				(BIT31)
-#define AVS_ENABLE				(BIT30)
-#define AVS_SEL_VSENCE0				(BIT28)
-#define AVS_SPEED_TARGET_MASK			(0x0000FFFF)
-#define AVS_HIGH_VDD_LIMIT_OFFS			(16)
-#define AVS_LOW_VDD_LIMIT_OFFS			(22)
-#define AVS_VDD_LIMIT_MASK			(0x3F)
-#define AVS_VDD_MIN				(0x0)	/* 640 mV */
-#define AVS_VDD_MAX				(0x33)	/* 1342 mV */
-
-/* The AVS voltage formula:  AVSmv = (1.05/0.9)*(640 + field_val * 10) */
-#define AVS_VDD_VAL(mv)				((((mv) * 90)/105 - 640)/10)
-#define AVS_VDD_800_MHZ_MV			(1150)	/* mV for CPU >= 800 MHz */
-#define AVS_VDD_600_MHZ_MV			(1100)	/* mV for CPU 600 MHz */
-
-
-enum a3700_clock_src {
-	TBG_A,
-	TBG_B
-};
-
-enum a3700_clock_line {
-	TBG_A_P = 0,
-	TBG_B_P = 1,
-	TBG_A_S = 2,
-	TBG_B_S = 3
-};
-
-/*
- * North Bridge Clocks
- */
-/* North Bridge clock line selectors (0x13000) */
-struct a3700_nb_clock_sel {
-	enum a3700_clock_line mmc_pclk_sel;		/* [1:0] */
-	enum a3700_clock_line sata_host_pclk_sel;	/* [3:2] */
-	enum a3700_clock_line sec_at_pclk_sel;		/* [5:4] */
-	enum a3700_clock_line sec_dap_pclk_sel;		/* [7:6] */
-	enum a3700_clock_line tsecm_pclk_sel;		/* [9:8] */
-	enum a3700_clock_line setm_tmx_pclk_sel;	/* [11:10] */
-	enum a3700_clock_line sqf_pclk_sel;		/* [13:12] */
-	enum a3700_clock_line pwm_pclk_sel;		/* [15:14] */
-	enum a3700_clock_line ddr_fclk_pclk_sel;	/* [17:16] */
-	enum a3700_clock_line trace_pclk_sel;		/* [19:18] */
-	enum a3700_clock_line counter_pclk_sel;		/* [21:20] */
-	enum a3700_clock_line a53_cpu_pclk_sel;		/* [23:22] */
-	enum a3700_clock_line eip97_pclk_sel;		/* [25:24] */
-};
-
-/* North Bridge clock divider 0 (0x13004) */
-struct a3700_nb_clock_div_0 {
-	u8 pwm_clk_prscl2;	/* [2:0] */
-	u8 pwm_clk_prscl1;	/* [5:3] */
-	u8 ddr_fclk_clk_prscl2;	/* [14:12] */
-	u8 ddr_fclk_clk_prscl1;	/* [17:15] */
-	u8 ddr_phy_mck_div_sel;	/* [18] */
-	u8 trace_div_sel;	/* [22:20] */
-	u8 counter_clk_prscl;	/* [25:23] */
-	u8 a53_cpu_clk_prscl;	/* [30:28] */
-};
-
-/* North Bridge clock divider 1 (0x13008) */
-struct a3700_nb_clock_div_1 {
-	u8 sec_at_clk_prscl2;	/* [2:0] */
-	u8 sec_at_clk_prscl1;	/* [5:3] */
-	u8 sec_dap_clk_prscl2;	/* [8:6] */
-	u8 sec_dap_clk_prscl1;	/* [11:9] */
-	u8 tsecm_clk_prscl2;	/* [14:12] */
-	u8 tsecm_clk_prscl1;	/* [17:15] */
-	u8 setm_tmx_clk_prscl;	/* [20:18] */
-	u8 sqf_clk_prscl2;	/* [26:24] */
-	u8 sqf_clk_prscl1;	/* [29:27] */
-};
-
-/* North Bridge clock divider 2 (0x1300C) */
-struct a3700_nb_clock_div_2 {
-	u8 wc_ahb_div_sel;	/* [2:0] */
-	u8 sata_h_clk_prscl2;	/* [9:7] */
-	u8 sata_h_clk_prscl1;	/* [12:10] */
-	u8 mmc_clk_prscl2;	/* [15:13] */
-	u8 mmc_clk_prscl1;	/* [18:16] */
-	u8 eip97_clk_prscl2;	/* [21:19] */
-	u8 eip97_clk_prscl1;	/* [24:22] */
-	u8 atb_clk_div_sel;	/* [26:25] */
-	u8 cpu_cnt_clk_div_sel;	/* [28:27] */
-	u8 plkdbg_clk_div_sel;	/* [30:29] */
-};
-
-/* North Bridge clock configuration */
-struct a3700_nb_clock_cfg {
-	struct a3700_nb_clock_sel	clock_sel;
-	struct a3700_nb_clock_div_0	div0;
-	struct a3700_nb_clock_div_1	div1;
-	struct a3700_nb_clock_div_2	div2;
-};
-
-/*
- * South Bridge Clocks
- */
- /* South Bridge clock line selectors (0x18000) */
-struct a3700_sb_clock_sel {
-	enum a3700_clock_line gbe_50_pclk_sel;		/* [7:6] */
-	enum a3700_clock_line gbe_core_pclk_sel;	/* [9:8] */
-	enum a3700_clock_line gbe_125_pclk_sel;		/* [11:10] */
-	enum a3700_clock_line sdio_pclk_sel;		/* [15:14] */
-	enum a3700_clock_line usb32_usb2_sys_pclk_sel;	/* [17:16] */
-	enum a3700_clock_line usb32_ss_sys_pclk_sel;	/* [19:18] */
-	enum a3700_clock_line sb_axi_pclk_sel;		/* [21:20] */
-};
-
-/* South Bridge clock divider 0 (0x18004) */
-struct a3700_sb_clock_div_0 {
-	u8 sdio_clk_prscl2;		/* [5:3] */
-	u8 sdio_clk_prscl1;		/* [8:6] */
-	u8 usb32_usb2_sys_clk_prscl2;	/* [11:9] */
-	u8 usb32_usb2_sys_clk_prscl1;	/* [14:12] */
-	u8 usb32_ss_sys_clk_prscl2;	/* [17:15] */
-	u8 usb32_ss_sys_clk_prscl1;	/* [20:18] */
-	u8 sb_axi_clk_prscl2;		/* [23:21] */
-	u8 sb_axi_clk_prscl1;		/* [24:24] */
-};
-
-/* South Bridge clock divider 1 (0x18008) */
-struct a3700_sb_clock_div_1 {
-	u8 gbe_125_clk_prscl2;		/* [8:6] */
-	u8 gbe_125_clk_prscl1;		/* [11:9] */
-	u8 gbe_bm_core_clk_div2_sel;	/* [12] */
-	u8 gbe1_core_clk_div2_sel;	/* [13] */
-	u8 gbe0_core_clk_div2_sel;	/* [14] */
-	u8 gbe_core_clk_prscl2;		/* [20:18] */
-	u8 gbe_core_clk_prscl1;		/* [23:21] */
-};
-
-/* South Bridge clock divider 2 (0x1800C) */
-struct a3700_sb_clock_div_2 {
-	u8 gbe_50_clk_prscl2;		/* [8:6] */
-	u8 gbe_50_clk_prscl1;		/* [11:9] */
-};
-
-/* South Bridge clock configuration */
-struct a3700_sb_clock_cfg {
-	struct a3700_sb_clock_sel	clock_sel;
-	struct a3700_sb_clock_div_0	div0;
-	struct a3700_sb_clock_div_1	div1;
-	struct a3700_sb_clock_div_2	div2;
-};
-
-struct a3700_tbg_cfg {
-	u32	kvco_mhz;
-	u32	se_vcodiv;
-	u32	diff_vcodiv;
-};
-
-/* System-wide clock configuration */
-struct a3700_clock_cfg {
-	u32				cpu_freq_mhz;
-	u32				ddr_freq_mhz;
-	struct a3700_tbg_cfg		tbg_a;
-	struct a3700_tbg_cfg		tbg_b;
-	struct a3700_nb_clock_cfg	nb_clk_cfg;
-	struct a3700_sb_clock_cfg	sb_clk_cfg;
-};
-
-/* This index points to configuration selected in MVEBU_A3700_CLOCK_CFGS
-   when DT entry is missing or invalid */
-#define MVEBU_A3700_DEF_CLOCK_PRESET_IDX	1
-
-/* Init values for the static clock configurations array */
-/*
-*************************************************************************************************************************************
-Configuration 0 – CPU 600, DDR 600
-
-		SE DIV	DIFF DIV
-KVCO-A	2400	1	1	← 2^n
-KVCO-B	2000	1	1	← 2^n						NB				SB
-=====================================================================================================================================
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-A-S	1200	3	1	sdio_pclk_sel		400	SB					DIV0[8:6]	DIV0[5:3]
-	2^n →	1	NA	ddr_phy_mck_div_sel	600	NB	DIV0[18]	NA
-		3	1	mmc_pclk_sel		400	NB	DIV2[15:13]	DIV2[18:16]
--------------------------------------------------------------------------------------------------------------------------------------
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-A-P	1200	2	NA	a53_cpu_pclk_sel	600	NB	DIV0[30:28]	NA
-		2	NA	wc_ahb_div_sel		300	NB	DIV2[2:0]	NA
-	2^n →	0	NA	atb_clk_div_sel		600	NB	DIV2[26:5]	NA
-	2^n →	1	NA	plkdbg_clk_div_sel	300	NB	DIV2[30:29]	NA
-		2	NA	setm_tmx_pclk_sel	600	NB	DIV1[20:18]	NA
-		2	NA	trace_pclk_sel		600	NB	DIV0[22:20]	NA
-		3	2	tsecm_pclk_sel		200	NB	DIV1[14:12]	DIV1[17:15]
-		3	2	sqf_pclk_sel		200	NB	DIV1[26:24]	DIV1[29:27]
--------------------------------------------------------------------------------------------------------------------------------------
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-B_S	1000	2	1	eip97_pclk_sel		500	NB	DIV2[24:22]	DIV2[21:19]
-		5	2	pwm_pclk_sel		100	NB	DIV0[5:3]	DIV0[2:0]
-		5	1	sec_at_pclk_sel		200	NB	DIV1[5:3]	DIV1[2:0]
-		5	2	sec_dap_pclk_sel	100	NB	DIV1[11:9]	DIV1[8:6]
-		5	1	sata_host_pclk_sel	200	NB	DIV2[9:7]	DIV2[12:10]
-		4	2	ddr_fclk_pclk_sel	125	NB	DIV0[17:15]	DIV0[14:12]
-		6	NA	counter_pclk_sel	167	NB	DIV0[25:23]	NA
-	2^n →	1	NA	cpu_cnt_clk_div_sel	83	NB	DIV2[28:27]	NA
-		4	1	gbe_core_pclk_sel	250	SB					DIV1[20:18]	DIV1[23:21]
-		1	NA	gbe_bm_core_clk_div2_sel250	SB					DIV1[12]	NA
-		1	NA	gbe1_core_clk_div2_sel	250	SB					DIV1[13]	NA
-		1	NA	gbe0_core_clk_div2_sel	250	SB					DIV1[14]	NA
-		4	2	gbe_125_pclk_sel	125	SB					DIV1[11:9]	DIV1[8:6]
-		5	1	sb_axi_pclk_sel		200	SB					DIV0[20:18]	DIV0[23:21]
-		4	2	usb32_ss_sys_pclk_sel	125	SB					DIV0[17:15]	DIV0[20:18]
-		5	2	usb32_usb2_sys_pclk_sel	100	SB					DIV0[14:12]	DIV0[11:9]
--------------------------------------------------------------------------------------------------------------------------------------
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-B-P	1000	4	5	gbe_50_pclk_sel		50	SB					DIV2[11:9]	DIV2[8:6]
-*************************************************************************************************************************************
-*************************************************************************************************************************************
-Configuration 1 – CPU 400, DDR 600
-
-		SE DIV	DIFF DIV
-KVCO-A	2400	1	1	← 2^n
-KVCO-B	1600	1	1	← 2^n						NB				SB
-=====================================================================================================================================
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-A-S	1200	5	2	sec_at_pclk_sel		120	NB	DIV1[5:3]	DIV1[2:0]
-		5	4	sec_dap_pclk_sel	60	NB	DIV1[11:9]	DIV1[8:6]
-		5	4	pwm_pclk_sel		60	NB	DIV0[5:3]	DIV0[2:0]
-		2	6	ddr_fclk_pclk_sel	100	NB	DIV0[17:15]	DIV0[14:12]
-		1	4	eip97_pclk_sel		300	NB	DIV2[24:22]	DIV2[21:19]
-		2	2	gbe_core_pclk_sel	300	SB					DIV1[20:18]	DIV1[23:21]
-		1	NA	gbe_bm_core_clk_div2_sel300	SB					DIV1[12]	NA
-		1	NA	gbe1_core_clk_div2_sel	300	SB					DIV1[13]	NA
-		1	NA	gbe0_core_clk_div2_sel	300	SB					DIV1[14]	NA
-		5	1	sdio_pclk_sel		240	SB					DIV0[8:6]	DIV0[5:3]
-		4	5	usb32_usb2_sys_pclk_sel	60	SB					DIV0[14:12]	DIV0[11:9]
-		3	4	usb32_ss_sys_pclk_sel	100	SB					DIV0[17:15]	DIV0[20:18]
-	2^n →	1	NA	ddr_phy_mck_div_sel	600	NB	DIV0[18]	NA
--------------------------------------------------------------------------------------------------------------------------------------
-		PRE-1	PRE-2	TARGET	FREQ		PRE-1	BR	PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-A-P	1200	4	5	gbe_50_pclk_sel		60	SB					DIV2[11:9]	DIV2[8:6]
--------------------------------------------------------------------------------------------------------------------------------------
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-B_S	800	4	1	mmc_pclk_sel		200	NB	DIV2[15:13]	DIV2[18:16]
-		5	1	sata_host_pclk_sel	160	NB	DIV2[9:7]	DIV2[12:10]
-		5	1	tsecm_pclk_sel		160	NB	DIV1[14:12]	DIV1[17:15]
-		2	NA	setm_tmx_pclk_sel	400	NB	DIV1[20:18]	NA
-		5	1	sqf_pclk_sel		160	NB	DIV1[26:24]	DIV1[29:27]
-		2	NA	trace_pclk_sel		400	NB	DIV0[22:20]	NA
-		5	NA	counter_pclk_sel	160	NB	DIV0[25:23]	NA
-	2^n →	1	NA	cpu_cnt_clk_div_sel	80	NB	DIV2[28:27]	NA
-		2	NA	a53_cpu_pclk_sel	400	NB	DIV0[30:28]	NA
-		2	NA	wc_ahb_div_sel		200	NB	DIV2[2:0]	NA
-	2^n →	0	NA	atb_clk_div_sel		400	NB	DIV2[26:5]	NA
-	2^n →	1	NA	plkdbg_clk_div_sel	200	NB	DIV2[30:29]	NA
-		3	2	gbe_125_pclk_sel	133	SB					DIV1[11:9]	DIV1[8:6]
-		2	2	sb_axi_pclk_sel		200	SB					DIV0[20:18]	DIV0[23:21]
--------------------------------------------------------------------------------------------------------------------------------------
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-B-P	800
-*************************************************************************************************************************************
-*************************************************************************************************************************************
-Configuration 2 – CPU 1000, DDR 800
-
-		SE DIV	DIFF DIV
-KVCO-A	1600	0	1	← 2^n
-KVCO-B	2000	1	2	← 2^n						NB				SB
-=====================================================================================================================================
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-A-S	1600	4	1	mmc_pclk_sel		400	NB	DIV2[15:13]	DIV2[18:16]
-	2^n →	1	NA	ddr_phy_mck_div_sel	800	NB	DIV0[18]	NA
-		4	1	sdio_pclk_sel		400	SB					DIV0[8:6]	DIV0[5:3]
--------------------------------------------------------------------------------------------------------------------------------------
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-A-P	800	5	NA	counter_pclk_sel	160	NB	DIV0[25:23]	NA
-	2^n →	1	NA	cpu_cnt_clk_div_sel	80	NB	DIV2[28:27]	NA
-		4	1	sqf_pclk_sel		200	NB	DIV1[26:24]	DIV1[29:27]
-		4	1	sata_host_pclk_sel	200	NB	DIV2[9:7]	DIV2[12:10]
-		4	1	tsecm_pclk_sel		200	NB	DIV1[14:12]	DIV1[17:15]
--------------------------------------------------------------------------------------------------------------------------------------
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-B_S	1000	5	1	sec_at_pclk_sel		200	NB	DIV1[5:3]	DIV1[2:0]
-		2	1	eip97_pclk_sel		500	NB	DIV2[24:22]	DIV2[21:19]
-		1	NA	setm_tmx_pclk_sel	1000	NB	DIV1[20:18]	NA
-		1	NA	trace_pclk_sel		1000	NB	DIV0[22:20]	NA
-		1	NA	a53_cpu_pclk_sel	1000	NB	DIV0[30:28]	NA
-		4	NA	wc_ahb_div_sel		250	NB	DIV2[2:0]	NA
-	2^n →	0	NA	atb_clk_div_sel		1000	NB	DIV2[26:5]	NA
-	2^n →	1	NA	plkdbg_clk_div_sel	500	NB	DIV2[30:29]	NA
-		4	2	ddr_fclk_pclk_sel	125	NB	DIV0[17:15]	DIV0[14:12]
-		5	2	sec_dap_pclk_sel	100	NB	DIV1[11:9]	DIV1[8:6]
-		5	2	pwm_pclk_sel		100	NB	DIV0[5:3]	DIV0[2:0]
-		4	1	gbe_core_pclk_sel	250	SB					DIV1[20:18]	DIV1[23:21]
-		1	NA	gbe_bm_core_clk_div2_sel250	SB					DIV1[12]	NA
-		1	NA	gbe1_core_clk_div2_sel	250	SB					DIV1[13]	NA
-		1	NA	gbe0_core_clk_div2_sel	250	SB					DIV1[14]	NA
-		4	2	gbe_125_pclk_sel	125	SB					DIV1[11:9]	DIV1[8:6]
-		2	2	sb_axi_pclk_sel		250	SB					DIV0[20:18]	DIV0[23:21]
-		4	2	usb32_ss_sys_pclk_sel	125	SB					DIV0[17:15]	DIV0[20:18]
-		5	2	usb32_usb2_sys_pclk_sel	100	SB					DIV0[14:12]	DIV0[11:9]
--------------------------------------------------------------------------------------------------------------------------------------
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-B-P	500	2	5	gbe_50_pclk_sel		50	SB					DIV2[11:9]	DIV2[8:6]
-*************************************************************************************************************************************
-*************************************************************************************************************************************
-Configuration 3 – CPU 800, DDR 800
-
-		SE DIV	DIFF DIV
-KVCO-A	1600	0	1	← 2^n
-KVCO-B	2000	1	2	← 2^n						NB				SB
-=====================================================================================================================================
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-A-S	1600	4	1	mmc_pclk_sel		400	NB	DIV2[15:13]	DIV2[18:16]
-	2^n →	1	NA	ddr_phy_mck_div_sel	800	NB	DIV0[18]	NA
-		4	1	sdio_pclk_sel		400	SB					DIV0[8:6]	DIV0[5:3]
--------------------------------------------------------------------------------------------------------------------------------------
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-A-P	800	5	NA	counter_pclk_sel	160	NB	DIV0[25:23]	NA
-	2^n →	1	NA	cpu_cnt_clk_div_sel	80	NB	DIV2[28:27]	NA
-		4	1	sqf_pclk_sel		200	NB	DIV1[26:24]	DIV1[29:27]
-		4	1	sata_host_pclk_sel	200	NB	DIV2[9:7]	DIV2[12:10]
-		4	1	tsecm_pclk_sel		200	NB	DIV1[14:12]	DIV1[17:15]
-		2	1	eip97_pclk_sel		400	NB	DIV2[24:22]	DIV2[21:19]
-		1	NA	setm_tmx_pclk_sel	800	NB	DIV1[20:18]	NA
-		1	NA	trace_pclk_sel		800	NB	DIV0[22:20]	NA
-		1	NA	a53_cpu_pclk_sel	800	NB	DIV0[30:28]	NA
-		4	NA	wc_ahb_div_sel		200	NB	DIV2[2:0]	NA
-	2^n →	0	NA	atb_clk_div_sel		800	NB	DIV2[26:5]	NA
-	2^n →	1	NA	plkdbg_clk_div_sel	400	NB	DIV2[30:29]	NA
--------------------------------------------------------------------------------------------------------------------------------------
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-B_S	1000	5	1	sec_at_pclk_sel		200	NB	DIV1[5:3]	DIV1[2:0]
-		4	2	ddr_fclk_pclk_sel	125	NB	DIV0[17:15]	DIV0[14:12]
-		5	2	sec_dap_pclk_sel	100	NB	DIV1[11:9]	DIV1[8:6]
-		5	2	pwm_pclk_sel		100	NB	DIV0[5:3]	DIV0[2:0]
-		4	1	gbe_core_pclk_sel	250	SB					DIV1[20:18]	DIV1[23:21]
-		1	NA	gbe_bm_core_clk_div2_sel250	SB					DIV1[12]	NA
-		1	NA	gbe1_core_clk_div2_sel	250	SB					DIV1[13]	NA
-		1	NA	gbe0_core_clk_div2_sel	250	SB					DIV1[14]	NA
-		4	2	gbe_125_pclk_sel	125	SB					DIV1[11:9]	DIV1[8:6]
-		2	2	sb_axi_pclk_sel		250	SB					DIV0[20:18]	DIV0[23:21]
-		4	2	usb32_ss_sys_pclk_sel	125	SB					DIV0[17:15]	DIV0[20:18]
-		5	2	usb32_usb2_sys_pclk_sel	100	SB					DIV0[14:12]	DIV0[11:9]
--------------------------------------------------------------------------------------------------------------------------------------
-		PRE-1	PRE-2	TARGET			FREQ	BR	PRE-1		PRE-2		PRE-1		PRE-2
--------------------------------------------------------------------------------------------------------------------------------------
-TBG-B-P	500	2	5	gbe_50_pclk_sel		50	SB					DIV2[11:9]	DIV2[8:6]
-*************************************************************************************************************************************
-*/
-/* Init values for the static clock configurations array */
-#define MVEBU_A3700_CLOCK_CFGS	{\
-	 /* Clock tree configuration entry 0 (testing, not yet fully functional) */\
-	{ 600, 600, /* CPU, DDR */\
-		{2400, 1, 1}, /* TBG-A: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
-		{2000, 1, 1}, /* TBG-B: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
-		/* NorthBridge */\
-		{{TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S, TBG_A_P, TBG_A_P, TBG_A_P,\
-		  TBG_B_S, TBG_B_S, TBG_A_P, TBG_B_S, TBG_A_P, TBG_B_S},\
-		 {2, 5, 2, 4, 1, 2, 6, 2},		/* DIV0 */\
-		 {1, 5, 2, 5, 2, 3, 2, 2, 3},		/* DIV1 */\
-		 {2, 1, 5, 1, 3, 1, 2, 0, 1, 1} },	/* DIV2 */\
-		/* SouthBridge */\
-		{{TBG_B_P, TBG_B_S, TBG_B_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S},\
-		 {1, 3, 2, 5, 2, 4, 1, 5},	/* DIV0 */\
-		 {2, 4, 1, 1, 1, 4, 1},		/* DIV1 */\
-		 {5, 4} }			/* DIV2 */\
-	},\
-	/* Clock tree configuration entry 1 (default working setup) */\
-	{ 400, 600, /* CPU, DDR */\
-		{2400, 1, 1}, /* TBG-A: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
-		{1600, 1, 1}, /* TBG-B: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
-		/* NorthBridge */\
-		{{TBG_B_S, TBG_B_S, TBG_A_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S,\
-		 TBG_A_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S, TBG_A_S},\
-		{4, 5, 6, 2, 1, 2, 5, 2},		/* DIV0 */\
-		{2, 5, 4, 5, 1, 5, 2, 1, 5},		/* DIV1 */\
-		{2, 1, 5, 1, 4, 1, 4, 0, 1, 1} },	/* DIV2 */\
-		/* SouthBridge */\
-		{{TBG_A_P, TBG_A_S, TBG_B_S, TBG_A_S, TBG_A_S, TBG_A_S, TBG_B_S},\
-		{1, 5, 5, 4, 3, 4, 2, 2},	/* DIV0 */\
-		{2, 3, 1, 1, 1, 2, 4},		/* DIV1 */\
-		{5, 4} }			/* DIV2 */\
-	},\
-	/* Clock tree configuration entry 2 */\
-	{ 1000, 800, /* CPU, DDR */\
-		{1600, 0, 1}, /* TBG-A: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
-		{2000, 1, 2}, /* TBG-B: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
-		/* NorthBridge */\
-		{{TBG_A_S, TBG_A_P, TBG_B_S, TBG_B_S, TBG_A_P, TBG_B_S, TBG_A_P,\
-		  TBG_B_S, TBG_B_S, TBG_B_S, TBG_A_P, TBG_B_S, TBG_B_S},\
-		{4, 5, 2, 4, 1, 1, 5, 1},		/* DIV0 */\
-		{1, 5, 2, 5, 1, 4, 1, 1, 4},		/* DIV1 */\
-		{2, 1, 4, 1, 4, 2, 1, 0, 1, 1} },	/* DIV2 */\
-		/* SouthBridge */\
-		{{TBG_B_P, TBG_B_S, TBG_B_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S},\
-		{1, 4, 2, 5, 2, 4, 2, 2},	/* DIV0 */\
-		{2, 4, 1, 1, 1, 4, 1},		/* DIV1 */\
-		{5, 2} }			/* DIV2 */\
-	},\
-	/* Clock tree configuration entry 3 */\
-	{ 800, 800, /* CPU, DDR */\
-		{1600, 0, 1}, /* TBG-A: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
-		{2000, 1, 2}, /* TBG-B: KVCO Freq, SE_VCODIV, DIFF_VCODIV */\
-		/* NorthBridge */\
-		{{TBG_A_S, TBG_A_P, TBG_B_S, TBG_B_S, TBG_A_P, TBG_A_P, TBG_A_P,\
-		  TBG_B_S, TBG_B_S, TBG_A_P, TBG_A_P, TBG_A_P, TBG_A_P},\
-		{4, 5, 2, 4, 1, 1, 5, 1},		/* DIV0 */\
-		{1, 5, 2, 5, 1, 4, 1, 1, 4},		/* DIV1 */\
-		{2, 1, 4, 1, 4, 2, 1, 0, 1, 1} },	/* DIV2 */\
-		/* SouthBridge */\
-		{{TBG_B_P, TBG_B_S, TBG_B_S, TBG_A_S, TBG_B_S, TBG_B_S, TBG_B_S},\
-		{1, 4, 2, 5, 2, 4, 2, 2},	/* DIV0 */\
-		{2, 4, 1, 1, 1, 4, 1},		/* DIV1 */\
-		{5, 2} }			/* DIV2 */\
-	},\
-}
-
-/*****************************************************************************
-* get_ref_clk
-*
-* return: reference clock in MHz (25 or 40)
-******************************************************************************/
-u32 get_ref_clk(void);
-
-/*****************************************************************************
-* get_cpu_clk
-*
-* return: current CPU clock in Mhz
-******************************************************************************/
-u32 get_cpu_clk(void);
-
-/*****************************************************************************
-* get_ddr_clk
-*
-* return: current DDR clock in Mhz
-******************************************************************************/
-u32 get_ddr_clk(void);
-
-
-/******************************************************************************
-* Name: set_clocks
-*
-* Description: Configure entire clock tree according to CPU and DDR frequency
-*
-* Input:	cpu_clk_mhz: required CPU clock
-*		ddr_clk_mhz: required DDR clock
-*		tbg_a_kvco_mhz: required TBG-A KVCO frequency or 0 for any available
-*		tbg_b_kvco_mhz: required TBG-B KVCO frequency or 0 for any available
-* Output:	None
-* Return:	Non-zero if the requested settings are not supported
-******************************************************************************/
-u32 set_clocks(u32 cpu_clk_mhz, u32 ddr_clk_mhz, u32 tbg_a_kvco_mhz, u32 tbg_b_kvco_mhz);
-
-int init_clock(void);
-
-#endif /* _ARMADALP_CLOCK_H_ */
diff --git a/arch/arm/include/asm/arch-armadalp/gpio.h b/arch/arm/include/asm/arch-armadalp/gpio.h
deleted file mode 100644
index c4e69d1..0000000
--- a/arch/arm/include/asm/arch-armadalp/gpio.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * ***************************************************************************
- * Copyright (C) 2015 Marvell International Ltd.
- * ***************************************************************************
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation, either version 2 of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * ***************************************************************************
- */
-
-#ifndef _MVEBU_GPIO_H_
-#define _MVEBU_GPIO_H_
-
-#define MVEBU_GPIO_NB_OUTPUT_EN_REG		(MVEBU_GPIO_NB_REG_BASE)
-#define MVEBU_GPIO_NB_OUTPUT_EN_HIGH_REG	(MVEBU_GPIO_NB_REG_BASE + 0x4)
-#define MVEBU_GPIO_NB_OUTPUT_SPI_EN_OFF		(28)/* This is hidden bit which is reserved in function spec */
-#define MVEBU_GPIO_NB_OUTPUT_VAL_REG		(MVEBU_GPIO_NB_REG_BASE + 0x18)
-#define MVEBU_GPIO_NB_SEL_REG			(MVEBU_GPIO_NB_REG_BASE + 0x30)
-#define MVEBU_GPIO_TW1_GPIO_EN_OFF		(10)
-#define MVEBU_GPIO_SPI_GPIO_EN_OFF		(18)
-
-#define MVEBU_GPIO_SB_OUTPUT_EN_REG		(MVEBU_GPIO_SB_REG_BASE)
-#define MVEBU_GPIO_SB_OUTPUT_VAL_REG		(MVEBU_GPIO_SB_REG_BASE + 0x18)
-#define MVEBU_GPIO_PCIE_RESET_OFF		(3)
-#define MVEBU_GPIO_SDIO_VOLTAGE_3_3V		(0)
-#define MVEBU_GPIO_SDIO_VOLTAGE_1_8V		(1)
-#define MVEBU_GPIO_SDIO_VOLTAGE_OFF		(22)
-#define MVEBU_GPIO_SB_SEL_REG			(MVEBU_GPIO_SB_REG_BASE + 0x30)
-#define MVEBU_GPIO_SB_SDIO_EN_OFF		(2)
-#define MVEBU_GPIO_RGMII_GPIO_EN_OFF		(3)
-#define MVEBU_GPIO_PCIE_EN_OFF			(4)
-
-void mvebu_set_sdio(int voltage);
-void mvebu_reset_pcie_dev(void);
-void mvebu_init_gpio(void);
-
-#endif /* _MVEBU_GPIO_H_ */
diff --git a/arch/arm/include/asm/arch-armadalp/mbus_reg.h b/arch/arm/include/asm/arch-armadalp/mbus_reg.h
deleted file mode 100644
index 03e29c2..0000000
--- a/arch/arm/include/asm/arch-armadalp/mbus_reg.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
-* ***************************************************************************
-* Copyright (C) 2015 Marvell International Ltd.
-* ***************************************************************************
-* This program is free software: you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the Free
-* Software Foundation, either version 2 of the License, or any later version.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program.  If not, see <http://www.gnu.org/licenses/>.
-* ***************************************************************************
-*/
-
-#ifndef _MBUS_ARLP_H_
-#define _MBUS_ARLP_H_
-
-#define MBUS_WIN_CTRL_REG(win_num)		(win_num * 0x10)
-#define MBUS_CR_WIN_ENABLE				0x1
-#define MBUS_CR_WIN_TARGET_OFFS			4
-#define MBUS_CR_WIN_TARGET_MASK			(0xf << MBUS_CR_WIN_TARGET_OFFS)
-#define MBUS_CR_WIN_ATTR_OFFS			8
-#define MBUS_CR_WIN_ATTR_MASK			(0xff << MBUS_CR_WIN_ATTR_OFFS)
-
-#define MBUS_WIN_SIZE_REG(win_num)		(0x4 + win_num * 0x10)
-#define MBUS_CR_WIN_SIZE_OFFS			0
-#define MBUS_CR_WIN_SIZE_MASK			(0xffffff << MBUS_CR_WIN_SIZE_OFFS)
-#define MBUS_CR_WIN_SIZE_ALIGNMENT		0x10000
-
-
-#define MBUS_WIN_BASE_REG(win_num)		(0x8 + win_num * 0x10)
-#define MBUS_BR_BASE_OFFS				0
-#define MBUS_BR_BASE_MASK				(0xffffff <<  MBUS_BR_BASE_OFFS)
-
-#define MBUS_WIN_REMAP_LOW_REG(win_num)	(0xc + win_num * 0x10)
-#define MBUS_RLR_REMAP_LOW_OFFS			0
-#define MBUS_RLR_REMAP_LOW_MASK			(0xffffff << MBUS_RLR_REMAP_LOW_OFFS)
-
-/* there is no remap_high reg in ArmadaLP, just define here to pass compilation */
-#define MBUS_WIN_REMAP_HIGH_REG(win_num)	(0xc + win_num * 0x10)
-
-#define MBUS_WIN_INTEREG_REG			(0xF0)
-
-#endif	/* _MBUS_ARLP_H_ */
-
diff --git a/arch/arm/include/asm/arch-armadalp/memory-map.h b/arch/arm/include/asm/arch-armadalp/memory-map.h
deleted file mode 100644
index 6e249cf..0000000
--- a/arch/arm/include/asm/arch-armadalp/memory-map.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
-* ***************************************************************************
-* Copyright (C) 2015 Marvell International Ltd.
-* ***************************************************************************
-* This program is free software: you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the Free
-* Software Foundation, either version 2 of the License, or any later version.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program.  If not, see <http://www.gnu.org/licenses/>.
-* ***************************************************************************
-*/
-
-/* Memory Map */
-/* 0x00000000 - 0x7FFFFFFF - DRAM */
-/* 0x80000000 - 0x8FFFFFFF - IHB-PCIe */
-/* 0xD0000000 - 0xD0300000 - Internal Reg */
-/* 0xD0700000 - 0xD070FFFF - CCI */
-/* 0xE0000000 - 0xE7FFFFFF - IHB */
-/* 0xE8000000 - 0xEFFFFFFF - PCIe */
-/* 0xF0000000 - 0xF001FFFF - rWTM */
-/* 0xFFF00000 - 0xFFFFFFFF - Boot Room */
-
-#ifdef __ASSEMBLY__
-#define MVEBU_REGS_BASE		(0xD0000000)
-#else
-#define MVEBU_REGS_BASE		(0xD0000000UL)
-#endif
-#define MVEBU_REGS_SIZE		(0x300000)
-
-
diff --git a/arch/arm/include/asm/arch-armadalp/misc-regs.h b/arch/arm/include/asm/arch-armadalp/misc-regs.h
deleted file mode 100644
index 9dfe1d8..0000000
--- a/arch/arm/include/asm/arch-armadalp/misc-regs.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
-* ***************************************************************************
-* Copyright (C) 2015 Marvell International Ltd.
-* ***************************************************************************
-* This program is free software: you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the Free
-* Software Foundation, either version 2 of the License, or any later version.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program.  If not, see <http://www.gnu.org/licenses/>.
-* ***************************************************************************
-*/
-
-#ifndef _MISC_REGS_H_
-#define _MISC_REGS_H_
-#include <asm/arch/regs-base.h>
-
-#define MVEBU_NB_PM_PWRDWN_OPT_REG     (MVEBU_NORTH_PM_REGS_BASE + 0x8)
-#define L2_SRAM_LKG_PD_EN              (BIT8)
-#define CPU_ROM_PD_EN                  (BIT10)
-#define AVS_DISABLE_MODE               (BIT14)
-#define DDRPHY_PAD_PWRDWN_EN           (BIT22)
-
-#define MVEBU_AXI_DCTRL_CTRL_RST_REG   (MVEBU_AXI_DCTRL_REGS_BASE)
-#define DDRPHY_MODE_SELECT             (BIT16)         /* 0: 2 to 1, 1: 4 to 1 */
-
-#define MVEBU_AXI_DCTRL_MCM_SEL_REG    (MVEBU_AXI_DCTRL_REGS_BASE + 0x4)
-
-
-#endif /* _MISC_REGS_H_ */
diff --git a/arch/arm/include/asm/arch-armadalp/pcie-core.h b/arch/arm/include/asm/arch-armadalp/pcie-core.h
deleted file mode 100644
index f0f5f39..0000000
--- a/arch/arm/include/asm/arch-armadalp/pcie-core.h
+++ /dev/null
@@ -1,408 +0,0 @@
-/*
-* ***************************************************************************
-* Copyright (C) 2015 Marvell International Ltd.
-* ***************************************************************************
-* This program is free software: you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the Free
-* Software Foundation, either version 2 of the License, or any later version.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program.  If not, see <http://www.gnu.org/licenses/>.
-* ***************************************************************************
-*/
-/* pcie-core.h
- *
- * Definition for PCIe core unit
- *
- * Author: Victor Gu <xigu@marvell.com>
- *
- * March 6, 2015
- *
- */
-
-#ifndef _PCIE_CORE_H_
-#define _PCIE_CORE_H_
-
-#include <asm/arch/memory-map.h>
-#include <asm/arch-mvebu/mvebu.h>
-#include <pci.h>
-
-/* ArLP RC has only 1 port */
-#define PCIE_ADVK_MAX_PORT	(1)
-
-/*
- * Make it 1 because we fake up internal bus 0.
- * We fake up internal bus 0 because we assume root port 0
- * is on bus 0. In that case, if we send a config TLP to
- * Endpoint device on bus 1, it must be a Type 1 TLP.
- * However, it's not. Because we only have one link, without
- * any internal bus.
- * If we don't fake internal bus, then just leave it 0.
- */
-#define PCIE_ADVK_ACTUAL_FIRST_BUSNO	1
-
-#define SIZE_8BIT	1
-#define SIZE_16BIT	2
-#define SIZE_32BIT	4
-
-#define LOCAL_VENDOR_ID		0x11AB
-#define LOCAL_DEVICE_ID		0x0
-#define LOCAL_SUBVENDOR_ID	0x11AB
-#define LOCAL_SUBDEVICE_ID	0x0
-#define LOCAL_CLASS_CODE	0x2
-#define LOCAL_SUBCLASS_CODE	0x0
-#define LOCAL_REVISION_ID	0x0
-#define LOCAL_PROGIF_CODE	0x0
-
-#define BAR_PCIE_MEM		0x0
-#define BAR_PCIE_REG		0x4
-
-/*
- * Used in PIO read/write
- * Should choose this value more carefully
- */
-#define PCIE_CORE_PIO_TIMEOUT_NUM	1000
-#define PCIE_CORE_PIO_ADDR_MASK	0xfffffffc
-/* This defines the size of VPD RAM */
-#define PCIE_CORE_VPD_RAM_SIZE	0x400 /*1K*/
-
-/* Time out number to get PCIe link up */
-#define PCIE_LINK_TIMEOUT_NUM	1000
-
-/* Transaction types */
-#define PCIE_MEM_RD		0x0
-#define PCIE_MEM_WR		0x2
-#define PCIE_IO_RD		0x4
-#define PCIE_IO_WR		0x6
-#define PCIE_CONFIG_RD_TYPE0	0x8
-#define PCIE_CONFIG_RD_TYPE1	0x9
-#define PCIE_CONFIG_WR_TYPE0	0xa
-#define PCIE_CONFIG_WR_TYPE1	0xb
-#define PCIE_MSG_REQ		0xc
-
-/* Message codes
- * virtual legacy interrupt messages
- */
-#define MSG_ASSERT_INTA		0x20
-#define MSG_ASSERT_INTB		0x21
-#define MSG_ASSERT_INTC		0x22
-#define MSG_ASSERT_INTD		0x23
-#define MSG_DEASSERT_INTA	0x24
-#define MSG_DEASSERT_INTB	0x25
-#define MSG_DEASSERT_INTC	0x26
-#define MSG_DEASSERT_INTD	0x27
-
-/* Power related messages */
-#define MSG_PM_ACTIVE_STATE_NAK	0x14
-#define MSG_PM_PME		0x18
-#define MSG_PM_TURN_OFF		0x19
-#define MSG_PM_TO_ACK		0x1b
-
-/* Error messages */
-#define MSG_ERR_COR		0x30
-#define MSG_ERR_NONFATAL	0x31
-#define MSG_ERR_FATAL		0x33
-
-/* Unlock message */
-#define MSG_UNLOCK		0x00
-
-/* Slot power limit set message */
-#define MSG_SET_SLOT_POWER_LIMIT	0x50
-
-/* Hot-Plug related messages */
-#define MSG_ATT_INDICATOR_ON		0x41
-#define MSG_ATT_INDICATOR_BLINK		0x43
-#define MSG_ATT_INDICATOR_OFF		0x40
-#define MSG_POWER_INDICATOR_ON		0x45
-#define MSG_POWER_INDICATOR_BLINK	0x47
-#define MSG_POWER_INDICATOR_OFF		0x44
-#define MSG_ATT_BUTTON_PRESSED		0x48
-
-#define PCIE_CORE_DEV_CTRL_STATS_REG	0xC8
-#define PCIE_CORE_LINK_CTRL_STAT_REG	0xD0
-#define PCIE_CORE_LINK_TRAINING_SHIFT	5
-#define PCIE_CORE_LINK_SPEED_SHIFT	16
-#define PCIE_CORE_LINK_SPEED_MASK	0xF
-#define PCIE_CORE_LINK_WIDTH_SHIFT	20
-#define PCIE_CORE_LINK_WIDTH_MASK	0x3F
-#define PCIE_CORE_LINK_DLL_STATE_SHIFT	29
-#define PCIE_CORE_LINK_DLL_STATE_MASK	0x1
-
-#define PCIE_DLL_STATE_ACTIVE	1
-#define PCIE_DLL_STATE_INACTIVE	0
-
-#define PCIE_CORE_ERR_CAP_CTRL_REG	0x118
-
-/* Shift */
-#define PCIE_CORE_PIO_CTRL_BYTE_COUNT_SHIFT	16
-
-/* Aardvark PIO registers */
-#define PIO_BASE_ADDR			0x4000
-#define PCIE_CORE_PIO_CTRL		0x0
-#define PCIE_CORE_PIO_STAT		0x4
-#define PCIE_CORE_PIO_ADDR_LS		0x8
-#define PCIE_CORE_PIO_ADDR_MS		0xc
-#define PCIE_CORE_PIO_WR_DATA		0x10
-#define PCIE_CORE_PIO_WR_DATA_STRB	0x14
-#define PCIE_CORE_PIO_RD_DATA		0x18
-#define PCIE_CORE_PIO_START		0x1c
-#define PCIE_CORE_PIO_ISR		0x20
-#define PCIE_CORE_PIO_ISRM		0x24
-
-/* Aardvark PCIe DPMU registers */
-#define DPMU_BASE_ADDR			0x4400
-#define PCIE_CORE_DPMU_CTRL0		0x0
-
-/* Aardvark Control registers */
-#define CONTROL_BASE_ADDR	0x4800
-#define PCIE_CORE_CTRL0_REG	0x0
-#define PCIE_GEN_SEL_MSK	0x3
-#define PCIE_GEN_SEL_SHIFT	0x0
-#define SPEED_GEN_1		0
-#define SPEED_GEN_2		1
-#define SPEED_GEN_3		2
-#define IS_RC_MSK		0x4
-#define IS_RC_SHIFT		2
-#define LANE_CNT_MSK		0x18
-#define LANE_CNT_SHIFT		0x3
-#define LANE_COUNT_1		(0 << LANE_CNT_SHIFT)
-#define LANE_COUNT_2		(1 << LANE_CNT_SHIFT)
-#define LANE_COUNT_4		(2 << LANE_CNT_SHIFT)
-#define LANE_COUNT_8		(3 << LANE_CNT_SHIFT)
-#define LINK_TRAINNING_EN	BIT6
-#define CORE_RESET_MSK		BIT7
-#define MGMT_RESET_MSK		BIT8
-#define MGMT_STICKY_RESET_MSK	BIT9
-#define APP_RESET_MSK		BIT16
-#define LEGACY_INTA		BIT28
-#define LEGACY_INTB		BIT29
-#define LEGACY_INTC		BIT30
-#define LEGACY_INTD		BIT31
-#define PCIE_CORE_CTRL1_REG	0x4
-#define HOT_RESET_GEN		BIT0
-#define PCIE_CORE_CTRL2_REG	0x8
-#define STRICT_ORDER_ENABLE	BIT5
-#define OB_WIN_ENABLE		BIT6
-#define MSI_ENABLE		BIT10
-#define PCIE_CORE_FLUSH_REG	0xC
-#define PCIE_CORE_FLUSH_TIMER_MASK	0xFFFF
-#define PCIE_CORE_FORCE_FLUSH	BIT16
-#define PCIE_CORE_FLUSH_ACTIVE	BIT17
-#define PCIE_CORE_FLUSH_CLEAR	BIT18
-#define PCIE_CORE_PWR_CTRL_REG	0x10
-#define REQ_PM_TRANSITION_L23	(1 << 0)
-#define POWER_STATE_CHANGE_ACK	(1 << 1)
-#define PCIE_CORE_PHY_REF_CLK_REG	0x14
-#define PCIE_CORE_EN_TX		(1 << 1)
-#define PCIE_CORE_EN_RX		(1 << 2)
-#define PCIE_CORE_SEL_AMP_MASK	0x7
-#define PCIE_CORE_SEL_AMP_SHIFT	0x8
-#define PCIE_CORE_EN_PU		(1 << 12)
-#define PCIE_CORE_MSG_LOG0		0x30
-#define PCIE_CORE_MSG_LOG0_MSK		0xFF
-#define PCIE_CORE_ISR0			0x40
-#define PCIE_CORE_ISR0_HOT_RESET		BIT0
-#define PCIE_CORE_ISR0_LINK_DOWN		BIT1
-#define PCIE_CORE_ISR0_INB_MSG			BIT2
-#define PCIE_CORE_ISR0_DP_PERR			BIT3
-#define PCIE_CORE_ISR0_DP_FERR			BIT4
-#define PCIE_CORE_ISR0_MSG_PME2ACK		BIT5
-#define PCIE_CORE_ISR0_MSG_PM_TURN_OFF		BIT6
-#define PCIE_CORE_ISR0_MSG_PM_PME		BIT7
-#define PCIE_CORE_ISR0_MSG_PM_ACTIVE_NAK	BIT8
-#define PCIE_CORE_ISR0_LEGACY_INT_SENT		BIT9
-#define PCIE_CORE_ISR0_LEGACY_INTA_ASSERT	BIT16
-#define PCIE_CORE_ISR0_LEGACY_INTB_ASSERT	BIT17
-#define PCIE_CORE_ISR0_LEGACY_INTC_ASSERT	BIT18
-#define PCIE_CORE_ISR0_LEGACY_INTD_ASSERT	BIT19
-#define PCIE_CORE_ISR0_LEGACY_INTA_DEASSERT	BIT20
-#define PCIE_CORE_ISR0_LEGACY_INTB_DEASSERT	BIT21
-#define PCIE_CORE_ISR0_LEGACY_INTC_DEASSERT	BIT22
-#define PCIE_CORE_ISR0_LEGACY_INTD_DEASSERT	BIT23
-#define PCIE_CORE_ISRM0				0x44
-#define PCIE_CORE_ISR1				0x48
-#define PCIE_CORE_ISR1_PWR_CHANGE_STATE		BIT4
-#define PCIE_CORE_ISR1_FLUSH_OFF		BIT5
-#define PCIE_CORE_ISRM1				0x4c
-#define PCIE_CORE_MSI_MSG_LOW_ADDR		0x50
-#define PCIE_CORE_MSI_MSG_HIGH_ADDR		0x54
-#define PCIE_CORE_MSI_MSG_ISR_STAT		0x58
-#define PCIE_CORE_MSI_MSG_ISR_MASK		0x5c
-#define PCIE_CORE_DP_PAR_CNTL	0x60
-#define PCIE_CORE_DP_PAR_STAT0	0x64
-#define PCIE_CORE_DP_PAR_STAT1	0x68
-
-/* Victor: below PF/VF register do not exist in ArLP */
-#define PCIE_CORE_PF_FLR_CTRL	0x80
-#define PCIE_CORE_PF_FLR_STAT	0x84
-#define PCIE_CORE_VF_FLR_CTRL	0x88
-#define PCIE_CORE_VF_FLR_TRL	0x8c
-
-#define PCIE_CORE_MSI_PAYLOAD	0x9c
-
-#define OB_WIN_BASE_ADDR	0x4c00
-#define OB_WIN_MATCH_LS		0x00
-#define OB_WIN_MATCH_MS		0x04
-#define OB_WIN_REMAP_LS		0x08
-#define OB_WIN_REMAP_MS		0x0c
-#define OB_WIN_MASK_LS		0x10
-#define OB_WIN_MASK_MS		0x14
-#define OB_WIN_ACTIONS		0x18
-
-#define OB_WIN_BLOCK_SIZE	0x20
-
-#define OB_Default_ACTIONS	0xfc
-
-#define OB_PCIE_MEM		0x0
-#define OB_PCIE_IO		0x4
-#define OB_PCIE_CONFIG0		0x8
-#define OB_PCIE_CONFIG1		0x9
-#define OB_PCIE_MSG		0xc
-#define OB_PCIE_MSG_VENDOR	0xd
-
-#define OB_ATTR_SEL		BIT11
-#define OB_FUNC_SEL		BIT23
-
-/* PCIe address translation registers */
-#define ADDR_TRANSLATION_ADDR	0x5800
-#define AT_PF0_BAR0		0x0
-#define BAR_TYPE_32b		0
-#define BAR_TYPE_64b		0x4
-#define BAR_ADDR_MASK		(~0x7F)
-#define AT_PF0_BAR1		0x4
-#define AT_PF0_BAR2		0x8
-#define AT_PF0_BAR3		0xc
-#define AT_PF0_BAR4		0x10
-#define AT_PF0_BAR5		0x14
-#define MSG_BAR			0x100
-#define EXT_ROM_BAR		0x120
-#define AT_ISEL_PF0_BAR0	0x200
-#define AT_ISEL_PF0_BAR1	0x204
-#define AT_ISEL_PF0_BAR2	0x208
-#define AT_ISEL_PF0_BAR3	0x20c
-#define AT_ISEL_PF0_BAR4	0x210
-#define AT_ISEL_PF0_BAR5	0x214
-
-#define LMI_BASE_ADDR		0x6000
-#define PHY_CONF_REG0		0x0
-#define PHY_ERR_REPORT		BIT6
-#define LTSSM_STATE_SHIFT	24
-#define LTSSM_STATE_MASK	0x3f000000
-#define LTSSM_STATE_L0		0x10
-#define PHY_CONF_REG1		0x4
-#define DLL_TIMER_CONF		0x8
-#define REPLAY_TIMEOUT_MASK	0xffff
-#define REPLAY_TIMEOUT_SHIFT	0
-#define ACK_TIMEOUT_MASK	0xffff0000
-#define ACK_TIMEOUT_SHIFT	16
-#define RCV_CREDIT_LT_REG0	0xc
-#define RCV_CREDIT_LT_REG1	0x10
-#define TRANSMIT_CREDIT_LT_REG0	0x14
-#define TRANSMIT_CREDIT_LT_REG1	0x18
-#define TRANSMIT_CREDIT_UPDATE_REG0 0x1c
-#define TRANSMIT_CREDIT_UPDATE_REG1 0x20
-#define L0S_TIMEOUT_REG		0x24
-#define L0S_TIMEOUT_SHIFT	0
-#define L0S_TIMEOUT_MASK	0xffff
-#define L2_ENTRY_ENABLE		BIT16
-#define L1_REENTRY_DELAY	0x40
-#define LOCAL_VENDOR_ID_REG	0x44
-#define ASPM_L1_TIMEOUT_REG	0x48
-#define ASPM_L1_TIMEOUT_MASK	0xfffff
-#define LOCAL_ERR_STAT_REG	0x20c
-#define PNP_RX_FIFO_PAR		BIT0
-#define CPL_RX_FIFO_PAR		BIT1
-#define REPLAY_BUF_PAR		BIT2
-#define PNP_RX_FIFO_OVERFLOW	BIT3
-#define CPL_RX_FIFO_OVERFLOW	BIT4
-#define REPLAY_TIMEOUT		BIT5
-#define REPLAY_TIMER_ROLLOVER	BIT6
-#define PHY_ERR			BIT7
-#define MALFORMED_TLP		BIT8
-#define UNEXPECTED_CPL		BIT9
-#define FLOW_CONTROL_ERR	BIT10
-#define CPL_TIMEOUT		BIT11
-#define LOCAL_ERR_INT_MASK_REG	0x210
-#define LCRC_ERR_COUNT_REG	0x214
-#define LCRC_COUNT_MASK		0xffff
-#define ECC_COR_ERR_COUNT_REG	0x218
-#define PNP_RX_FIFO_MASK	0xff
-#define PNP_RX_FIFO_SHIFT	0
-#define CPL_RX_FIFO_MASK	0xff00
-#define CPL_RX_FIFO_SHIFT	8
-#define REPLAY_RAM_MASK		0xff0000
-#define REPLAY_RAM_SHIFT	16
-#define PHY_FUNC_0_BAR_CONF_REG	0x240
-#define PHY_FUNC_1_BAR_CONF_REG	0x244
-#define BAR_0_1_APERTURE_SHIFT	0
-#define BAR_2_3_APERTURE_SHIFT	7
-#define BAR_4_5_APERTURE_SHIFT	19
-#define BAR_ROM_APERTURE_SHIFT	26
-#define BAR_0_1_ENABLE		(1 << 5)
-#define BAR_2_3_ENABLE		(1 << 12)
-#define BAR_4_5_ENABLE		(1 << 24)
-#define BAR_ROM_ENABLE		(1 << 31)
-#define BAR_0_1_PREFETCHABLE	(1 << 6)
-#define BAR_2_3_PREFETCHABLE	(1 << 13)
-#define BAR_4_5_PREFETCHABLE	(1 << 25)
-
-#define PHY_BASE_ADDR		0x8000		/* update for Sycamore */
-
-/* For new PIO */
-#define PCIE_BDF(dev)            (dev << 4)	/* PCI_BDF shifts 8bit, so we need extra 4bit shift */
-#define PCIE_BUS(bus)            ((bus & 0xFF) << 20)
-#define PCIE_DEV(dev)            ((dev & 0x1F) << 15)
-#define PCIE_FUNC(fun)           ((fun & 0x7)  << 12)
-#define PCIE_REG_ADDR(reg)       ((reg & 0xFFC) << 0)
-
-/* PCIe core controller registers */
-#define PCIE_CTRL_CORE_BASE_ADDR	0x18000
-#define PCIE_CTRL_CONFIG_REG		0x0
-#define PCIE_CTRL_MODE_SHIFT		0x0
-#define PCIE_CTRL_MODE_MASK		0x1
-
-#define PCIE_CORE_MODE_EP		0x0
-#define PCIE_CORE_MODE_RC		0x1
-
-/* PCIe interrupt registers */
-#define PCIE_CTRL_INT_BASE_ADDR		0x1B000
-#define RC_INT_STATS_REG		0x0
-#define RC_INT_MASK_REG			0x4
-
-/*
- * Get the register address of a given function's configuration space(each funciton has an address space of 0x1000)
- * baseaddr is the base address of a PCIe device in Aardvark
- */
-#define PCIE_CORE_CONFIG_REG_ADDR(baseaddr, offset) ((u64)baseaddr + offset)
-
-/* Get the PIO registers addresses of a PCIE device, 0x4000 is the offset of PIO register block */
-#define PCIE_CORE_PIO_REG_ADDR(baseaddr, offset) ((u64)baseaddr + PIO_BASE_ADDR + offset)
-
-/* Get the Control registers addresses of a PCIE device, 0x4800 is the offset of control register block*/
-#define PCIE_CORE_CTRL_REG_ADDR(baseaddr, offset) ((u64)baseaddr + CONTROL_BASE_ADDR + offset)
-
-/* Get the Outbound Address Translation window register address, 0x4c00 is the offset of ob window register block */
-#define PCIE_CORE_OB_REG_ADDR(baseaddr, offset, win) ((u64)baseaddr + OB_WIN_BASE_ADDR + win*OB_WIN_BLOCK_SIZE + offset)
-
-/* Get the DPMU registers addresses of a PCIE device, 0x4400 is the offset of control register block */
-#define PCIE_CORE_DPMU_REG_ADDR(baseaddr, offset) ((u64)baseaddr + DPMU_BASE_ADDR + offset)
-
-/* Get the Address Translation registers address of a PCIE device's , 0x5800 is the offset of control register block */
-#define PCIE_CORE_AT_REG_ADDR(baseaddr, offset) ((u64)baseaddr + ADDR_TRANSLATION_ADDR + offset)
-
-/* Get the VPD addresses of a PCIe device, 0x5000 is the offset of VPD register block */
-#define PCIE_CORE_VPD_RAM_ADDR(baseaddr, vfnum, offset) ((u64)baseaddr + VPD_RAM_BASE_ADDR + offset)
-
-/* Get the LMI register address of a PCIE device, 0x6000 is the offset of control register block */
-#define PCIE_CORE_LMI_REG_ADDR(baseaddr, offset) ((u64)baseaddr + LMI_BASE_ADDR + offset)
-
-/* Get PCIe controller core configuration addresses of a PCIe device, 0x180000 is the offset of controller core block */
-#define PCIE_CTRL_CORE_REG_ADDR(baseaddr, offset) ((u64)baseaddr + PCIE_CTRL_CORE_BASE_ADDR + offset)
-
-#endif /* _PCIE_CORE_H_ */
-
diff --git a/arch/arm/include/asm/arch-armadalp/regs-base.h b/arch/arm/include/asm/arch-armadalp/regs-base.h
deleted file mode 100644
index 492ea58..0000000
--- a/arch/arm/include/asm/arch-armadalp/regs-base.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
-* ***************************************************************************
-* Copyright (C) 2015 Marvell International Ltd.
-* ***************************************************************************
-* This program is free software: you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the Free
-* Software Foundation, either version 2 of the License, or any later version.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program.  If not, see <http://www.gnu.org/licenses/>.
-* ***************************************************************************
-*/
-
-#ifndef _REGS_BASE_H_
-#define _REGS_BASE_H_
-
-#include <asm/arch/memory-map.h>
-
-#define MPP_REGS_BASE		(MVEBU_REGS_BASE + 0x18000)
-#define MVEBU_ADEC_BASE		(MVEBU_REGS_BASE + 0xCF00)
-
-#define MVEBU_MISC_REGS_BASE	(MVEBU_REGS_BASE + 0x18200)
-#define MVEBU_DEVICE_ID_REG	(MVEBU_MISC_REGS_BASE + 0x38)
-#define MVEBU_DEVICE_REV_REG	(MVEBU_MISC_REGS_BASE + 0x3C)
-#define MVEBU_RESET_MASK_REG	(MVEBU_MISC_REGS_BASE + 0x60)
-#define MVEBU_SOFT_RESET_REG	(MVEBU_MISC_REGS_BASE + 0x64)
-
-#define MVEBU_GIC_BASE (MVEBU_REGS_BASE + 0x1d00000)
-#define MVEBU_GICD_BASE		(MVEBU_GIC_BASE)
-#define MVEBU_GICR_BASE		(MVEBU_GIC_BASE + 0x40000)
-#define MVEBU_GICC_BASE		(MVEBU_GIC_BASE + 0x80000)
-
-/* GBE register base address */
-#define MVEBU_ARLP_GBE0_INTERNAL_REG_BASE	MVEBU_REGS_BASE + 0xc364
-#define MVEBU_ARLP_GBE1_INTERNAL_REG_BASE	MVEBU_REGS_BASE + 0xc464
-
-/* CCI-400 */
-#define MVEBU_CCI_BASE			(MVEBU_REGS_BASE + 0x8000000)
-#define MVEBU_CCI_S3_SNOOP_CTRL_REG	(MVEBU_CCI_BASE + 0x4000)
-
-/* GPIO register base address */
-#define MVEBU_GPIO_NB_REG_BASE	(MVEBU_REGS_BASE + 0x13800)
-#define MVEBU_GPIO_SB_REG_BASE	(MVEBU_REGS_BASE + 0x18800)
-
-#define MVEBU_A3700_NB_TEST_PIN_OUTPUT_EN (MVEBU_REGS_BASE + 0x13804)
-#define MVEBU_A3700_NB_TEST_PIN_OUTPUT_SPI_EN_OFF (28)
-
-/* Clocks */
-#define MVEBU_NORTH_CLOCK_REGS_BASE	(MVEBU_REGS_BASE + 0x13000)
-#define MVEBU_SOUTH_CLOCK_REGS_BASE	(MVEBU_REGS_BASE + 0x18000)
-#define MVEBU_TESTPIN_NORTH_REG_BASE	(MVEBU_NORTH_CLOCK_REGS_BASE + 0x800)
-
-/* Reset sample */
-#define MVEBU_TEST_PIN_LATCH_N		(MVEBU_TESTPIN_NORTH_REG_BASE + 0x8)
-
-/* PM */
-#define MVEBU_NORTH_PM_REGS_BASE	(MVEBU_REGS_BASE + 0x14000)
-#define MVEBU_SOUTH_PM_REGS_BASE	(MVEBU_REGS_BASE + 0x19000)
-
-/* AXI DCTRL */
-#define MVEBU_AXI_DCTRL_REGS_BASE	(MVEBU_REGS_BASE + 0x2000)
-
-/* AVS */
-#define MVEBU_AVS_REGS_BASE		(MVEBU_REGS_BASE + 0x11500)
-
-
-#endif	/* _REGS_BASE_H_ */
diff --git a/arch/arm/include/asm/arch-armadalp/soc-info.h b/arch/arm/include/asm/arch-armadalp/soc-info.h
deleted file mode 100644
index b003717..0000000
--- a/arch/arm/include/asm/arch-armadalp/soc-info.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
-* ***************************************************************************
-* Copyright (C) 2015 Marvell International Ltd.
-* ***************************************************************************
-* This program is free software: you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the Free
-* Software Foundation, either version 2 of the License, or any later version.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program.  If not, see <http://www.gnu.org/licenses/>.
-* ***************************************************************************
-*/
-
-#ifndef _SOC_INFO_H_
-#define _SOC_INFO_H_
-
-/* MBUS definitions*/
-#define MAX_MBUS_WINS			10
-#define MAX_MBUS_REMAP_WINS		8
-#define INTERNAL_REG_WIN_NUM		11
-
-/* General MPP definitions */
-#define MAX_MPP_OPTS		7
-#define MAX_MPP_ID		56
-
-#define MPP_BIT_CNT		4
-#define MPP_FIELD_MASK		0x7
-#define MPP_FIELD_BITS		3
-#define MPP_VAL_MASK		0xF
-
-#define MPPS_PER_REG		(32 / MPP_BIT_CNT)
-#define MAX_MPP_REGS		((MAX_MPP_ID + MPPS_PER_REG) / MPPS_PER_REG)
-
-/* Pin Ctrl driver definitions */
-#define BITS_PER_PIN		1
-#define PIN_FUNC_MASK		((1 << BITS_PER_PIN) - 1)
-#define PIN_REG_SHIFT		5
-#define PIN_FIELD_MASK		((1 << PIN_REG_SHIFT) - 1)
-
-/********************************/
-/* REF Clock and Boot device    */
-/********************************/
-#define MVEBU_XTAL_MODE_MASK		BIT9
-#define MVEBU_XTAL_MODE_OFFS		(9)
-#define MVEBU_XTAL_CLOCK_25MHZ		(0x0)
-#define MVEBU_XTAL_CLOCK_40MHZ		(0x1)
-
-#define MVEBU_BOOTMODE_OFFS		(5)
-#define MVEBU_BOOTMODE_MASK		(0x7 << MVEBU_BOOTMODE_OFFS)
-#define MVEBU_BOOTMODE_NONE		(0)
-#define MVEBU_BOOTMODE_SPI_NOR		(1)
-#define MVEBU_BOOTMODE_EMMC_NORM	(2)
-#define MVEBU_BOOTMODE_EMMC_ALT		(3)
-#define MVEBU_BOOTMODE_SATA		(4)
-#define MVEBU_BOOTMODE_SPI_NAND		(5)
-#define MVEBU_BOOTMODE_UART		(6)
-#define MVEBU_BOOTMODE_RSRVD		(7)
-
-#endif	/* _SOC_INFO_H_ */
diff --git a/board/mvebu/armada3700/Makefile b/board/mvebu/armada3700/Makefile
new file mode 100644
index 0000000..1e13266
--- /dev/null
+++ b/board/mvebu/armada3700/Makefile
@@ -0,0 +1,20 @@
+#
+# ***************************************************************************
+# Copyright (C) 2015 Marvell International Ltd.
+# ***************************************************************************
+# This program is free software: you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation, either version 2 of the License, or any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+# ***************************************************************************
+#
+
+obj-y	+= armada3700.o
+obj-$(CONFIG_DEVEL_BOARD)	+= devel-board.o
diff --git a/board/mvebu/armada3700/armada3700.c b/board/mvebu/armada3700/armada3700.c
new file mode 100644
index 0000000..6f42ab5
--- /dev/null
+++ b/board/mvebu/armada3700/armada3700.c
@@ -0,0 +1,28 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+/* #define DEBUG*/
+
+#include <common.h>
+#include <linux/compiler.h>
+
+int mvebu_board_id_get(void)
+{
+	/* stub function for future use */
+	return 0;
+}
diff --git a/board/mvebu/armada3700/devel-board.c b/board/mvebu/armada3700/devel-board.c
new file mode 100644
index 0000000..acb1c68
--- /dev/null
+++ b/board/mvebu/armada3700/devel-board.c
@@ -0,0 +1,34 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+/* #define DEBUG */
+
+#include <common.h>
+#include <asm/arch-mvebu/soc.h>
+#include "../common/devel-board.h"
+#include "../common/sar.h"
+
+int mvebu_devel_board_init(void)
+{
+#ifdef CONFIG_MVEBU_SAR
+	sar_init();
+#endif
+
+	return 0;
+}
+
diff --git a/board/mvebu/armadalp/Makefile b/board/mvebu/armadalp/Makefile
deleted file mode 100644
index 2140a5e..0000000
--- a/board/mvebu/armadalp/Makefile
+++ /dev/null
@@ -1,20 +0,0 @@
-#
-# ***************************************************************************
-# Copyright (C) 2015 Marvell International Ltd.
-# ***************************************************************************
-# This program is free software: you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the Free
-# Software Foundation, either version 2 of the License, or any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-# ***************************************************************************
-#
-
-obj-y	+= armadalp.o
-obj-$(CONFIG_DEVEL_BOARD)	+= devel-board.o
diff --git a/board/mvebu/armadalp/armadalp.c b/board/mvebu/armadalp/armadalp.c
deleted file mode 100644
index 6f42ab5..0000000
--- a/board/mvebu/armadalp/armadalp.c
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * ***************************************************************************
- * Copyright (C) 2015 Marvell International Ltd.
- * ***************************************************************************
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation, either version 2 of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * ***************************************************************************
- */
-
-/* #define DEBUG*/
-
-#include <common.h>
-#include <linux/compiler.h>
-
-int mvebu_board_id_get(void)
-{
-	/* stub function for future use */
-	return 0;
-}
diff --git a/board/mvebu/armadalp/devel-board.c b/board/mvebu/armadalp/devel-board.c
deleted file mode 100644
index acb1c68..0000000
--- a/board/mvebu/armadalp/devel-board.c
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * ***************************************************************************
- * Copyright (C) 2015 Marvell International Ltd.
- * ***************************************************************************
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation, either version 2 of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * ***************************************************************************
- */
-
-/* #define DEBUG */
-
-#include <common.h>
-#include <asm/arch-mvebu/soc.h>
-#include "../common/devel-board.h"
-#include "../common/sar.h"
-
-int mvebu_devel_board_init(void)
-{
-#ifdef CONFIG_MVEBU_SAR
-	sar_init();
-#endif
-
-	return 0;
-}
-
diff --git a/configs/mvebu_armada3700_defconfig b/configs/mvebu_armada3700_defconfig
new file mode 100644
index 0000000..9b220d1
--- /dev/null
+++ b/configs/mvebu_armada3700_defconfig
@@ -0,0 +1,46 @@
+CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="ARM64"
++S:CONFIG_ARM=y
++S:CONFIG_TARGET_ARMADA_LP=y
++S:CONFIG_MVEBU_A3700_IO_ADDR_DEC=y
++S:CONFIG_MVEBU_A3700_MISC_INIT=y
++S:CONFIG_MVEBU_A3700_CLOCK=y
+CONFIG_MVEBU_MPP_BUS=y
++S:CONFIG_MVEBU_UART_ARLP=y
+CONFIG_XENON_MMC=y
++S:CONFIG_DEVEL_BOARD=y
+CONFIG_CMD_BDI=y
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_EDITENV=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_MEMORY=y
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_NET=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_MISC=y
+CONFIG_CMD_MVEBU_MPP=y
+CONFIG_CMD_MVEBU_FDT_CONFIG=y
+CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_HW_INFO=y
++S:CONFIG_OF_CONTROL=y
++S:CONFIG_OF_EMBED=y
++S:CONFIG_DEFAULT_DEVICE_TREE="armada-lp-db"
+CONFIG_MVEBU_ADVK_PCIE=y
+CONFIG_MV_INCLUDE_SATA=y
+CONFIG_SCSI_AHCI_PLAT=y
++S:CONFIG_MVEBU_MBUS=y
++S:CONFIG_MVEBU_MBUS_SPL_ONLY=y
+CONFIG_MVNETA=y
+CONFIG_MVEBU_NETA_BYPASS_DEC_WIN=y
+CONFIG_PHY_MARVELL=y
++S:CONFIG_I2C_MV=y
++S:# CONFIG_I2C_MV_PAD_REG is not set
+CONFIG_MVEBU_SPI=y
+CONFIG_MVEBU_PINCTL=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
++S:CONFIG_MVEBU_COMPHY_SUPPORT=y
++S:CONFIG_MVEBU_MK6_SUPPORT=y
++S:CONFIG_MVEBU_DLL_TUNE_SUPPORT=y
diff --git a/configs/mvebu_armada3700_palladium_defconfig b/configs/mvebu_armada3700_palladium_defconfig
new file mode 100644
index 0000000..8489ec3
--- /dev/null
+++ b/configs/mvebu_armada3700_palladium_defconfig
@@ -0,0 +1,35 @@
+CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="ARM64"
++S:CONFIG_ARM=y
++S:CONFIG_TARGET_ARMADA_LP=y
++S:CONFIG_PALLADIUM=y
++S:CONFIG_MVEBU_A3700_IO_ADDR_DEC=y
++S:CONFIG_MVEBU_A3700_MISC_INIT=y
++S:CONFIG_MVEBU_A3700_CLOCK=y
++S:CONFIG_MVEBU_UART_ARLP=y
+CONFIG_XENON_MMC=y
++S:CONFIG_DEVEL_BOARD=y
++S:# CONFIG_MULTI_DT_FILE is not set
+CONFIG_CMD_BDI=y
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_EDITENV=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_MEMORY=y
+CONFIG_CMD_NET=y
+CONFIG_CMD_PING=y
++S:CONFIG_OF_CONTROL=y
++S:CONFIG_OF_EMBED=y
++S:CONFIG_DEFAULT_DEVICE_TREE="armada-lp-palladium"
+CONFIG_MVEBU_ADVK_PCIE=y
+CONFIG_MV_INCLUDE_SATA=y
+CONFIG_SCSI_AHCI_PLAT=y
++S:CONFIG_MVEBU_MBUS=y
++S:CONFIG_MVEBU_MBUS_SPL_ONLY=y
+CONFIG_MVNETA=y
+CONFIG_MVEBU_NETA_BYPASS_DEC_WIN=y
+CONFIG_I2C_MV=y
+# CONFIG_I2C_MV_PAD_REG is not set
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
++S:# CONFIG_MVEBU_SPL_DDR_SUPPORT is not set
diff --git a/configs/mvebu_armadalp_defconfig b/configs/mvebu_armadalp_defconfig
deleted file mode 100644
index 9b220d1..0000000
--- a/configs/mvebu_armadalp_defconfig
+++ /dev/null
@@ -1,46 +0,0 @@
-CONFIG_SPL=y
-CONFIG_SYS_EXTRA_OPTIONS="ARM64"
-+S:CONFIG_ARM=y
-+S:CONFIG_TARGET_ARMADA_LP=y
-+S:CONFIG_MVEBU_A3700_IO_ADDR_DEC=y
-+S:CONFIG_MVEBU_A3700_MISC_INIT=y
-+S:CONFIG_MVEBU_A3700_CLOCK=y
-CONFIG_MVEBU_MPP_BUS=y
-+S:CONFIG_MVEBU_UART_ARLP=y
-CONFIG_XENON_MMC=y
-+S:CONFIG_DEVEL_BOARD=y
-CONFIG_CMD_BDI=y
-CONFIG_CMD_BOOTD=y
-CONFIG_CMD_RUN=y
-CONFIG_CMD_EDITENV=y
-CONFIG_CMD_SAVEENV=y
-CONFIG_CMD_MEMORY=y
-CONFIG_CMD_ECHO=y
-CONFIG_CMD_NET=y
-CONFIG_CMD_PING=y
-CONFIG_CMD_MII=y
-CONFIG_CMD_MISC=y
-CONFIG_CMD_MVEBU_MPP=y
-CONFIG_CMD_MVEBU_FDT_CONFIG=y
-CONFIG_CMD_MVEBU_BUBT=y
-CONFIG_CMD_MVEBU_HW_INFO=y
-+S:CONFIG_OF_CONTROL=y
-+S:CONFIG_OF_EMBED=y
-+S:CONFIG_DEFAULT_DEVICE_TREE="armada-lp-db"
-CONFIG_MVEBU_ADVK_PCIE=y
-CONFIG_MV_INCLUDE_SATA=y
-CONFIG_SCSI_AHCI_PLAT=y
-+S:CONFIG_MVEBU_MBUS=y
-+S:CONFIG_MVEBU_MBUS_SPL_ONLY=y
-CONFIG_MVNETA=y
-CONFIG_MVEBU_NETA_BYPASS_DEC_WIN=y
-CONFIG_PHY_MARVELL=y
-+S:CONFIG_I2C_MV=y
-+S:# CONFIG_I2C_MV_PAD_REG is not set
-CONFIG_MVEBU_SPI=y
-CONFIG_MVEBU_PINCTL=y
-CONFIG_USB=y
-CONFIG_USB_XHCI_HCD=y
-+S:CONFIG_MVEBU_COMPHY_SUPPORT=y
-+S:CONFIG_MVEBU_MK6_SUPPORT=y
-+S:CONFIG_MVEBU_DLL_TUNE_SUPPORT=y
diff --git a/configs/mvebu_armadalp_palladium_defconfig b/configs/mvebu_armadalp_palladium_defconfig
deleted file mode 100644
index 8489ec3..0000000
--- a/configs/mvebu_armadalp_palladium_defconfig
+++ /dev/null
@@ -1,35 +0,0 @@
-CONFIG_SPL=y
-CONFIG_SYS_EXTRA_OPTIONS="ARM64"
-+S:CONFIG_ARM=y
-+S:CONFIG_TARGET_ARMADA_LP=y
-+S:CONFIG_PALLADIUM=y
-+S:CONFIG_MVEBU_A3700_IO_ADDR_DEC=y
-+S:CONFIG_MVEBU_A3700_MISC_INIT=y
-+S:CONFIG_MVEBU_A3700_CLOCK=y
-+S:CONFIG_MVEBU_UART_ARLP=y
-CONFIG_XENON_MMC=y
-+S:CONFIG_DEVEL_BOARD=y
-+S:# CONFIG_MULTI_DT_FILE is not set
-CONFIG_CMD_BDI=y
-CONFIG_CMD_BOOTD=y
-CONFIG_CMD_RUN=y
-CONFIG_CMD_EDITENV=y
-CONFIG_CMD_SAVEENV=y
-CONFIG_CMD_MEMORY=y
-CONFIG_CMD_NET=y
-CONFIG_CMD_PING=y
-+S:CONFIG_OF_CONTROL=y
-+S:CONFIG_OF_EMBED=y
-+S:CONFIG_DEFAULT_DEVICE_TREE="armada-lp-palladium"
-CONFIG_MVEBU_ADVK_PCIE=y
-CONFIG_MV_INCLUDE_SATA=y
-CONFIG_SCSI_AHCI_PLAT=y
-+S:CONFIG_MVEBU_MBUS=y
-+S:CONFIG_MVEBU_MBUS_SPL_ONLY=y
-CONFIG_MVNETA=y
-CONFIG_MVEBU_NETA_BYPASS_DEC_WIN=y
-CONFIG_I2C_MV=y
-# CONFIG_I2C_MV_PAD_REG is not set
-CONFIG_USB=y
-CONFIG_USB_XHCI_HCD=y
-+S:# CONFIG_MVEBU_SPL_DDR_SUPPORT is not set
diff --git a/doc/mvebu/build.txt b/doc/mvebu/build.txt
index 52da096..fbe737a 100644
--- a/doc/mvebu/build.txt
+++ b/doc/mvebu/build.txt
@@ -32,7 +32,7 @@ Build Instruction:
 	# make <defconfig_file>
 	For AP806 stand alone board use "make mvebu_apn806_defconfig"
 	For Armada 8040Rz board use "make mvebu_armada70x0_defconfig"
-	For Armada-3700 board use "make mvebu_armadalp_defconfig"
+	For Armada-3700 board use "make mvebu_armada3700_defconfig"
 7. Build the U-Boot (Armada-3700 builds require WTP tools installation -
    refer to the section "Tools installation for Armada-3700 builds"):
 	# make
diff --git a/include/configs/armada3700.h b/include/configs/armada3700.h
new file mode 100644
index 0000000..e14f65f
--- /dev/null
+++ b/include/configs/armada3700.h
@@ -0,0 +1,144 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+#ifndef __ARMADA_LP_H
+#define __ARMADA_LP_H
+
+/* Version */
+#define CONFIG_BOOTP_VCI_STRING		" U-boot.armv8.armadalp"
+
+/* Platform */
+/* Support GICv3 */
+#undef CONFIG_GICV2
+#define CONFIG_GICV3
+
+/*
+#define MV_INCLUDE_SDIO
+#define MV_INCLUDE_INTEG_SATA
+#define MV_INCLUDE_CLK_PWR_CNTRL
+
+#define MV_INCLUDE_RCVR
+#define MV_INCLUDE_NAND
+#define MV_INCLUDE_SPI
+#define MV_INCLUDE_XOR
+#define MV_INCLUDE_SATA
+#define MV_INCLUDE_USB
+#define CONFIG_MV_ETH_NETA
+#define MV_INCLUDE_GPIO
+#define MV_INCLUDE_I2C
+#define MV_INCLUDE_RTC
+#define MV_INCLUDE_PEX
+*/
+
+/* Plaform */
+#define CONFIG_MARVELL
+
+/* Clock Definitions */
+#ifdef CONFIG_PALLADIUM
+#define COUNTER_FREQUENCY	(6000)
+#else
+/*
+ * The counter on A3700 always fed from reference clock (XTAL)
+ * However minimal CPU counter prescaler is 2, so the counter
+ * frequency will be divided by 2
+ */
+#define COUNTER_FREQUENCY	(12500000)
+#endif
+
+/* DRAM detection stuff */
+#define MV_DRAM_AUTO_SIZE
+#define CONFIG_SYS_DRAM_BANKS		1
+
+#ifdef CONFIG_SPL_BUILD
+/* SPL */
+/* Defines for SPL */
+/*#define CONFIG_SPL_TEXT_BASE	0xF0000000 - CM3 SRAM, 0x01000000 - DRAM */
+/* SRAM is 128K in total:      0xF0000000 - 0xF001FFFF
+   SPL code occupies addresses 0xF0000000 - 0xF000FFFF
+   SPL data can use addresses  0xF0010000 - 0xF0014000
+   WTMI starts at address      0xF00140F0
+   CM3 BootROM uses adresses   0xF0016000 - 0xF001FFFF
+   CM3 mapping for SRAM is     0x1FFF0000 - 0x20010000
+ */
+#define CONFIG_SPL_TEXT_BASE		0xF0000000
+#define CONFIG_SPL_MAX_SIZE		0x00010000	/* 64K */
+
+#ifndef __ASSEMBLY__
+extern char __end_of_spl[];
+#endif /* __ASSEMBLY__ */
+#define CONFIG_SYS_SPL_MALLOC_START	((ulong)__end_of_spl)
+#define CONFIG_SYS_SPL_MALLOC_SIZE	(0x4000)	/* 16K */
+#endif /* CONFIG_SPL_BUILD */
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/cpu/mvebu-common/u-boot-armv8-spl.lds"
+
+/* SPI flash for Palladium */
+#ifdef CONFIG_MVEBU_SPI
+
+#define CONFIG_MVEBU_SPI_ARLP
+
+#ifdef CONFIG_PALLADIUM
+#define CONFIG_SPI_FLASH_SPANSION
+#endif /* CONFIG_PALLADIUM */
+
+#endif /* CONFIG_MVEBU_SPI */
+
+/* The EEPROM ST M24C64 has 32 byte page write mode and takes up to 10 msec.
+ */
+#define CONFIG_MVEBU_EEPROM_PAGE_WRITE_DELAY_MS	10
+
+/*
+ * Include the generic MVEBU configuration file.
+ * The generic file is affected by the defines above.
+ */
+#include "mvebu-common.h"
+
+/* need board_early_init_f to invoke init_mbus, before dram_init */
+#define CONFIG_BOARD_EARLY_INIT_F
+
+#define CONFIG_SYS_PCI_64BIT	/* enable 64-bit PCI resources */
+
+/*
+ * SOC specific overrides
+ * Add here all config values that differ
+ * from the generic value in mvebu-common.h
+ */
+#ifdef CONFIG_PALLADIUM
+
+/* Disable I-CACHE for palladium */
+#define CONFIG_SYS_ICACHE_OFF
+
+#undef CONFIG_BOOTDELAY
+#define CONFIG_BOOTDELAY                -1
+
+#undef CONFIG_BAUDRATE
+#ifdef CONFIG_PALLADIUM
+#define CONFIG_BAUDRATE                 300
+#else
+#define CONFIG_BAUDRATE                 4000
+#endif
+
+#undef CONFIG_BOOTARGS
+#define CONFIG_BOOTARGS			"console=ttyS0,300 earlycon=ar3700_uart,0xd0012000 swiotlb=4096"
+
+#undef  CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS	"kernel_addr=0x107ffc0\0"	\
+					"fdt_addr=0x1000000\0"		\
+					"fdt_high=0xa0000000\0"
+#endif /*CONFIG_PALLADIUM*/
+
+#endif /* __ARMADA_LP_H */
diff --git a/include/configs/armadalp.h b/include/configs/armadalp.h
deleted file mode 100644
index e14f65f..0000000
--- a/include/configs/armadalp.h
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * ***************************************************************************
- * Copyright (C) 2015 Marvell International Ltd.
- * ***************************************************************************
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation, either version 2 of the License, or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * ***************************************************************************
- */
-
-#ifndef __ARMADA_LP_H
-#define __ARMADA_LP_H
-
-/* Version */
-#define CONFIG_BOOTP_VCI_STRING		" U-boot.armv8.armadalp"
-
-/* Platform */
-/* Support GICv3 */
-#undef CONFIG_GICV2
-#define CONFIG_GICV3
-
-/*
-#define MV_INCLUDE_SDIO
-#define MV_INCLUDE_INTEG_SATA
-#define MV_INCLUDE_CLK_PWR_CNTRL
-
-#define MV_INCLUDE_RCVR
-#define MV_INCLUDE_NAND
-#define MV_INCLUDE_SPI
-#define MV_INCLUDE_XOR
-#define MV_INCLUDE_SATA
-#define MV_INCLUDE_USB
-#define CONFIG_MV_ETH_NETA
-#define MV_INCLUDE_GPIO
-#define MV_INCLUDE_I2C
-#define MV_INCLUDE_RTC
-#define MV_INCLUDE_PEX
-*/
-
-/* Plaform */
-#define CONFIG_MARVELL
-
-/* Clock Definitions */
-#ifdef CONFIG_PALLADIUM
-#define COUNTER_FREQUENCY	(6000)
-#else
-/*
- * The counter on A3700 always fed from reference clock (XTAL)
- * However minimal CPU counter prescaler is 2, so the counter
- * frequency will be divided by 2
- */
-#define COUNTER_FREQUENCY	(12500000)
-#endif
-
-/* DRAM detection stuff */
-#define MV_DRAM_AUTO_SIZE
-#define CONFIG_SYS_DRAM_BANKS		1
-
-#ifdef CONFIG_SPL_BUILD
-/* SPL */
-/* Defines for SPL */
-/*#define CONFIG_SPL_TEXT_BASE	0xF0000000 - CM3 SRAM, 0x01000000 - DRAM */
-/* SRAM is 128K in total:      0xF0000000 - 0xF001FFFF
-   SPL code occupies addresses 0xF0000000 - 0xF000FFFF
-   SPL data can use addresses  0xF0010000 - 0xF0014000
-   WTMI starts at address      0xF00140F0
-   CM3 BootROM uses adresses   0xF0016000 - 0xF001FFFF
-   CM3 mapping for SRAM is     0x1FFF0000 - 0x20010000
- */
-#define CONFIG_SPL_TEXT_BASE		0xF0000000
-#define CONFIG_SPL_MAX_SIZE		0x00010000	/* 64K */
-
-#ifndef __ASSEMBLY__
-extern char __end_of_spl[];
-#endif /* __ASSEMBLY__ */
-#define CONFIG_SYS_SPL_MALLOC_START	((ulong)__end_of_spl)
-#define CONFIG_SYS_SPL_MALLOC_SIZE	(0x4000)	/* 16K */
-#endif /* CONFIG_SPL_BUILD */
-#define CONFIG_SPL_LDSCRIPT		"arch/arm/cpu/mvebu-common/u-boot-armv8-spl.lds"
-
-/* SPI flash for Palladium */
-#ifdef CONFIG_MVEBU_SPI
-
-#define CONFIG_MVEBU_SPI_ARLP
-
-#ifdef CONFIG_PALLADIUM
-#define CONFIG_SPI_FLASH_SPANSION
-#endif /* CONFIG_PALLADIUM */
-
-#endif /* CONFIG_MVEBU_SPI */
-
-/* The EEPROM ST M24C64 has 32 byte page write mode and takes up to 10 msec.
- */
-#define CONFIG_MVEBU_EEPROM_PAGE_WRITE_DELAY_MS	10
-
-/*
- * Include the generic MVEBU configuration file.
- * The generic file is affected by the defines above.
- */
-#include "mvebu-common.h"
-
-/* need board_early_init_f to invoke init_mbus, before dram_init */
-#define CONFIG_BOARD_EARLY_INIT_F
-
-#define CONFIG_SYS_PCI_64BIT	/* enable 64-bit PCI resources */
-
-/*
- * SOC specific overrides
- * Add here all config values that differ
- * from the generic value in mvebu-common.h
- */
-#ifdef CONFIG_PALLADIUM
-
-/* Disable I-CACHE for palladium */
-#define CONFIG_SYS_ICACHE_OFF
-
-#undef CONFIG_BOOTDELAY
-#define CONFIG_BOOTDELAY                -1
-
-#undef CONFIG_BAUDRATE
-#ifdef CONFIG_PALLADIUM
-#define CONFIG_BAUDRATE                 300
-#else
-#define CONFIG_BAUDRATE                 4000
-#endif
-
-#undef CONFIG_BOOTARGS
-#define CONFIG_BOOTARGS			"console=ttyS0,300 earlycon=ar3700_uart,0xd0012000 swiotlb=4096"
-
-#undef  CONFIG_EXTRA_ENV_SETTINGS
-#define CONFIG_EXTRA_ENV_SETTINGS	"kernel_addr=0x107ffc0\0"	\
-					"fdt_addr=0x1000000\0"		\
-					"fdt_high=0xa0000000\0"
-#endif /*CONFIG_PALLADIUM*/
-
-#endif /* __ARMADA_LP_H */
-- 
1.9.1

