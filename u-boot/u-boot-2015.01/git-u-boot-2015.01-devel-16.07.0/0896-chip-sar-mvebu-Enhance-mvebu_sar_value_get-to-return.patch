From b964843a87cf2a6e67496d15eeb564bb06e0edf6 Mon Sep 17 00:00:00 2001
From: Shadi Ammouri <shadi@marvell.com>
Date: Tue, 23 Feb 2016 10:04:41 +0200
Subject: [PATCH 0896/1240] chip-sar: mvebu: Enhance mvebu_sar_value_get to
 return more info

- Return more information on the required sample-at-reset. Including
  the raw register value, and the interface index from which the boot
  is being made (for bootsrc retrieval).

Change-Id: Ie758029fad07ee0093666e718ebe1f90b76e4ec6
Signed-off-by: Shadi Ammouri <shadi@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/27772
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Tested-by: Hanna Hawa <hannah@marvell.com>
---
 arch/arm/cpu/armv8/armada8k/clock.c   | 18 +++++++++---------
 arch/arm/include/asm/arch-mvebu/sar.h | 26 +++++++++++++++++++++++++-
 drivers/misc/mvebu_sar/ap806_sar.c    |  5 +++--
 drivers/misc/mvebu_sar/chip_sar.c     |  2 +-
 drivers/misc/mvebu_sar/chip_sar.h     |  2 +-
 drivers/misc/mvebu_sar/cp110_sar.c    | 25 +++++++++++++++----------
 6 files changed, 54 insertions(+), 24 deletions(-)

diff --git a/arch/arm/cpu/armv8/armada8k/clock.c b/arch/arm/cpu/armv8/armada8k/clock.c
index 65c3bd3..fc17ee93 100644
--- a/arch/arm/cpu/armv8/armada8k/clock.c
+++ b/arch/arm/cpu/armv8/armada8k/clock.c
@@ -26,10 +26,10 @@
 
 u32 soc_ring_clk_get(void)
 {
-	u32 freq;
+	struct sar_val sar;
 
-	mvebu_sar_value_get(SAR_AP_FABRIC_FREQ , &freq);
-	return freq;
+	mvebu_sar_value_get(SAR_AP_FABRIC_FREQ , &sar);
+	return sar.freq;
 }
 
 u32 soc_mss_clk_get(void)
@@ -63,18 +63,18 @@ unsigned long mvebu_get_nand_clock(void)
 
 u32 soc_cpu_clk_get(void)
 {
-	u32 freq;
+	struct sar_val sar;
 
-	mvebu_sar_value_get(SAR_CPU_FREQ , &freq);
-	return freq;
+	mvebu_sar_value_get(SAR_CPU_FREQ , &sar);
+	return sar.freq;
 }
 
 u32 soc_ddr_clk_get(void)
 {
-	u32 freq;
+	struct sar_val sar;
 
-	mvebu_sar_value_get(SAR_DDR_FREQ, &freq);
-	return freq;
+	mvebu_sar_value_get(SAR_DDR_FREQ, &sar);
+	return sar.freq;
 }
 
 void soc_print_clock_info(void)
diff --git a/arch/arm/include/asm/arch-mvebu/sar.h b/arch/arm/include/asm/arch-mvebu/sar.h
index ff3f5e6..4c358fe 100644
--- a/arch/arm/include/asm/arch-mvebu/sar.h
+++ b/arch/arm/include/asm/arch-mvebu/sar.h
@@ -48,9 +48,33 @@ enum mvebu_bootsrc_type {
 	BOOTSRC_MAX_IDX
 };
 
+/*
+** sample-at-reset information
+**  raw_sar_val: Raw value out of the sample-at-reset register.
+**		This is hw dependent and should not be used for comparison
+**		purposes (useful for debug, or verbose information).
+**  bootsrc (SAR_BOOT_SRC):
+**	type: Boot source interface type.
+**	index: When applicable, indicates the interface index (e.g. SPI #1,
+**		NAND #0).
+**	width: When applicable, indicates the interface bus width (e.g. NAND
+**	8-bit).
+**  freq: Frequency in Hz.
+*/
+struct sar_val {
+	u32 raw_sar_val;
+	union {
+		struct {
+			enum mvebu_bootsrc_type type;
+			int index;
+		} bootsrc;
+		u32 freq;
+	};
+};
+
 
 int mvebu_sar_init(const void *blob);
-int mvebu_sar_value_get(enum mvebu_sar_opts opt, u32 *val);
+int mvebu_sar_value_get(enum mvebu_sar_opts opt, struct sar_val *val);
 void mvebu_sar_dump(void);
 
 #endif	/* _SAR_H_ */
diff --git a/drivers/misc/mvebu_sar/ap806_sar.c b/drivers/misc/mvebu_sar/ap806_sar.c
index 6f0482e..95f475d 100644
--- a/drivers/misc/mvebu_sar/ap806_sar.c
+++ b/drivers/misc/mvebu_sar/ap806_sar.c
@@ -118,7 +118,7 @@ static const u32 pll_freq_tbl[7][5] = {
 };
 
 
-int ap806_sar_value_get(enum mvebu_sar_opts sar_opt, u32 *val)
+int ap806_sar_value_get(enum mvebu_sar_opts sar_opt, struct sar_val *val)
 {
 	u32 pll_idx, pll_val;
 
@@ -137,7 +137,8 @@ int ap806_sar_value_get(enum mvebu_sar_opts sar_opt, u32 *val)
 		return -EINVAL;
 	}
 	pll_val = sar_get_pll_val(pll_idx);
-	*val = pll_freq_tbl[pll_val][pll_idx];
+	val->raw_sar_val = pll_val;
+	val->freq = pll_freq_tbl[pll_val][pll_idx];
 	return 0;
 }
 
diff --git a/drivers/misc/mvebu_sar/chip_sar.c b/drivers/misc/mvebu_sar/chip_sar.c
index baa244f..a0b3af5 100644
--- a/drivers/misc/mvebu_sar/chip_sar.c
+++ b/drivers/misc/mvebu_sar/chip_sar.c
@@ -128,7 +128,7 @@ int mvebu_sar_init(const void *blob)
 	return 0;
 }
 
-int mvebu_sar_value_get(enum mvebu_sar_opts opt, u32 *val)
+int mvebu_sar_value_get(enum mvebu_sar_opts opt, struct sar_val *val)
 {
 	u32 idx;
 	struct sar_chip_info *chip_ptr;
diff --git a/drivers/misc/mvebu_sar/chip_sar.h b/drivers/misc/mvebu_sar/chip_sar.h
index 6a52af5..9827728 100644
--- a/drivers/misc/mvebu_sar/chip_sar.h
+++ b/drivers/misc/mvebu_sar/chip_sar.h
@@ -25,7 +25,7 @@ struct sar_chip_info {
 	enum fdt_compat_id compat;
 	int (*sar_init_func)(const void *blob, int node);
 	int (*sar_dump_func)(void);
-	int (*sar_value_get_func)(enum mvebu_sar_opts sar, u32 *val);
+	int (*sar_value_get_func)(enum mvebu_sar_opts sar, struct sar_val *val);
 	int (*sar_bootsrc_get)(u32 *idx);
 };
 
diff --git a/drivers/misc/mvebu_sar/cp110_sar.c b/drivers/misc/mvebu_sar/cp110_sar.c
index e4e044f..2073c10 100644
--- a/drivers/misc/mvebu_sar/cp110_sar.c
+++ b/drivers/misc/mvebu_sar/cp110_sar.c
@@ -48,21 +48,23 @@ struct bootsrc_idx_info {
 	int start;
 	int end;
 	enum mvebu_bootsrc_type src;
+	int index;
 };
 
 static struct bootsrc_idx_info bootsrc_list[] = {
-	{0x0,	0x5,	BOOTSRC_NOR},
-	{0xA,	0x25,	BOOTSRC_NAND},
-	{0x28,	0x28,	BOOTSRC_AP_SD_EMMC},
-	{0x29,	0x29,	BOOTSRC_SD_EMMC},
-	{0x2A,	0x2A,	BOOTSRC_AP_SD_EMMC},
-	{0x2B,	0x2B,	BOOTSRC_SD_EMMC},
-	{0x30,	0x31,	BOOTSRC_AP_SPI},
-	{0x32,	0x35,	BOOTSRC_NOR},
+	{0x0,	0x5,	BOOTSRC_NOR,		0},
+	{0xA,	0x25,	BOOTSRC_NAND,		0},
+	{0x28,	0x28,	BOOTSRC_AP_SD_EMMC,	0},
+	{0x29,	0x29,	BOOTSRC_SD_EMMC,	0},
+	{0x2A,	0x2A,	BOOTSRC_AP_SD_EMMC,	0},
+	{0x2B,	0x2B,	BOOTSRC_SD_EMMC,	0},
+	{0x30,	0x31,	BOOTSRC_AP_SPI,		0},
+	{0x32,	0x33,	BOOTSRC_SPI,		1},
+	{0x34,	0x35,	BOOTSRC_SPI,		0},
 	{-1,	-1,	-1}
 };
 
-int cp110_sar_value_get(enum mvebu_sar_opts sar_opt, u32 *val)
+int cp110_sar_value_get(enum mvebu_sar_opts sar_opt, struct sar_val *val)
 {
 	u32 reg, mode;
 	int i;
@@ -75,10 +77,13 @@ int cp110_sar_value_get(enum mvebu_sar_opts sar_opt, u32 *val)
 	reg = readl(sar_base);
 	mode = (reg & SAR1_RST_BOOT_MODE_AP_CP0_MASK) >> SAR1_RST_BOOT_MODE_AP_CP0_OFFSET;
 
+	val->raw_sar_val = mode;
+
 	i = 0;
 	while (bootsrc_list[i].start != -1) {
 		if ((mode >= bootsrc_list[i].start) && (mode <= bootsrc_list[i].end)) {
-			*val = bootsrc_list[i].src;
+			val->bootsrc.type = bootsrc_list[i].src;
+			val->bootsrc.index = bootsrc_list[i].index;
 			break;
 		}
 		i++;
-- 
1.9.1

