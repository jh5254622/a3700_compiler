From 93d36a749586fcbf484a58a09a7606580971e510 Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Tue, 26 Apr 2016 15:23:00 +0300
Subject: [PATCH 1120/1240] fix: xenon: run soc init according to DT status

for A8k, Xenon IP on the AP requires special SoC MPP configuration,
and if enabled, it disables the functionality of the used MPP by XENON.
this broke SPI support on the AP.

this patch relocates this configuration from generic soc code, to a
weak SoC implemetation, to be called from xenon init driver.
hence, this configuration will be done only if XENON DT entry is enabled.

Change-Id: I9de1f7e4c11a7f9b6521ac703edc77ff9067fae1
Signed-off-by: Omri Itach <omrii@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/29290
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Haim Boot <hayim@marvell.com>
---
 arch/arm/cpu/armv8/armada8k/soc.c | 23 +++++++++++++----------
 drivers/mmc/xenon_mmc.c           | 10 ++++++++++
 2 files changed, 23 insertions(+), 10 deletions(-)

diff --git a/arch/arm/cpu/armv8/armada8k/soc.c b/arch/arm/cpu/armv8/armada8k/soc.c
index 93cbce8..8b00f7a 100644
--- a/arch/arm/cpu/armv8/armada8k/soc.c
+++ b/arch/arm/cpu/armv8/armada8k/soc.c
@@ -41,9 +41,6 @@
 
 int soc_early_init_f(void)
 {
-#ifdef CONFIG_XENON_MMC
-	u32 reg;
-#endif
 	debug_enter();
 #ifdef CONFIG_MVEBU_CHIP_SAR
 	/* Sample at reset register init */
@@ -53,13 +50,6 @@ int soc_early_init_f(void)
 	mvebu_pinctl_probe();
 #endif
 
-#ifdef CONFIG_XENON_MMC
-	/* set eMMC/SD PHY output instead of MPPs */
-	reg = readl(EMMC_PHY_IO_CTRL);
-	reg &= ~EMMC_PHY_CTRL_SDPHY_EN;
-	writel(reg, EMMC_PHY_IO_CTRL);
-#endif
-
 	debug_exit();
 	return 0;
 }
@@ -187,6 +177,19 @@ void board_usb_vbus_init(void)
 }
 #endif
 
+
+#ifdef CONFIG_XENON_MMC
+void mmc_soc_init(void)
+{
+	u32 reg;
+
+	/* set eMMC/SD PHY output instead of MPPs */
+	reg = readl(EMMC_PHY_IO_CTRL);
+	reg &= ~EMMC_PHY_CTRL_SDPHY_EN;
+	writel(reg, EMMC_PHY_IO_CTRL);
+}
+#endif
+
 /************************************************************************
    Function:  mvebu_is_in_recovery_mode
 
diff --git a/drivers/mmc/xenon_mmc.c b/drivers/mmc/xenon_mmc.c
index 85f9d86..acfdb12 100644
--- a/drivers/mmc/xenon_mmc.c
+++ b/drivers/mmc/xenon_mmc.c
@@ -941,6 +941,14 @@ int xenon_mmc_create(int dev_idx, void __iomem *reg_base, u32 max_clk, u32 mmc_m
 	return 0;
 }
 
+/* weak implementation: dependant on SoC requirements.
+ * will be overrun in soc.c, in case a platforms requires special
+ * SoC configuration prior to XENON usage */
+void __weak mmc_soc_init(void)
+{
+	return;
+}
+
 int board_mmc_init(bd_t *bis)
 {
 	int node_list[XENON_MMC_PORTS_MAX];
@@ -952,6 +960,8 @@ int board_mmc_init(bd_t *bis)
 
 	count = fdtdec_find_aliases_for_id(blob, "xenon-sdhci",
 			COMPAT_MVEBU_XENON_MMC, &node_list[0], XENON_MMC_PORTS_MAX);
+	if (count > 0)
+		mmc_soc_init();
 
 	for (port_count = 0; port_count < count; port_count++) {
 		if (port_count == XENON_MMC_PORTS_MAX) {
-- 
1.9.1

