From 02f3be9497fbe34f730593e8e5938f80d2fd7543 Mon Sep 17 00:00:00 2001
From: Ken Ma <make@marvell.com>
Date: Fri, 19 Feb 2016 00:35:50 +0800
Subject: [PATCH 1129/1240] pcie: a3700: replace old gpio APIs with new general
 APIs

- In armada3700 pcie fdt nodes, a new property "reset-gpio" node is
  added
- The old gpio subroutines for PCIe are moved to the PCIe driver,
  the old pinctrl codes are kept and will be removed in future

Change-Id: I66aea500902c5cdd996e76848c879ac58eaae636
Signed-off-by: Ken Ma <make@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/27669
Reviewed-by: Haim Boot <hayim@marvell.com>
Tested-by: Haim Boot <hayim@marvell.com>
---
 arch/arm/cpu/armv8/armada3700/mvebu_gpio.c  | 18 -----------
 arch/arm/dts/armada-3700-db.dts             |  1 +
 arch/arm/include/asm/arch-armada3700/gpio.h |  3 --
 drivers/pci/pci_advk.c                      | 49 +++++++++++++++++++++++++++--
 4 files changed, 47 insertions(+), 24 deletions(-)

diff --git a/arch/arm/cpu/armv8/armada3700/mvebu_gpio.c b/arch/arm/cpu/armv8/armada3700/mvebu_gpio.c
index c23b745..bf953c2 100644
--- a/arch/arm/cpu/armv8/armada3700/mvebu_gpio.c
+++ b/arch/arm/cpu/armv8/armada3700/mvebu_gpio.c
@@ -27,28 +27,10 @@ void mvebu_reset_pcie_dev(void)
 {
 	u32 reg_val;
 
-	/* Set PCIe reset to 0 */
-	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_VAL_REG);
-	reg_val &= ~(1 << MVEBU_GPIO_PCIE_RESET_OFF);
-	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_VAL_REG);
-
-	/* Set to GPIO output mode */
-	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_EN_REG);
-	reg_val |= (1 << MVEBU_GPIO_PCIE_RESET_OFF);
-	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_EN_REG);
-
 	/* Set PCIe to GPIO mode */
 	reg_val = readl(MVEBU_GPIO_SB_SEL_REG);
 	reg_val |= (1 << MVEBU_GPIO_PCIE_EN_OFF);
 	writel(reg_val, MVEBU_GPIO_SB_SEL_REG);
-
-	/* typical delay for NIC to finish reset from NIC specification */
-	udelay(100);
-
-	/* Release PCIe reset */
-	reg_val = readl(MVEBU_GPIO_SB_OUTPUT_VAL_REG);
-	reg_val |= (1 << MVEBU_GPIO_PCIE_RESET_OFF);
-	writel(reg_val, MVEBU_GPIO_SB_OUTPUT_VAL_REG);
 }
 
 /*
diff --git a/arch/arm/dts/armada-3700-db.dts b/arch/arm/dts/armada-3700-db.dts
index aee047b..f8439fb 100644
--- a/arch/arm/dts/armada-3700-db.dts
+++ b/arch/arm/dts/armada-3700-db.dts
@@ -63,6 +63,7 @@
 			};
 			pcie-controller {
 				pcie@1,0 {
+					reset-gpio = <&gpio1 ARMADA_3700_GPIO(BANK_1, 3) GPIO_ACTIVE_HIGH>;
 					status = "okay";
 				};
 			};
diff --git a/arch/arm/include/asm/arch-armada3700/gpio.h b/arch/arm/include/asm/arch-armada3700/gpio.h
index 8a33f0c..b941a70 100644
--- a/arch/arm/include/asm/arch-armada3700/gpio.h
+++ b/arch/arm/include/asm/arch-armada3700/gpio.h
@@ -28,9 +28,6 @@
 #define MVEBU_GPIO_TW1_GPIO_EN_OFF		(10)
 #define MVEBU_GPIO_SPI_GPIO_EN_OFF		(18)
 
-#define MVEBU_GPIO_SB_OUTPUT_EN_REG		(MVEBU_GPIO_SB_REG_BASE)
-#define MVEBU_GPIO_SB_OUTPUT_VAL_REG		(MVEBU_GPIO_SB_REG_BASE + 0x18)
-#define MVEBU_GPIO_PCIE_RESET_OFF		(3)
 #define MVEBU_GPIO_SB_SEL_REG			(MVEBU_GPIO_SB_REG_BASE + 0x30)
 #define MVEBU_GPIO_SB_SDIO_EN_OFF		(2)
 #define MVEBU_GPIO_RGMII_GPIO_EN_OFF		(3)
diff --git a/drivers/pci/pci_advk.c b/drivers/pci/pci_advk.c
index 089521b..d029cc6 100644
--- a/drivers/pci/pci_advk.c
+++ b/drivers/pci/pci_advk.c
@@ -30,7 +30,7 @@
 #include <asm/arch/pcie-core.h>
 #include <pci.h>
 #include <asm/arch-mvebu/fdt.h>
-#include <asm/arch/gpio.h>
+#include <asm/gpio.h>
 
 /* #define DEBUG */
 /* #define DEBUG_CFG_CYCLE */
@@ -390,7 +390,39 @@ static int advk_pcie_link_init(void __iomem *reg_base)
 	return 0;
 }
 
-static int advk_pcie_init(int host_id, void __iomem *reg_base, struct pcie_win *win, int first_busno)
+/*
+ * reset PCIe device
+ */
+static void advk_pcie_reset_dev(struct fdt_gpio_state *gpio)
+{
+#ifdef CONFIG_MVEBU_GPIO
+	int val;
+
+	if (!fdt_gpio_isvalid(gpio))
+		return;
+
+	/* Set PCIe reset gpio in output mode with low level */
+	val = gpio->flags & FDT_GPIO_ACTIVE_LOW ? 1 : 0;
+	gpio_direction_output(gpio->gpio, val);
+
+	/* typical delay for NIC to finish reset from NIC specification */
+	udelay(100);
+
+	/* Set PCIe reset gpio in high level */
+	val = gpio->flags & FDT_GPIO_ACTIVE_LOW ? 0 : 1;
+	gpio_set_value(gpio->gpio, val);
+#else
+	printf("ERROR: the PCIe device is not reset, need to implement gpio in SOC code\n");
+#endif
+
+	return;
+}
+
+static int advk_pcie_init(int host_id,
+				void __iomem *reg_base,
+				struct pcie_win *win,
+				int first_busno,
+				struct fdt_gpio_state *gpio)
 {
 	int ret = 0;
 	u32 state;
@@ -405,7 +437,10 @@ static int advk_pcie_init(int host_id, void __iomem *reg_base, struct pcie_win *
 	memset(hose, 0, sizeof(hose));
 
 	/* reset PCIe device in RC mode */
+	/* now the gpio setting for reset is splitted from mvebu_reset_pcie_dev to advk_pcie_reset_dev */
+	/* mvebu_reset_pcie_dev only do the pinctrl work, it will be removed in the future */
 	mvebu_reset_pcie_dev();
+	advk_pcie_reset_dev(gpio);
 
 	/* start link training */
 	ret = advk_pcie_link_init(reg_base);
@@ -499,6 +534,7 @@ void pci_init_board(void)
 	const void *blob = gd->fdt_blob;
 	struct pcie_win win;
 	void __iomem *reg_base;
+	struct fdt_gpio_state reset_gpio;
 	int err;
 
 	count = fdtdec_find_aliases_for_id(blob, "pcie-controller",
@@ -535,8 +571,15 @@ void pci_init_board(void)
 			continue;
 		}
 
+#ifdef CONFIG_MVEBU_GPIO
+		fdtdec_decode_gpio(blob, port_node, "reset-gpio", &reset_gpio);
+		fdtdec_setup_gpio(&reset_gpio);
+#else
+		printf("ERROR: reset gpio is initialized, need to implement gpio in SOC code\n");
+#endif
+
 		/* If all is well register the host */
-		first_busno = advk_pcie_init(host_id, reg_base, &win, first_busno);
+		first_busno = advk_pcie_init(host_id, reg_base, &win, first_busno, &reset_gpio);
 	}
 }
 
-- 
1.9.1

