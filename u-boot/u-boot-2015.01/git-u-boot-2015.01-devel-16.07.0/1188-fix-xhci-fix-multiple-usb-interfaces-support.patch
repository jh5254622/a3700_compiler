From 8fee0cb9cd22b198214894086c70d455c99d01fc Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Tue, 31 May 2016 18:10:55 +0300
Subject: [PATCH 1188/1240] fix: xhci: fix multiple usb interfaces support

Despite using a for loop, xhci_hcd_init allways returned the
1st enabled interface from Device tree, regardless of requested index.

This patch:

1. increase the USB controller count (and XHCI count accordingly).

2. - Scan device tree nodes prior usage of usb_lowlevel_init & xhci_hcd_init.
   - Save node count and nodes as global data
   - use the enabled port count to scan all (and only) enabled ports.

Change-Id: I968058d1fa0a3d5b3afc452b1271887a516be2ab
Signed-off-by: Omri Itach <omrii@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/30231
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Reviewed-by: Haim Boot <hayim@marvell.com>
---
 common/usb.c                   |  7 ++--
 drivers/usb/host/xhci-mvebu.c  | 80 +++++++++++++++++++++++-------------------
 include/configs/mvebu-common.h |  3 +-
 include/usb.h                  |  1 +
 4 files changed, 52 insertions(+), 39 deletions(-)

diff --git a/common/usb.c b/common/usb.c
index 736cd9f..9f3badd 100644
--- a/common/usb.c
+++ b/common/usb.c
@@ -59,7 +59,7 @@ int usb_init(void)
 	void *ctrl;
 	struct usb_device *dev;
 	int i, start_index = 0;
-	int ret;
+	int ret, enable_port_count;
 
 	dev_index = 0;
 	asynch_allowed = 1;
@@ -71,8 +71,11 @@ int usb_init(void)
 		usb_dev[i].devnum = -1;
 	}
 
+	/* Parse device tree mapping for usb nodes, and initialize only enabled ports */
+	enable_port_count = usb_device_tree_init();
+
 	/* init low_level USB */
-	for (i = 0; i < CONFIG_USB_MAX_CONTROLLER_COUNT; i++) {
+	for (i = 0; i < enable_port_count ; i++) {
 		/* init low_level USB */
 		printf("USB%d:   ", i);
 		ret = usb_lowlevel_init(i, USB_INIT_HOST, &ctrl);
diff --git a/drivers/usb/host/xhci-mvebu.c b/drivers/usb/host/xhci-mvebu.c
index 68aa231..78ea086 100644
--- a/drivers/usb/host/xhci-mvebu.c
+++ b/drivers/usb/host/xhci-mvebu.c
@@ -53,54 +53,62 @@ static void usb_vbus_init(int node)
 #endif
 }
 
+/* Device tree global data scanned at 1st init for usb3 nodes */
+int node_list[CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS], count = 0;
+
+/* Parse and save enabled device tree usb3 nodes, and return enabled node count */
+int usb_device_tree_init(void)
+{
+	/* - Scan device tree usb3 nodes once, and save relevant nodes in static node_list */
+	count = fdtdec_find_aliases_for_id(gd->fdt_blob, "usb3",
+			COMPAT_MVEBU_USB3, node_list, CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS);
+
+	if (count == 0)
+		printf("%s: 'usb3' is disabled in Device Tree\n", __func__);
+
+	/* Return enabled port count */
+	return count;
+}
+
+bool vbus_initialized = 0;
 int xhci_hcd_init(int index, struct xhci_hccr **hccr, struct xhci_hcor **hcor)
 {
-	int node_list[CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS], node;
-	int i, count;
+	int node;
 	unsigned long usb3_reg_base;
 
-	/* Enable USB VBUS using I2C io-expander
-	** TODO: need to be updated according to Device tree, and will be triggered
-	** below per port (while going through enabled ports DT info) */
-	board_usb_vbus_init();
-
-	/* in dts file, go through all the 'usb3' nodes.
-	 */
-	count = fdtdec_find_aliases_for_id(gd->fdt_blob, "usb3",
-			COMPAT_MVEBU_USB3, node_list, CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS);
-	if (count == 0) {
-		error("could not find usb3 node in FDT, initialization skipped!\n");
-		return -ENXIO;
+	/* Enable USB VBUS for all ports at once, using I2C io-expander */
+	if (!vbus_initialized) {
+		/* TODO: need to be updated according to Device tree */
+		board_usb_vbus_init();
+		vbus_initialized = 1; /* mark I2C USB VBUS cycle completed */
 	}
-	for (i = 0; i < count ; i++) {
-		node = node_list[i];
 
-		if (node <= 0)
-			continue;
+	/* node_list: Enabled DT nodes were initialized in usb_device_tree_init(),
+	 * so it's valid to use node_list[index] to fetch its registers */
+	node = node_list[index];
 
-		/* fetch 'reg' propertiy from 'usb3' node */
-		usb3_reg_base = (unsigned long)fdt_get_regs_offs(gd->fdt_blob, node, "reg");
-		if (usb3_reg_base == FDT_ADDR_T_NONE) {
-			error("could not find reg in usb3 node, initialization skipped!\n");
-			return -ENXIO;
-		}
+	/* fetch 'reg' property from 'usb3' node */
+	usb3_reg_base = (unsigned long)fdt_get_regs_offs(gd->fdt_blob, node, "reg");
 
-		*hccr = (struct xhci_hccr *)usb3_reg_base;
-		*hcor = (struct xhci_hcor *)((unsigned long) *hccr
+	if (usb3_reg_base == FDT_ADDR_T_NONE) {
+		error("could not find reg property in usb3 node, initialization skipped!\n");
+		return -ENXIO;
+	}
+
+	*hccr = (struct xhci_hccr *)usb3_reg_base;
+	*hcor = (struct xhci_hcor *)((unsigned long) *hccr
 					+ HC_LENGTH(xhci_readl(&(*hccr)->cr_capbase)));
 
-		/* Enable USB VBUS:
-		** enable VBUS using GPIO, and got information from USB node in
-		** device tree */
-		usb_vbus_init(node);
+	/* Enable USB VBUS per port (only via GPIO):
+	** enable VBUS using GPIO, and got information from USB node in
+	** device tree */
+	usb_vbus_init(node);
 
-		debug("mvebu-xhci: init hccr %lx and hcor %lx hc_length %ld\n",
-		      (uintptr_t)*hccr, (uintptr_t)*hcor,
-			(uintptr_t)HC_LENGTH(xhci_readl(&(*hccr)->cr_capbase)));
-		return 0;
-	}
+	debug("mvebu-xhci: init hccr %lx and hcor %lx hc_length %ld\n",
+	      (uintptr_t)*hccr, (uintptr_t)*hcor,
+		(uintptr_t)HC_LENGTH(xhci_readl(&(*hccr)->cr_capbase)));
 
-	return -ENXIO;
+	return 0;
 }
 
 void xhci_hcd_stop(int index)
diff --git a/include/configs/mvebu-common.h b/include/configs/mvebu-common.h
index 85ce7ed..edeb425 100644
--- a/include/configs/mvebu-common.h
+++ b/include/configs/mvebu-common.h
@@ -333,7 +333,8 @@
 
 /* USB 3.0 */
 #ifdef CONFIG_USB_XHCI_HCD
-#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS 2
+#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS 3
+#define CONFIG_USB_MAX_CONTROLLER_COUNT CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS
 #endif
 
 /* MMC-SD */
diff --git a/include/usb.h b/include/usb.h
index d3c7415..79bd764 100644
--- a/include/usb.h
+++ b/include/usb.h
@@ -159,6 +159,7 @@ enum usb_init_type {
 
 int usb_lowlevel_init(int index, enum usb_init_type init, void **controller);
 int usb_lowlevel_stop(int index);
+int usb_device_tree_init(void);
 
 int submit_bulk_msg(struct usb_device *dev, unsigned long pipe,
 			void *buffer, int transfer_len);
-- 
1.9.1

