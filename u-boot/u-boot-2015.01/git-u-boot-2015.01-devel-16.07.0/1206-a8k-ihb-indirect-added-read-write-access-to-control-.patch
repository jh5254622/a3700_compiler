From 6370d1e3241e72a0bcd1ec434c92045dc27b3c6e Mon Sep 17 00:00:00 2001
From: Ahmad Abbas <ahmada@marvell.com>
Date: Wed, 1 Jun 2016 16:38:25 +0300
Subject: [PATCH 1206/1240] a8k: ihb: indirect: added read/write access to
 control region.

added read/write access to the control region registers using the
indirect command with ihb. added two new commands 'ctrl_read' and
'ctrl_write' to access the registers in the control region.

Change-Id: Iefba1efb350ebd7f6025380ae0575f888d63bd7c
Signed-off-by: Ahmad Abbas <ahmada@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/30246
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Haim Boot <hayim@marvell.com>
---
 .../include/asm/arch-mvebu/mvebu_phy_indirect.h    |  8 +++++--
 common/mvebu/cmd_phy_indirect.c                    | 23 +++++++++++++------
 drivers/misc/mvebu_phy_indirect.c                  | 26 ++++++++++------------
 3 files changed, 34 insertions(+), 23 deletions(-)

diff --git a/arch/arm/include/asm/arch-mvebu/mvebu_phy_indirect.h b/arch/arm/include/asm/arch-mvebu/mvebu_phy_indirect.h
index ce1d89f..cda5eac 100644
--- a/arch/arm/include/asm/arch-mvebu/mvebu_phy_indirect.h
+++ b/arch/arm/include/asm/arch-mvebu/mvebu_phy_indirect.h
@@ -24,13 +24,17 @@ enum phy_indirect_unit {
 	INDIRECT_MAX
 };
 
+enum ihb_region {
+	IHB_CTRL_REGION     = 0,
+	IHB_PHY_REG_REGION  = 3,
+};
 /*
  * Functions prototypes
  */
 
 int mvebu_phy_indirect_init(void);
-int mvebu_phy_indirect_read(enum phy_indirect_unit unit, int unit_id, int reg_ofs, u32 *val);
-int mvebu_phy_indirect_write(enum phy_indirect_unit unit, int unit_id, int reg_ofs, u32 val);
+int mvebu_phy_indirect_read(enum ihb_region region, enum phy_indirect_unit unit, int unit_id, int reg_ofs, u32 *val);
+int mvebu_phy_indirect_write(enum ihb_region region, enum phy_indirect_unit unit, int unit_id, int reg_ofs, u32 val);
 
 
 #endif /* __MVEBU_MMC_H__ */
diff --git a/common/mvebu/cmd_phy_indirect.c b/common/mvebu/cmd_phy_indirect.c
index b2dca4e..f3a167f 100644
--- a/common/mvebu/cmd_phy_indirect.c
+++ b/common/mvebu/cmd_phy_indirect.c
@@ -45,13 +45,13 @@ int do_indirect_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
 		return 1;
 	}
 
-	if ((strcmp(cmd, "write") == 0) && (argc < 6)) {
-		error("missing parameters for 'write' command\n");
+	if ((strcmp(cmd, "write") == 0 || strcmp(cmd, "ctrl_write") == 0) && (argc < 6)) {
+		error("missing parameters for 'write'/'ctrl_write' command\n");
 		printf("make sure you specify both offset and value\n");
 		return 1;
 	}
-	if ((strcmp(cmd, "read") == 0) && (argc < 5)) {
-		error("missing parameters for 'read' command\n");
+	if ((strcmp(cmd, "read") == 0 || strcmp(cmd, "ctrl_read") == 0) && (argc < 5)) {
+		error("missing parameters for 'read'/'ctrl_read' command\n");
 		printf("make sure you specify register offset\n");
 		return 1;
 	}
@@ -61,13 +61,22 @@ int do_indirect_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
 
 	/* read commnad */
 	if (strcmp(cmd, "read") == 0) {
-		if (mvebu_phy_indirect_read(phy_unit, unit_id, reg_ofs, &value))
+		if (mvebu_phy_indirect_read(IHB_PHY_REG_REGION, phy_unit, unit_id, reg_ofs, &value))
 			return 1;
 		printf("0x%x: 0x%x\n", reg_ofs, value);
 	} else if (strcmp(cmd, "write") == 0) {
 		value = simple_strtoul(argv[5], NULL, 16);
 
-		if (mvebu_phy_indirect_write(phy_unit, unit_id, reg_ofs, value))
+		if (mvebu_phy_indirect_write(IHB_PHY_REG_REGION, phy_unit, unit_id, reg_ofs, value))
+			return 1;
+	} else if (strcmp(cmd, "ctrl_read") == 0) {
+		if (mvebu_phy_indirect_read(IHB_CTRL_REGION, phy_unit, unit_id, reg_ofs, &value))
+			return 1;
+		printf("0x%x: 0x%x\n", reg_ofs, value);
+	} else if (strcmp(cmd, "ctrl_write") == 0) {
+		value = simple_strtoul(argv[5], NULL, 16);
+
+		if (mvebu_phy_indirect_write(IHB_CTRL_REGION, phy_unit, unit_id, reg_ofs, value))
 			return 1;
 	} else {
 		error("unknown command \"%s\"\n", cmd);
@@ -86,7 +95,7 @@ U_BOOT_CMD(
 	"Parameters:\n"
 	"\tunit		ihb\n"
 	"\tunit id		0/1\n"
-	"\tcommand		read/write\n"
+	"\tcommand		read/write/ctrl_read/ctrl_write\n"
 	"\toffset		register address\n"
 	"\tvalue		register data to write\n"
 	"Example: indirect ihb 0 read 0x20\n"
diff --git a/drivers/misc/mvebu_phy_indirect.c b/drivers/misc/mvebu_phy_indirect.c
index 3b7c7a6..4741dc3 100644
--- a/drivers/misc/mvebu_phy_indirect.c
+++ b/drivers/misc/mvebu_phy_indirect.c
@@ -78,10 +78,6 @@ enum ihb_access_type {
 	IHB_READ  = 1
 };
 
-enum ihb_region {
-	IHB_CTRL_REGION     = 0,
-	IHB_PHY_REG_REGION  = 3,
-};
 
 
 static int mvebu_ihb_poll_read_done(int reg_ofs, int unit_id)
@@ -115,7 +111,8 @@ static int mvebu_ihb_poll_read_done(int reg_ofs, int unit_id)
  *      (MSB are set to IHB_PHY_CTRL register (0x7) bit [28:27]
 */
 
-static int mvebu_ihb_command_set(enum ihb_access_type access_type, int reg_ofs,	u32 data, int unit_id)
+static int mvebu_ihb_command_set(enum ihb_access_type access_type, int reg_ofs,
+		u32 data, int unit_id, enum ihb_region region)
 {
 	u32 ihb_cmd_reg = 0;
 	u32 ihb_phy_ctrl_reg = 0;
@@ -146,20 +143,21 @@ static int mvebu_ihb_command_set(enum ihb_access_type access_type, int reg_ofs,
 		writel(data, MVEBU_IHB_PHY_BASE(unit_id) | MVEBU_IHB_PHY_DATA_REG_OFF);
 	}
 
-	ihb_cmd_reg = MVEBU_IHB_CMD_GET(access_type, IHB_PHY_REG_REGION, reg_ofs);
+	ihb_cmd_reg = MVEBU_IHB_CMD_GET(access_type, region, reg_ofs);
 	writel(ihb_cmd_reg, MVEBU_IHB_PHY_BASE(unit_id) | MVEBU_IHB_PHY_CMD_REG_OFF);		/* set commnd */
 
 	return 0;
 }
 
-static int mvebu_ihb_read(int reg_ofs, u32 *val, int unit_id)
+static int mvebu_ihb_read(int reg_ofs, u32 *val, int unit_id, enum ihb_region
+		region)
 {
 	/* initialize access to ihb phy (incase it wasn't already) */
 	if (!ihb_init_done)
 		mvebu_phy_indirect_init();
 
 	/* set read command */
-	if (mvebu_ihb_command_set(IHB_READ, reg_ofs, 0 /* dummy */, unit_id)) {
+	if (mvebu_ihb_command_set(IHB_READ, reg_ofs, 0 /* dummy */, unit_id, region)) {
 		error("IHB read: set command failed\n");
 		return 1;
 	}
@@ -173,14 +171,14 @@ static int mvebu_ihb_read(int reg_ofs, u32 *val, int unit_id)
 	return 0;
 }
 
-static int mvebu_ihb_write(int reg_ofs, u32 data, int unit_id)
+static int mvebu_ihb_write(int reg_ofs, u32 data, int unit_id, enum ihb_region region)
 {
 	/* initialize access to ihb phy (incase it wasn't already) */
 	if (!ihb_init_done)
 		mvebu_phy_indirect_init();
 
 	/* set write command */
-	if (mvebu_ihb_command_set(IHB_WRITE, reg_ofs, data, unit_id)) {
+	if (mvebu_ihb_command_set(IHB_WRITE, reg_ofs, data, unit_id, region)) {
 		error("IHB write: set command failed\n");
 		return 1;
 	}
@@ -188,22 +186,22 @@ static int mvebu_ihb_write(int reg_ofs, u32 data, int unit_id)
 	return 0;
 }
 
-int mvebu_phy_indirect_read(enum phy_indirect_unit phy_unit, int unit_id, int reg_ofs, u32 *val)
+int mvebu_phy_indirect_read(enum ihb_region region, enum phy_indirect_unit phy_unit, int unit_id, int reg_ofs, u32 *val)
 {
 	switch (phy_unit) {
 	case INDIRECT_IHB:
-		return mvebu_ihb_read(reg_ofs, val, unit_id);
+		return mvebu_ihb_read(reg_ofs, val, unit_id, region);
 	default:
 		error("unit %d is not supported\n", phy_unit);
 		return 1;
 	}
 }
 
-int mvebu_phy_indirect_write(enum phy_indirect_unit phy_unit, int unit_id, int reg_ofs, u32 val)
+int mvebu_phy_indirect_write(enum ihb_region region, enum phy_indirect_unit phy_unit, int unit_id, int reg_ofs, u32 val)
 {
 	switch (phy_unit) {
 	case INDIRECT_IHB:
-		return mvebu_ihb_write(reg_ofs, val, unit_id);
+		return mvebu_ihb_write(reg_ofs, val, unit_id, region);
 	default:
 		error("unit %d is not supported\n", phy_unit);
 		return 1;
-- 
1.9.1

